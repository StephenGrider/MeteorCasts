{"metadata":{"usedHelpers":[],"marked":[],"modules":{"imports":[],"exports":{"exported":[],"specifiers":[]}}},"options":{"filename":"/packages/mongo/oplog_tailing.js","filenameRelative":"/packages/mongo/oplog_tailing.js","env":{},"retainLines":false,"highlightCode":true,"suppressDeprecationMessages":false,"presets":[],"plugins":[[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],{"polyfill":false}],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],{"loose":true}],[[],{"loose":true}],[[],null],[[],{"loose":true}],[[],null],[[],null],[[],{"allowTopLevelThis":true,"strict":false,"loose":true}],[[],null],[[],null],[[],null],[[],null],[[],null],[[],{"loose":true}],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null]],"ignore":[],"code":true,"metadata":true,"ast":false,"comments":true,"compact":false,"minified":false,"sourceMap":true,"sourceMaps":true,"sourceMapTarget":"/packages/mongo/oplog_tailing.js.map","sourceFileName":"/packages/mongo/oplog_tailing.js","babelrc":false,"sourceType":"module","moduleIds":false,"passPerPreset":false,"basename":"oplog_tailing"},"ignored":false,"code":"var Future = Npm.require('fibers/future');\n\nOPLOG_COLLECTION = 'oplog.rs';\n\nvar TOO_FAR_BEHIND = process.env.METEOR_OPLOG_TOO_FAR_BEHIND || 2000;\n\nvar showTS = function showTS(ts) {\n  return \"Timestamp(\" + ts.getHighBits() + \", \" + ts.getLowBits() + \")\";\n};\n\nidForOp = function idForOp(op) {\n  if (op.op === 'd') return op.o._id;else if (op.op === 'i') return op.o._id;else if (op.op === 'u') return op.o2._id;else if (op.op === 'c') throw Error(\"Operator 'c' doesn't supply an object with id: \" + EJSON.stringify(op));else throw Error(\"Unknown op: \" + EJSON.stringify(op));\n};\n\nOplogHandle = function OplogHandle(oplogUrl, dbName) {\n  var self = this;\n  self._oplogUrl = oplogUrl;\n  self._dbName = dbName;\n\n  self._oplogLastEntryConnection = null;\n  self._oplogTailConnection = null;\n  self._stopped = false;\n  self._tailHandle = null;\n  self._readyFuture = new Future();\n  self._crossbar = new DDPServer._Crossbar({\n    factPackage: \"mongo-livedata\", factName: \"oplog-watchers\"\n  });\n  self._baseOplogSelector = {\n    ns: new RegExp('^' + Meteor._escapeRegExp(self._dbName) + '\\\\.'),\n    $or: [{ op: { $in: ['i', 'u', 'd'] } },\n    // drop collection\n    { op: 'c', 'o.drop': { $exists: true } }, { op: 'c', 'o.dropDatabase': 1 }]\n  };\n\n  // Data structures to support waitUntilCaughtUp(). Each oplog entry has a\n  // MongoTimestamp object on it (which is not the same as a Date --- it's a\n  // combination of time and an incrementing counter; see\n  // http://docs.mongodb.org/manual/reference/bson-types/#timestamps).\n  //\n  // _catchingUpFutures is an array of {ts: MongoTimestamp, future: Future}\n  // objects, sorted by ascending timestamp. _lastProcessedTS is the\n  // MongoTimestamp of the last oplog entry we've processed.\n  //\n  // Each time we call waitUntilCaughtUp, we take a peek at the final oplog\n  // entry in the db.  If we've already processed it (ie, it is not greater than\n  // _lastProcessedTS), waitUntilCaughtUp immediately returns. Otherwise,\n  // waitUntilCaughtUp makes a new Future and inserts it along with the final\n  // timestamp entry that it read, into _catchingUpFutures. waitUntilCaughtUp\n  // then waits on that future, which is resolved once _lastProcessedTS is\n  // incremented to be past its timestamp by the worker fiber.\n  //\n  // XXX use a priority queue or something else that's faster than an array\n  self._catchingUpFutures = [];\n  self._lastProcessedTS = null;\n\n  self._onSkippedEntriesHook = new Hook({\n    debugPrintExceptions: \"onSkippedEntries callback\"\n  });\n\n  self._entryQueue = new Meteor._DoubleEndedQueue();\n  self._workerActive = false;\n\n  self._startTailing();\n};\n\n_.extend(OplogHandle.prototype, {\n  stop: function () {\n    function stop() {\n      var self = this;\n      if (self._stopped) return;\n      self._stopped = true;\n      if (self._tailHandle) self._tailHandle.stop();\n      // XXX should close connections too\n    }\n\n    return stop;\n  }(),\n  onOplogEntry: function () {\n    function onOplogEntry(trigger, callback) {\n      var self = this;\n      if (self._stopped) throw new Error(\"Called onOplogEntry on stopped handle!\");\n\n      // Calling onOplogEntry requires us to wait for the tailing to be ready.\n      self._readyFuture.wait();\n\n      var originalCallback = callback;\n      callback = Meteor.bindEnvironment(function (notification) {\n        // XXX can we avoid this clone by making oplog.js careful?\n        originalCallback(EJSON.clone(notification));\n      }, function (err) {\n        Meteor._debug(\"Error in oplog callback\", err.stack);\n      });\n      var listenHandle = self._crossbar.listen(trigger, callback);\n      return {\n        stop: function () {\n          function stop() {\n            listenHandle.stop();\n          }\n\n          return stop;\n        }()\n      };\n    }\n\n    return onOplogEntry;\n  }(),\n  // Register a callback to be invoked any time we skip oplog entries (eg,\n  // because we are too far behind).\n  onSkippedEntries: function () {\n    function onSkippedEntries(callback) {\n      var self = this;\n      if (self._stopped) throw new Error(\"Called onSkippedEntries on stopped handle!\");\n      return self._onSkippedEntriesHook.register(callback);\n    }\n\n    return onSkippedEntries;\n  }(),\n  // Calls `callback` once the oplog has been processed up to a point that is\n  // roughly \"now\": specifically, once we've processed all ops that are\n  // currently visible.\n  // XXX become convinced that this is actually safe even if oplogConnection\n  // is some kind of pool\n  waitUntilCaughtUp: function () {\n    function waitUntilCaughtUp() {\n      var self = this;\n      if (self._stopped) throw new Error(\"Called waitUntilCaughtUp on stopped handle!\");\n\n      // Calling waitUntilCaughtUp requries us to wait for the oplog connection to\n      // be ready.\n      self._readyFuture.wait();\n\n      while (!self._stopped) {\n        // We need to make the selector at least as restrictive as the actual\n        // tailing selector (ie, we need to specify the DB name) or else we might\n        // find a TS that won't show up in the actual tail stream.\n        try {\n          var lastEntry = self._oplogLastEntryConnection.findOne(OPLOG_COLLECTION, self._baseOplogSelector, { fields: { ts: 1 }, sort: { $natural: -1 } });\n          break;\n        } catch (e) {\n          // During failover (eg) if we get an exception we should log and retry\n          // instead of crashing.\n          Meteor._debug(\"Got exception while reading last entry: \" + e);\n          Meteor._sleepForMs(100);\n        }\n      }\n\n      if (self._stopped) return;\n\n      if (!lastEntry) {\n        // Really, nothing in the oplog? Well, we've processed everything.\n        return;\n      }\n\n      var ts = lastEntry.ts;\n      if (!ts) throw Error(\"oplog entry without ts: \" + EJSON.stringify(lastEntry));\n\n      if (self._lastProcessedTS && ts.lessThanOrEqual(self._lastProcessedTS)) {\n        // We've already caught up to here.\n        return;\n      }\n\n      // Insert the future into our list. Almost always, this will be at the end,\n      // but it's conceivable that if we fail over from one primary to another,\n      // the oplog entries we see will go backwards.\n      var insertAfter = self._catchingUpFutures.length;\n      while (insertAfter - 1 > 0 && self._catchingUpFutures[insertAfter - 1].ts.greaterThan(ts)) {\n        insertAfter--;\n      }\n      var f = new Future();\n      self._catchingUpFutures.splice(insertAfter, 0, { ts: ts, future: f });\n      f.wait();\n    }\n\n    return waitUntilCaughtUp;\n  }(),\n  _startTailing: function () {\n    function _startTailing() {\n      var self = this;\n      // First, make sure that we're talking to the local database.\n      var mongodbUri = Npm.require('mongodb-uri');\n      if (mongodbUri.parse(self._oplogUrl).database !== 'local') {\n        throw Error(\"$MONGO_OPLOG_URL must be set to the 'local' database of \" + \"a Mongo replica set\");\n      }\n\n      // We make two separate connections to Mongo. The Node Mongo driver\n      // implements a naive round-robin connection pool: each \"connection\" is a\n      // pool of several (5 by default) TCP connections, and each request is\n      // rotated through the pools. Tailable cursor queries block on the server\n      // until there is some data to return (or until a few seconds have\n      // passed). So if the connection pool used for tailing cursors is the same\n      // pool used for other queries, the other queries will be delayed by seconds\n      // 1/5 of the time.\n      //\n      // The tail connection will only ever be running a single tail command, so\n      // it only needs to make one underlying TCP connection.\n      self._oplogTailConnection = new MongoConnection(self._oplogUrl, { poolSize: 1 });\n      // XXX better docs, but: it's to get monotonic results\n      // XXX is it safe to say \"if there's an in flight query, just use its\n      //     results\"? I don't think so but should consider that\n      self._oplogLastEntryConnection = new MongoConnection(self._oplogUrl, { poolSize: 1 });\n\n      // Now, make sure that there actually is a repl set here. If not, oplog\n      // tailing won't ever find anything!\n      var f = new Future();\n      self._oplogLastEntryConnection.db.admin().command({ ismaster: 1 }, f.resolver());\n      var isMasterDoc = f.wait();\n      if (!(isMasterDoc && isMasterDoc.documents && isMasterDoc.documents[0] && isMasterDoc.documents[0].setName)) {\n        throw Error(\"$MONGO_OPLOG_URL must be set to the 'local' database of \" + \"a Mongo replica set\");\n      }\n\n      // Find the last oplog entry.\n      var lastOplogEntry = self._oplogLastEntryConnection.findOne(OPLOG_COLLECTION, {}, { sort: { $natural: -1 }, fields: { ts: 1 } });\n\n      var oplogSelector = _.clone(self._baseOplogSelector);\n      if (lastOplogEntry) {\n        // Start after the last entry that currently exists.\n        oplogSelector.ts = { $gt: lastOplogEntry.ts };\n        // If there are any calls to callWhenProcessedLatest before any other\n        // oplog entries show up, allow callWhenProcessedLatest to call its\n        // callback immediately.\n        self._lastProcessedTS = lastOplogEntry.ts;\n      }\n\n      var cursorDescription = new CursorDescription(OPLOG_COLLECTION, oplogSelector, { tailable: true });\n\n      self._tailHandle = self._oplogTailConnection.tail(cursorDescription, function (doc) {\n        self._entryQueue.push(doc);\n        self._maybeStartWorker();\n      });\n      self._readyFuture['return']();\n    }\n\n    return _startTailing;\n  }(),\n\n  _maybeStartWorker: function () {\n    function _maybeStartWorker() {\n      var self = this;\n      if (self._workerActive) return;\n      self._workerActive = true;\n      Meteor.defer(function () {\n        try {\n          while (!self._stopped && !self._entryQueue.isEmpty()) {\n            // Are we too far behind? Just tell our observers that they need to\n            // repoll, and drop our queue.\n            if (self._entryQueue.length > TOO_FAR_BEHIND) {\n              var lastEntry = self._entryQueue.pop();\n              self._entryQueue.clear();\n\n              self._onSkippedEntriesHook.each(function (callback) {\n                callback();\n                return true;\n              });\n\n              // Free any waitUntilCaughtUp() calls that were waiting for us to\n              // pass something that we just skipped.\n              self._setLastProcessedTS(lastEntry.ts);\n              continue;\n            }\n\n            var doc = self._entryQueue.shift();\n\n            if (!(doc.ns && doc.ns.length > self._dbName.length + 1 && doc.ns.substr(0, self._dbName.length + 1) === self._dbName + '.')) {\n              throw new Error(\"Unexpected ns\");\n            }\n\n            var trigger = { collection: doc.ns.substr(self._dbName.length + 1),\n              dropCollection: false,\n              dropDatabase: false,\n              op: doc };\n\n            // Is it a special command and the collection name is hidden somewhere\n            // in operator?\n            if (trigger.collection === \"$cmd\") {\n              if (doc.o.dropDatabase) {\n                delete trigger.collection;\n                trigger.dropDatabase = true;\n              } else if (_.has(doc.o, 'drop')) {\n                trigger.collection = doc.o.drop;\n                trigger.dropCollection = true;\n                trigger.id = null;\n              } else {\n                throw Error(\"Unknown command \" + JSON.stringify(doc));\n              }\n            } else {\n              // All other ops have an id.\n              trigger.id = idForOp(doc);\n            }\n\n            self._crossbar.fire(trigger);\n\n            // Now that we've processed this operation, process pending\n            // sequencers.\n            if (!doc.ts) throw Error(\"oplog entry without ts: \" + EJSON.stringify(doc));\n            self._setLastProcessedTS(doc.ts);\n          }\n        } finally {\n          self._workerActive = false;\n        }\n      });\n    }\n\n    return _maybeStartWorker;\n  }(),\n  _setLastProcessedTS: function () {\n    function _setLastProcessedTS(ts) {\n      var self = this;\n      self._lastProcessedTS = ts;\n      while (!_.isEmpty(self._catchingUpFutures) && self._catchingUpFutures[0].ts.lessThanOrEqual(self._lastProcessedTS)) {\n        var sequencer = self._catchingUpFutures.shift();\n        sequencer.future['return']();\n      }\n    }\n\n    return _setLastProcessedTS;\n  }()\n});","ast":null,"map":{"version":3,"sources":["/packages/mongo/oplog_tailing.js"],"names":[],"mappings":"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","file":"/packages/mongo/oplog_tailing.js.map","sourcesContent":["var Future = Npm.require('fibers/future');\n\nOPLOG_COLLECTION = 'oplog.rs';\n\nvar TOO_FAR_BEHIND = process.env.METEOR_OPLOG_TOO_FAR_BEHIND || 2000;\n\nvar showTS = function (ts) {\n  return \"Timestamp(\" + ts.getHighBits() + \", \" + ts.getLowBits() + \")\";\n};\n\nidForOp = function (op) {\n  if (op.op === 'd')\n    return op.o._id;\n  else if (op.op === 'i')\n    return op.o._id;\n  else if (op.op === 'u')\n    return op.o2._id;\n  else if (op.op === 'c')\n    throw Error(\"Operator 'c' doesn't supply an object with id: \" +\n                EJSON.stringify(op));\n  else\n    throw Error(\"Unknown op: \" + EJSON.stringify(op));\n};\n\nOplogHandle = function (oplogUrl, dbName) {\n  var self = this;\n  self._oplogUrl = oplogUrl;\n  self._dbName = dbName;\n\n  self._oplogLastEntryConnection = null;\n  self._oplogTailConnection = null;\n  self._stopped = false;\n  self._tailHandle = null;\n  self._readyFuture = new Future();\n  self._crossbar = new DDPServer._Crossbar({\n    factPackage: \"mongo-livedata\", factName: \"oplog-watchers\"\n  });\n  self._baseOplogSelector = {\n    ns: new RegExp('^' + Meteor._escapeRegExp(self._dbName) + '\\\\.'),\n    $or: [\n      { op: {$in: ['i', 'u', 'd']} },\n      // drop collection\n      { op: 'c', 'o.drop': { $exists: true } },\n      { op: 'c', 'o.dropDatabase': 1 },\n    ]\n  };\n\n  // Data structures to support waitUntilCaughtUp(). Each oplog entry has a\n  // MongoTimestamp object on it (which is not the same as a Date --- it's a\n  // combination of time and an incrementing counter; see\n  // http://docs.mongodb.org/manual/reference/bson-types/#timestamps).\n  //\n  // _catchingUpFutures is an array of {ts: MongoTimestamp, future: Future}\n  // objects, sorted by ascending timestamp. _lastProcessedTS is the\n  // MongoTimestamp of the last oplog entry we've processed.\n  //\n  // Each time we call waitUntilCaughtUp, we take a peek at the final oplog\n  // entry in the db.  If we've already processed it (ie, it is not greater than\n  // _lastProcessedTS), waitUntilCaughtUp immediately returns. Otherwise,\n  // waitUntilCaughtUp makes a new Future and inserts it along with the final\n  // timestamp entry that it read, into _catchingUpFutures. waitUntilCaughtUp\n  // then waits on that future, which is resolved once _lastProcessedTS is\n  // incremented to be past its timestamp by the worker fiber.\n  //\n  // XXX use a priority queue or something else that's faster than an array\n  self._catchingUpFutures = [];\n  self._lastProcessedTS = null;\n\n  self._onSkippedEntriesHook = new Hook({\n    debugPrintExceptions: \"onSkippedEntries callback\"\n  });\n\n  self._entryQueue = new Meteor._DoubleEndedQueue();\n  self._workerActive = false;\n\n  self._startTailing();\n};\n\n_.extend(OplogHandle.prototype, {\n  stop: function () {\n    var self = this;\n    if (self._stopped)\n      return;\n    self._stopped = true;\n    if (self._tailHandle)\n      self._tailHandle.stop();\n    // XXX should close connections too\n  },\n  onOplogEntry: function (trigger, callback) {\n    var self = this;\n    if (self._stopped)\n      throw new Error(\"Called onOplogEntry on stopped handle!\");\n\n    // Calling onOplogEntry requires us to wait for the tailing to be ready.\n    self._readyFuture.wait();\n\n    var originalCallback = callback;\n    callback = Meteor.bindEnvironment(function (notification) {\n      // XXX can we avoid this clone by making oplog.js careful?\n      originalCallback(EJSON.clone(notification));\n    }, function (err) {\n      Meteor._debug(\"Error in oplog callback\", err.stack);\n    });\n    var listenHandle = self._crossbar.listen(trigger, callback);\n    return {\n      stop: function () {\n        listenHandle.stop();\n      }\n    };\n  },\n  // Register a callback to be invoked any time we skip oplog entries (eg,\n  // because we are too far behind).\n  onSkippedEntries: function (callback) {\n    var self = this;\n    if (self._stopped)\n      throw new Error(\"Called onSkippedEntries on stopped handle!\");\n    return self._onSkippedEntriesHook.register(callback);\n  },\n  // Calls `callback` once the oplog has been processed up to a point that is\n  // roughly \"now\": specifically, once we've processed all ops that are\n  // currently visible.\n  // XXX become convinced that this is actually safe even if oplogConnection\n  // is some kind of pool\n  waitUntilCaughtUp: function () {\n    var self = this;\n    if (self._stopped)\n      throw new Error(\"Called waitUntilCaughtUp on stopped handle!\");\n\n    // Calling waitUntilCaughtUp requries us to wait for the oplog connection to\n    // be ready.\n    self._readyFuture.wait();\n\n    while (!self._stopped) {\n      // We need to make the selector at least as restrictive as the actual\n      // tailing selector (ie, we need to specify the DB name) or else we might\n      // find a TS that won't show up in the actual tail stream.\n      try {\n        var lastEntry = self._oplogLastEntryConnection.findOne(\n          OPLOG_COLLECTION, self._baseOplogSelector,\n          {fields: {ts: 1}, sort: {$natural: -1}});\n        break;\n      } catch (e) {\n        // During failover (eg) if we get an exception we should log and retry\n        // instead of crashing.\n        Meteor._debug(\"Got exception while reading last entry: \" + e);\n        Meteor._sleepForMs(100);\n      }\n    }\n\n    if (self._stopped)\n      return;\n\n    if (!lastEntry) {\n      // Really, nothing in the oplog? Well, we've processed everything.\n      return;\n    }\n\n    var ts = lastEntry.ts;\n    if (!ts)\n      throw Error(\"oplog entry without ts: \" + EJSON.stringify(lastEntry));\n\n    if (self._lastProcessedTS && ts.lessThanOrEqual(self._lastProcessedTS)) {\n      // We've already caught up to here.\n      return;\n    }\n\n\n    // Insert the future into our list. Almost always, this will be at the end,\n    // but it's conceivable that if we fail over from one primary to another,\n    // the oplog entries we see will go backwards.\n    var insertAfter = self._catchingUpFutures.length;\n    while (insertAfter - 1 > 0\n           && self._catchingUpFutures[insertAfter - 1].ts.greaterThan(ts)) {\n      insertAfter--;\n    }\n    var f = new Future;\n    self._catchingUpFutures.splice(insertAfter, 0, {ts: ts, future: f});\n    f.wait();\n  },\n  _startTailing: function () {\n    var self = this;\n    // First, make sure that we're talking to the local database.\n    var mongodbUri = Npm.require('mongodb-uri');\n    if (mongodbUri.parse(self._oplogUrl).database !== 'local') {\n      throw Error(\"$MONGO_OPLOG_URL must be set to the 'local' database of \" +\n                  \"a Mongo replica set\");\n    }\n\n    // We make two separate connections to Mongo. The Node Mongo driver\n    // implements a naive round-robin connection pool: each \"connection\" is a\n    // pool of several (5 by default) TCP connections, and each request is\n    // rotated through the pools. Tailable cursor queries block on the server\n    // until there is some data to return (or until a few seconds have\n    // passed). So if the connection pool used for tailing cursors is the same\n    // pool used for other queries, the other queries will be delayed by seconds\n    // 1/5 of the time.\n    //\n    // The tail connection will only ever be running a single tail command, so\n    // it only needs to make one underlying TCP connection.\n    self._oplogTailConnection = new MongoConnection(\n      self._oplogUrl, {poolSize: 1});\n    // XXX better docs, but: it's to get monotonic results\n    // XXX is it safe to say \"if there's an in flight query, just use its\n    //     results\"? I don't think so but should consider that\n    self._oplogLastEntryConnection = new MongoConnection(\n      self._oplogUrl, {poolSize: 1});\n\n    // Now, make sure that there actually is a repl set here. If not, oplog\n    // tailing won't ever find anything!\n    var f = new Future;\n    self._oplogLastEntryConnection.db.admin().command(\n      { ismaster: 1 }, f.resolver());\n    var isMasterDoc = f.wait();\n    if (!(isMasterDoc && isMasterDoc.documents && isMasterDoc.documents[0] &&\n          isMasterDoc.documents[0].setName)) {\n      throw Error(\"$MONGO_OPLOG_URL must be set to the 'local' database of \" +\n                  \"a Mongo replica set\");\n    }\n\n    // Find the last oplog entry.\n    var lastOplogEntry = self._oplogLastEntryConnection.findOne(\n      OPLOG_COLLECTION, {}, {sort: {$natural: -1}, fields: {ts: 1}});\n\n    var oplogSelector = _.clone(self._baseOplogSelector);\n    if (lastOplogEntry) {\n      // Start after the last entry that currently exists.\n      oplogSelector.ts = {$gt: lastOplogEntry.ts};\n      // If there are any calls to callWhenProcessedLatest before any other\n      // oplog entries show up, allow callWhenProcessedLatest to call its\n      // callback immediately.\n      self._lastProcessedTS = lastOplogEntry.ts;\n    }\n\n    var cursorDescription = new CursorDescription(\n      OPLOG_COLLECTION, oplogSelector, {tailable: true});\n\n    self._tailHandle = self._oplogTailConnection.tail(\n      cursorDescription, function (doc) {\n        self._entryQueue.push(doc);\n        self._maybeStartWorker();\n      }\n    );\n    self._readyFuture.return();\n  },\n\n  _maybeStartWorker: function () {\n    var self = this;\n    if (self._workerActive)\n      return;\n    self._workerActive = true;\n    Meteor.defer(function () {\n      try {\n        while (! self._stopped && ! self._entryQueue.isEmpty()) {\n          // Are we too far behind? Just tell our observers that they need to\n          // repoll, and drop our queue.\n          if (self._entryQueue.length > TOO_FAR_BEHIND) {\n            var lastEntry = self._entryQueue.pop();\n            self._entryQueue.clear();\n\n            self._onSkippedEntriesHook.each(function (callback) {\n              callback();\n              return true;\n            });\n\n            // Free any waitUntilCaughtUp() calls that were waiting for us to\n            // pass something that we just skipped.\n            self._setLastProcessedTS(lastEntry.ts);\n            continue;\n          }\n\n          var doc = self._entryQueue.shift();\n\n          if (!(doc.ns && doc.ns.length > self._dbName.length + 1 &&\n                doc.ns.substr(0, self._dbName.length + 1) ===\n                (self._dbName + '.'))) {\n            throw new Error(\"Unexpected ns\");\n          }\n\n          var trigger = {collection: doc.ns.substr(self._dbName.length + 1),\n                         dropCollection: false,\n                         dropDatabase: false,\n                         op: doc};\n\n          // Is it a special command and the collection name is hidden somewhere\n          // in operator?\n          if (trigger.collection === \"$cmd\") {\n            if (doc.o.dropDatabase) {\n              delete trigger.collection;\n              trigger.dropDatabase = true;\n            } else if (_.has(doc.o, 'drop')) {\n              trigger.collection = doc.o.drop;\n              trigger.dropCollection = true;\n              trigger.id = null;\n            } else {\n              throw Error(\"Unknown command \" + JSON.stringify(doc));\n            }\n          } else {\n            // All other ops have an id.\n            trigger.id = idForOp(doc);\n          }\n\n          self._crossbar.fire(trigger);\n\n          // Now that we've processed this operation, process pending\n          // sequencers.\n          if (!doc.ts)\n            throw Error(\"oplog entry without ts: \" + EJSON.stringify(doc));\n          self._setLastProcessedTS(doc.ts);\n        }\n      } finally {\n        self._workerActive = false;\n      }\n    });\n  },\n  _setLastProcessedTS: function (ts) {\n    var self = this;\n    self._lastProcessedTS = ts;\n    while (!_.isEmpty(self._catchingUpFutures)\n           && self._catchingUpFutures[0].ts.lessThanOrEqual(\n             self._lastProcessedTS)) {\n      var sequencer = self._catchingUpFutures.shift();\n      sequencer.future.return();\n    }\n  }\n});\n"]},"hash":"e65369b4b7f194a06804deb2c374b301563b07c4"}
