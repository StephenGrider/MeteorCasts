{"metadata":{"usedHelpers":[],"marked":[],"modules":{"imports":[],"exports":{"exported":[],"specifiers":[]}}},"options":{"filename":"/packages/mongo/observe_multiplex.js","filenameRelative":"/packages/mongo/observe_multiplex.js","env":{},"retainLines":false,"highlightCode":true,"suppressDeprecationMessages":false,"presets":[],"plugins":[[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],{"polyfill":false}],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],{"loose":true}],[[],{"loose":true}],[[],null],[[],{"loose":true}],[[],null],[[],null],[[],{"allowTopLevelThis":true,"strict":false,"loose":true}],[[],null],[[],null],[[],null],[[],null],[[],null],[[],{"loose":true}],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null]],"ignore":[],"code":true,"metadata":true,"ast":false,"comments":true,"compact":false,"minified":false,"sourceMap":true,"sourceMaps":true,"sourceMapTarget":"/packages/mongo/observe_multiplex.js.map","sourceFileName":"/packages/mongo/observe_multiplex.js","babelrc":false,"sourceType":"module","moduleIds":false,"passPerPreset":false,"basename":"observe_multiplex"},"ignored":false,"code":"var Future = Npm.require('fibers/future');\n\nObserveMultiplexer = function ObserveMultiplexer(options) {\n  var self = this;\n\n  if (!options || !_.has(options, 'ordered')) throw Error(\"must specified ordered\");\n\n  Package.facts && Package.facts.Facts.incrementServerFact(\"mongo-livedata\", \"observe-multiplexers\", 1);\n\n  self._ordered = options.ordered;\n  self._onStop = options.onStop || function () {};\n  self._queue = new Meteor._SynchronousQueue();\n  self._handles = {};\n  self._readyFuture = new Future();\n  self._cache = new LocalCollection._CachingChangeObserver({\n    ordered: options.ordered });\n  // Number of addHandleAndSendInitialAdds tasks scheduled but not yet\n  // running. removeHandle uses this to know if it's time to call the onStop\n  // callback.\n  self._addHandleTasksScheduledButNotPerformed = 0;\n\n  _.each(self.callbackNames(), function (callbackName) {\n    self[callbackName] = function () /* ... */{\n      self._applyCallback(callbackName, _.toArray(arguments));\n    };\n  });\n};\n\n_.extend(ObserveMultiplexer.prototype, {\n  addHandleAndSendInitialAdds: function () {\n    function addHandleAndSendInitialAdds(handle) {\n      var self = this;\n\n      // Check this before calling runTask (even though runTask does the same\n      // check) so that we don't leak an ObserveMultiplexer on error by\n      // incrementing _addHandleTasksScheduledButNotPerformed and never\n      // decrementing it.\n      if (!self._queue.safeToRunTask()) throw new Error(\"Can't call observeChanges from an observe callback on the same query\");\n      ++self._addHandleTasksScheduledButNotPerformed;\n\n      Package.facts && Package.facts.Facts.incrementServerFact(\"mongo-livedata\", \"observe-handles\", 1);\n\n      self._queue.runTask(function () {\n        self._handles[handle._id] = handle;\n        // Send out whatever adds we have so far (whether or not we the\n        // multiplexer is ready).\n        self._sendAdds(handle);\n        --self._addHandleTasksScheduledButNotPerformed;\n      });\n      // *outside* the task, since otherwise we'd deadlock\n      self._readyFuture.wait();\n    }\n\n    return addHandleAndSendInitialAdds;\n  }(),\n\n  // Remove an observe handle. If it was the last observe handle, call the\n  // onStop callback; you cannot add any more observe handles after this.\n  //\n  // This is not synchronized with polls and handle additions: this means that\n  // you can safely call it from within an observe callback, but it also means\n  // that we have to be careful when we iterate over _handles.\n  removeHandle: function () {\n    function removeHandle(id) {\n      var self = this;\n\n      // This should not be possible: you can only call removeHandle by having\n      // access to the ObserveHandle, which isn't returned to user code until the\n      // multiplex is ready.\n      if (!self._ready()) throw new Error(\"Can't remove handles until the multiplex is ready\");\n\n      delete self._handles[id];\n\n      Package.facts && Package.facts.Facts.incrementServerFact(\"mongo-livedata\", \"observe-handles\", -1);\n\n      if (_.isEmpty(self._handles) && self._addHandleTasksScheduledButNotPerformed === 0) {\n        self._stop();\n      }\n    }\n\n    return removeHandle;\n  }(),\n  _stop: function () {\n    function _stop(options) {\n      var self = this;\n      options = options || {};\n\n      // It shouldn't be possible for us to stop when all our handles still\n      // haven't been returned from observeChanges!\n      if (!self._ready() && !options.fromQueryError) throw Error(\"surprising _stop: not ready\");\n\n      // Call stop callback (which kills the underlying process which sends us\n      // callbacks and removes us from the connection's dictionary).\n      self._onStop();\n      Package.facts && Package.facts.Facts.incrementServerFact(\"mongo-livedata\", \"observe-multiplexers\", -1);\n\n      // Cause future addHandleAndSendInitialAdds calls to throw (but the onStop\n      // callback should make our connection forget about us).\n      self._handles = null;\n    }\n\n    return _stop;\n  }(),\n\n  // Allows all addHandleAndSendInitialAdds calls to return, once all preceding\n  // adds have been processed. Does not block.\n  ready: function () {\n    function ready() {\n      var self = this;\n      self._queue.queueTask(function () {\n        if (self._ready()) throw Error(\"can't make ObserveMultiplex ready twice!\");\n        self._readyFuture['return']();\n      });\n    }\n\n    return ready;\n  }(),\n\n  // If trying to execute the query results in an error, call this. This is\n  // intended for permanent errors, not transient network errors that could be\n  // fixed. It should only be called before ready(), because if you called ready\n  // that meant that you managed to run the query once. It will stop this\n  // ObserveMultiplex and cause addHandleAndSendInitialAdds calls (and thus\n  // observeChanges calls) to throw the error.\n  queryError: function () {\n    function queryError(err) {\n      var self = this;\n      self._queue.runTask(function () {\n        if (self._ready()) throw Error(\"can't claim query has an error after it worked!\");\n        self._stop({ fromQueryError: true });\n        self._readyFuture['throw'](err);\n      });\n    }\n\n    return queryError;\n  }(),\n\n  // Calls \"cb\" once the effects of all \"ready\", \"addHandleAndSendInitialAdds\"\n  // and observe callbacks which came before this call have been propagated to\n  // all handles. \"ready\" must have already been called on this multiplexer.\n  onFlush: function () {\n    function onFlush(cb) {\n      var self = this;\n      self._queue.queueTask(function () {\n        if (!self._ready()) throw Error(\"only call onFlush on a multiplexer that will be ready\");\n        cb();\n      });\n    }\n\n    return onFlush;\n  }(),\n  callbackNames: function () {\n    function callbackNames() {\n      var self = this;\n      if (self._ordered) return [\"addedBefore\", \"changed\", \"movedBefore\", \"removed\"];else return [\"added\", \"changed\", \"removed\"];\n    }\n\n    return callbackNames;\n  }(),\n  _ready: function () {\n    function _ready() {\n      return this._readyFuture.isResolved();\n    }\n\n    return _ready;\n  }(),\n  _applyCallback: function () {\n    function _applyCallback(callbackName, args) {\n      var self = this;\n      self._queue.queueTask(function () {\n        // If we stopped in the meantime, do nothing.\n        if (!self._handles) return;\n\n        // First, apply the change to the cache.\n        // XXX We could make applyChange callbacks promise not to hang on to any\n        // state from their arguments (assuming that their supplied callbacks\n        // don't) and skip this clone. Currently 'changed' hangs on to state\n        // though.\n        self._cache.applyChange[callbackName].apply(null, EJSON.clone(args));\n\n        // If we haven't finished the initial adds, then we should only be getting\n        // adds.\n        if (!self._ready() && callbackName !== 'added' && callbackName !== 'addedBefore') {\n          throw new Error(\"Got \" + callbackName + \" during initial adds\");\n        }\n\n        // Now multiplex the callbacks out to all observe handles. It's OK if\n        // these calls yield; since we're inside a task, no other use of our queue\n        // can continue until these are done. (But we do have to be careful to not\n        // use a handle that got removed, because removeHandle does not use the\n        // queue; thus, we iterate over an array of keys that we control.)\n        _.each(_.keys(self._handles), function (handleId) {\n          var handle = self._handles && self._handles[handleId];\n          if (!handle) return;\n          var callback = handle['_' + callbackName];\n          // clone arguments so that callbacks can mutate their arguments\n          callback && callback.apply(null, EJSON.clone(args));\n        });\n      });\n    }\n\n    return _applyCallback;\n  }(),\n\n  // Sends initial adds to a handle. It should only be called from within a task\n  // (the task that is processing the addHandleAndSendInitialAdds call). It\n  // synchronously invokes the handle's added or addedBefore; there's no need to\n  // flush the queue afterwards to ensure that the callbacks get out.\n  _sendAdds: function () {\n    function _sendAdds(handle) {\n      var self = this;\n      if (self._queue.safeToRunTask()) throw Error(\"_sendAdds may only be called from within a task!\");\n      var add = self._ordered ? handle._addedBefore : handle._added;\n      if (!add) return;\n      // note: docs may be an _IdMap or an OrderedDict\n      self._cache.docs.forEach(function (doc, id) {\n        if (!_.has(self._handles, handle._id)) throw Error(\"handle got removed before sending initial adds!\");\n        var fields = EJSON.clone(doc);\n        delete fields._id;\n        if (self._ordered) add(id, fields, null); // we're going in order, so add at end\n        else add(id, fields);\n      });\n    }\n\n    return _sendAdds;\n  }()\n});\n\nvar nextObserveHandleId = 1;\nObserveHandle = function ObserveHandle(multiplexer, callbacks) {\n  var self = this;\n  // The end user is only supposed to call stop().  The other fields are\n  // accessible to the multiplexer, though.\n  self._multiplexer = multiplexer;\n  _.each(multiplexer.callbackNames(), function (name) {\n    if (callbacks[name]) {\n      self['_' + name] = callbacks[name];\n    } else if (name === \"addedBefore\" && callbacks.added) {\n      // Special case: if you specify \"added\" and \"movedBefore\", you get an\n      // ordered observe where for some reason you don't get ordering data on\n      // the adds.  I dunno, we wrote tests for it, there must have been a\n      // reason.\n      self._addedBefore = function (id, fields, before) {\n        callbacks.added(id, fields);\n      };\n    }\n  });\n  self._stopped = false;\n  self._id = nextObserveHandleId++;\n};\nObserveHandle.prototype.stop = function () {\n  var self = this;\n  if (self._stopped) return;\n  self._stopped = true;\n  self._multiplexer.removeHandle(self._id);\n};","ast":null,"map":{"version":3,"sources":["/packages/mongo/observe_multiplex.js"],"names":[],"mappings":"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","file":"/packages/mongo/observe_multiplex.js.map","sourcesContent":["var Future = Npm.require('fibers/future');\n\nObserveMultiplexer = function (options) {\n  var self = this;\n\n  if (!options || !_.has(options, 'ordered'))\n    throw Error(\"must specified ordered\");\n\n  Package.facts && Package.facts.Facts.incrementServerFact(\n    \"mongo-livedata\", \"observe-multiplexers\", 1);\n\n  self._ordered = options.ordered;\n  self._onStop = options.onStop || function () {};\n  self._queue = new Meteor._SynchronousQueue();\n  self._handles = {};\n  self._readyFuture = new Future;\n  self._cache = new LocalCollection._CachingChangeObserver({\n    ordered: options.ordered});\n  // Number of addHandleAndSendInitialAdds tasks scheduled but not yet\n  // running. removeHandle uses this to know if it's time to call the onStop\n  // callback.\n  self._addHandleTasksScheduledButNotPerformed = 0;\n\n  _.each(self.callbackNames(), function (callbackName) {\n    self[callbackName] = function (/* ... */) {\n      self._applyCallback(callbackName, _.toArray(arguments));\n    };\n  });\n};\n\n_.extend(ObserveMultiplexer.prototype, {\n  addHandleAndSendInitialAdds: function (handle) {\n    var self = this;\n\n    // Check this before calling runTask (even though runTask does the same\n    // check) so that we don't leak an ObserveMultiplexer on error by\n    // incrementing _addHandleTasksScheduledButNotPerformed and never\n    // decrementing it.\n    if (!self._queue.safeToRunTask())\n      throw new Error(\n        \"Can't call observeChanges from an observe callback on the same query\");\n    ++self._addHandleTasksScheduledButNotPerformed;\n\n    Package.facts && Package.facts.Facts.incrementServerFact(\n      \"mongo-livedata\", \"observe-handles\", 1);\n\n    self._queue.runTask(function () {\n      self._handles[handle._id] = handle;\n      // Send out whatever adds we have so far (whether or not we the\n      // multiplexer is ready).\n      self._sendAdds(handle);\n      --self._addHandleTasksScheduledButNotPerformed;\n    });\n    // *outside* the task, since otherwise we'd deadlock\n    self._readyFuture.wait();\n  },\n\n  // Remove an observe handle. If it was the last observe handle, call the\n  // onStop callback; you cannot add any more observe handles after this.\n  //\n  // This is not synchronized with polls and handle additions: this means that\n  // you can safely call it from within an observe callback, but it also means\n  // that we have to be careful when we iterate over _handles.\n  removeHandle: function (id) {\n    var self = this;\n\n    // This should not be possible: you can only call removeHandle by having\n    // access to the ObserveHandle, which isn't returned to user code until the\n    // multiplex is ready.\n    if (!self._ready())\n      throw new Error(\"Can't remove handles until the multiplex is ready\");\n\n    delete self._handles[id];\n\n    Package.facts && Package.facts.Facts.incrementServerFact(\n      \"mongo-livedata\", \"observe-handles\", -1);\n\n    if (_.isEmpty(self._handles) &&\n        self._addHandleTasksScheduledButNotPerformed === 0) {\n      self._stop();\n    }\n  },\n  _stop: function (options) {\n    var self = this;\n    options = options || {};\n\n    // It shouldn't be possible for us to stop when all our handles still\n    // haven't been returned from observeChanges!\n    if (! self._ready() && ! options.fromQueryError)\n      throw Error(\"surprising _stop: not ready\");\n\n    // Call stop callback (which kills the underlying process which sends us\n    // callbacks and removes us from the connection's dictionary).\n    self._onStop();\n    Package.facts && Package.facts.Facts.incrementServerFact(\n      \"mongo-livedata\", \"observe-multiplexers\", -1);\n\n    // Cause future addHandleAndSendInitialAdds calls to throw (but the onStop\n    // callback should make our connection forget about us).\n    self._handles = null;\n  },\n\n  // Allows all addHandleAndSendInitialAdds calls to return, once all preceding\n  // adds have been processed. Does not block.\n  ready: function () {\n    var self = this;\n    self._queue.queueTask(function () {\n      if (self._ready())\n        throw Error(\"can't make ObserveMultiplex ready twice!\");\n      self._readyFuture.return();\n    });\n  },\n\n  // If trying to execute the query results in an error, call this. This is\n  // intended for permanent errors, not transient network errors that could be\n  // fixed. It should only be called before ready(), because if you called ready\n  // that meant that you managed to run the query once. It will stop this\n  // ObserveMultiplex and cause addHandleAndSendInitialAdds calls (and thus\n  // observeChanges calls) to throw the error.\n  queryError: function (err) {\n    var self = this;\n    self._queue.runTask(function () {\n      if (self._ready())\n        throw Error(\"can't claim query has an error after it worked!\");\n      self._stop({fromQueryError: true});\n      self._readyFuture.throw(err);\n    });\n  },\n\n  // Calls \"cb\" once the effects of all \"ready\", \"addHandleAndSendInitialAdds\"\n  // and observe callbacks which came before this call have been propagated to\n  // all handles. \"ready\" must have already been called on this multiplexer.\n  onFlush: function (cb) {\n    var self = this;\n    self._queue.queueTask(function () {\n      if (!self._ready())\n        throw Error(\"only call onFlush on a multiplexer that will be ready\");\n      cb();\n    });\n  },\n  callbackNames: function () {\n    var self = this;\n    if (self._ordered)\n      return [\"addedBefore\", \"changed\", \"movedBefore\", \"removed\"];\n    else\n      return [\"added\", \"changed\", \"removed\"];\n  },\n  _ready: function () {\n    return this._readyFuture.isResolved();\n  },\n  _applyCallback: function (callbackName, args) {\n    var self = this;\n    self._queue.queueTask(function () {\n      // If we stopped in the meantime, do nothing.\n      if (!self._handles)\n        return;\n\n      // First, apply the change to the cache.\n      // XXX We could make applyChange callbacks promise not to hang on to any\n      // state from their arguments (assuming that their supplied callbacks\n      // don't) and skip this clone. Currently 'changed' hangs on to state\n      // though.\n      self._cache.applyChange[callbackName].apply(null, EJSON.clone(args));\n\n      // If we haven't finished the initial adds, then we should only be getting\n      // adds.\n      if (!self._ready() &&\n          (callbackName !== 'added' && callbackName !== 'addedBefore')) {\n        throw new Error(\"Got \" + callbackName + \" during initial adds\");\n      }\n\n      // Now multiplex the callbacks out to all observe handles. It's OK if\n      // these calls yield; since we're inside a task, no other use of our queue\n      // can continue until these are done. (But we do have to be careful to not\n      // use a handle that got removed, because removeHandle does not use the\n      // queue; thus, we iterate over an array of keys that we control.)\n      _.each(_.keys(self._handles), function (handleId) {\n        var handle = self._handles && self._handles[handleId];\n        if (!handle)\n          return;\n        var callback = handle['_' + callbackName];\n        // clone arguments so that callbacks can mutate their arguments\n        callback && callback.apply(null, EJSON.clone(args));\n      });\n    });\n  },\n\n  // Sends initial adds to a handle. It should only be called from within a task\n  // (the task that is processing the addHandleAndSendInitialAdds call). It\n  // synchronously invokes the handle's added or addedBefore; there's no need to\n  // flush the queue afterwards to ensure that the callbacks get out.\n  _sendAdds: function (handle) {\n    var self = this;\n    if (self._queue.safeToRunTask())\n      throw Error(\"_sendAdds may only be called from within a task!\");\n    var add = self._ordered ? handle._addedBefore : handle._added;\n    if (!add)\n      return;\n    // note: docs may be an _IdMap or an OrderedDict\n    self._cache.docs.forEach(function (doc, id) {\n      if (!_.has(self._handles, handle._id))\n        throw Error(\"handle got removed before sending initial adds!\");\n      var fields = EJSON.clone(doc);\n      delete fields._id;\n      if (self._ordered)\n        add(id, fields, null); // we're going in order, so add at end\n      else\n        add(id, fields);\n    });\n  }\n});\n\n\nvar nextObserveHandleId = 1;\nObserveHandle = function (multiplexer, callbacks) {\n  var self = this;\n  // The end user is only supposed to call stop().  The other fields are\n  // accessible to the multiplexer, though.\n  self._multiplexer = multiplexer;\n  _.each(multiplexer.callbackNames(), function (name) {\n    if (callbacks[name]) {\n      self['_' + name] = callbacks[name];\n    } else if (name === \"addedBefore\" && callbacks.added) {\n      // Special case: if you specify \"added\" and \"movedBefore\", you get an\n      // ordered observe where for some reason you don't get ordering data on\n      // the adds.  I dunno, we wrote tests for it, there must have been a\n      // reason.\n      self._addedBefore = function (id, fields, before) {\n        callbacks.added(id, fields);\n      };\n    }\n  });\n  self._stopped = false;\n  self._id = nextObserveHandleId++;\n};\nObserveHandle.prototype.stop = function () {\n  var self = this;\n  if (self._stopped)\n    return;\n  self._stopped = true;\n  self._multiplexer.removeHandle(self._id);\n};\n"]},"hash":"04b336004672a7b395bfa4dee172d93a15f3afd3"}
