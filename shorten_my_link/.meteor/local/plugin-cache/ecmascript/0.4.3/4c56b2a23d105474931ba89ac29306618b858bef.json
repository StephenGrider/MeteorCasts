{"metadata":{"usedHelpers":[],"marked":[],"modules":{"imports":[],"exports":{"exported":[],"specifiers":[]}}},"options":{"filename":"/packages/mongo/allow_tests.js","filenameRelative":"/packages/mongo/allow_tests.js","env":{},"retainLines":false,"highlightCode":true,"suppressDeprecationMessages":false,"presets":[],"plugins":[[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],{"polyfill":false}],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],{"loose":true}],[[],{"loose":true}],[[],null],[[],{"loose":true}],[[],null],[[],null],[[],{"allowTopLevelThis":true,"strict":false,"loose":true}],[[],null],[[],null],[[],null],[[],null],[[],null],[[],{"loose":true}],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null]],"ignore":[],"code":true,"metadata":true,"ast":false,"comments":true,"compact":false,"minified":false,"sourceMap":true,"sourceMaps":true,"sourceMapTarget":"/packages/mongo/allow_tests.js.map","sourceFileName":"/packages/mongo/allow_tests.js","babelrc":false,"sourceType":"module","moduleIds":false,"passPerPreset":false,"basename":"allow_tests"},"ignored":false,"code":"if (Meteor.isServer) {\n  // Set up allow/deny rules for test collections\n\n  var allowCollections = {};\n\n  // We create the collections in the publisher (instead of using a method or\n  // something) because if we made them with a method, we'd need to follow the\n  // method with some subscribes, and it's possible that the method call would\n  // be delayed by a wait method and the subscribe messages would be sent before\n  // it and fail due to the collection not yet existing. So we are very hacky\n  // and use a publish.\n  Meteor.publish(\"allowTests\", function (nonce, idGeneration) {\n    check(nonce, String);\n    check(idGeneration, String);\n    var cursors = [];\n    var needToConfigure = undefined;\n\n    // helper for defining a collection. we are careful to create just one\n    // Mongo.Collection even if the sub body is rerun, by caching them.\n    var defineCollection = function defineCollection(name, insecure, transform) {\n      var fullName = name + idGeneration + nonce;\n\n      var collection;\n      if (_.has(allowCollections, fullName)) {\n        collection = allowCollections[fullName];\n        if (needToConfigure === true) throw new Error(\"collections inconsistently exist\");\n        needToConfigure = false;\n      } else {\n        collection = new Mongo.Collection(fullName, { idGeneration: idGeneration, transform: transform });\n        allowCollections[fullName] = collection;\n        if (needToConfigure === false) throw new Error(\"collections inconsistently don't exist\");\n        needToConfigure = true;\n        collection._insecure = insecure;\n        var m = {};\n        m[\"clear-collection-\" + fullName] = function () {\n          collection.remove({});\n        };\n        Meteor.methods(m);\n      }\n\n      cursors.push(collection.find());\n      return collection;\n    };\n\n    var insecureCollection = defineCollection(\"collection-insecure\", true /*insecure*/);\n    // totally locked down collection\n    var lockedDownCollection = defineCollection(\"collection-locked-down\", false /*insecure*/);\n    // restricted collection with same allowed modifications, both with and\n    // without the `insecure` package\n    var restrictedCollectionDefaultSecure = defineCollection(\"collection-restrictedDefaultSecure\", false /*insecure*/);\n    var restrictedCollectionDefaultInsecure = defineCollection(\"collection-restrictedDefaultInsecure\", true /*insecure*/);\n    var restrictedCollectionForUpdateOptionsTest = defineCollection(\"collection-restrictedForUpdateOptionsTest\", true /*insecure*/);\n    var restrictedCollectionForPartialAllowTest = defineCollection(\"collection-restrictedForPartialAllowTest\", true /*insecure*/);\n    var restrictedCollectionForPartialDenyTest = defineCollection(\"collection-restrictedForPartialDenyTest\", true /*insecure*/);\n    var restrictedCollectionForFetchTest = defineCollection(\"collection-restrictedForFetchTest\", true /*insecure*/);\n    var restrictedCollectionForFetchAllTest = defineCollection(\"collection-restrictedForFetchAllTest\", true /*insecure*/);\n    var restrictedCollectionWithTransform = defineCollection(\"withTransform\", false, function (doc) {\n      return doc.a;\n    });\n    var restrictedCollectionForInvalidTransformTest = defineCollection(\"collection-restrictedForInvalidTransform\", false /*insecure*/);\n    var restrictedCollectionForClientIdTest = defineCollection(\"collection-restrictedForClientIdTest\", false /*insecure*/);\n\n    if (needToConfigure) {\n      restrictedCollectionWithTransform.allow({\n        insert: function () {\n          function insert(userId, doc) {\n            return doc.foo === \"foo\";\n          }\n\n          return insert;\n        }(),\n        update: function () {\n          function update(userId, doc) {\n            return doc.foo === \"foo\";\n          }\n\n          return update;\n        }(),\n        remove: function () {\n          function remove(userId, doc) {\n            return doc.bar === \"bar\";\n          }\n\n          return remove;\n        }()\n      });\n      restrictedCollectionWithTransform.allow({\n        // transform: null means that doc here is the top level, not the 'a'\n        // element.\n        transform: null,\n        insert: function () {\n          function insert(userId, doc) {\n            return !!doc.topLevelField;\n          }\n\n          return insert;\n        }(),\n        update: function () {\n          function update(userId, doc) {\n            return !!doc.topLevelField;\n          }\n\n          return update;\n        }()\n      });\n      restrictedCollectionForInvalidTransformTest.allow({\n        // transform must return an object which is not a mongo id\n        transform: function () {\n          function transform(doc) {\n            return doc._id;\n          }\n\n          return transform;\n        }(),\n        insert: function () {\n          function insert() {\n            return true;\n          }\n\n          return insert;\n        }()\n      });\n      restrictedCollectionForClientIdTest.allow({\n        // This test just requires the collection to trigger the restricted\n        // case.\n        insert: function () {\n          function insert() {\n            return true;\n          }\n\n          return insert;\n        }()\n      });\n\n      // two calls to allow to verify that either validator is sufficient.\n      var allows = [{\n        insert: function () {\n          function insert(userId, doc) {\n            return doc.canInsert;\n          }\n\n          return insert;\n        }(),\n        update: function () {\n          function update(userId, doc) {\n            return doc.canUpdate;\n          }\n\n          return update;\n        }(),\n        remove: function () {\n          function remove(userId, doc) {\n            return doc.canRemove;\n          }\n\n          return remove;\n        }()\n      }, {\n        insert: function () {\n          function insert(userId, doc) {\n            return doc.canInsert2;\n          }\n\n          return insert;\n        }(),\n        update: function () {\n          function update(userId, doc, fields, modifier) {\n            return -1 !== _.indexOf(fields, 'canUpdate2');\n          }\n\n          return update;\n        }(),\n        remove: function () {\n          function remove(userId, doc) {\n            return doc.canRemove2;\n          }\n\n          return remove;\n        }()\n      }];\n\n      // two calls to deny to verify that either one blocks the change.\n      var denies = [{\n        insert: function () {\n          function insert(userId, doc) {\n            return doc.cantInsert;\n          }\n\n          return insert;\n        }(),\n        remove: function () {\n          function remove(userId, doc) {\n            return doc.cantRemove;\n          }\n\n          return remove;\n        }()\n      }, {\n        insert: function () {\n          function insert(userId, doc) {\n            // Don't allow explicit ID to be set by the client.\n            return _.has(doc, '_id');\n          }\n\n          return insert;\n        }(),\n        update: function () {\n          function update(userId, doc, fields, modifier) {\n            return -1 !== _.indexOf(fields, 'verySecret');\n          }\n\n          return update;\n        }()\n      }];\n\n      _.each([restrictedCollectionDefaultSecure, restrictedCollectionDefaultInsecure, restrictedCollectionForUpdateOptionsTest], function (collection) {\n        _.each(allows, function (allow) {\n          collection.allow(allow);\n        });\n        _.each(denies, function (deny) {\n          collection.deny(deny);\n        });\n      });\n\n      // just restrict one operation so that we can verify that others\n      // fail\n      restrictedCollectionForPartialAllowTest.allow({\n        insert: function () {\n          function insert() {}\n\n          return insert;\n        }()\n      });\n      restrictedCollectionForPartialDenyTest.deny({\n        insert: function () {\n          function insert() {}\n\n          return insert;\n        }()\n      });\n\n      // verify that we only fetch the fields specified - we should\n      // be fetching just field1, field2, and field3.\n      restrictedCollectionForFetchTest.allow({\n        insert: function () {\n          function insert() {\n            return true;\n          }\n\n          return insert;\n        }(),\n        update: function () {\n          function update(userId, doc) {\n            // throw fields in doc so that we can inspect them in test\n            throw new Meteor.Error(999, \"Test: Fields in doc: \" + _.keys(doc).sort().join(','));\n          }\n\n          return update;\n        }(),\n        remove: function () {\n          function remove(userId, doc) {\n            // throw fields in doc so that we can inspect them in test\n            throw new Meteor.Error(999, \"Test: Fields in doc: \" + _.keys(doc).sort().join(','));\n          }\n\n          return remove;\n        }(),\n        fetch: ['field1']\n      });\n      restrictedCollectionForFetchTest.allow({\n        fetch: ['field2']\n      });\n      restrictedCollectionForFetchTest.deny({\n        fetch: ['field3']\n      });\n\n      // verify that not passing fetch to one of the calls to allow\n      // causes all fields to be fetched\n      restrictedCollectionForFetchAllTest.allow({\n        insert: function () {\n          function insert() {\n            return true;\n          }\n\n          return insert;\n        }(),\n        update: function () {\n          function update(userId, doc) {\n            // throw fields in doc so that we can inspect them in test\n            throw new Meteor.Error(999, \"Test: Fields in doc: \" + _.keys(doc).sort().join(','));\n          }\n\n          return update;\n        }(),\n        remove: function () {\n          function remove(userId, doc) {\n            // throw fields in doc so that we can inspect them in test\n            throw new Meteor.Error(999, \"Test: Fields in doc: \" + _.keys(doc).sort().join(','));\n          }\n\n          return remove;\n        }(),\n        fetch: ['field1']\n      });\n      restrictedCollectionForFetchAllTest.allow({\n        update: function () {\n          function update() {\n            return true;\n          }\n\n          return update;\n        }()\n      });\n    }\n\n    return cursors;\n  });\n}\n\nif (Meteor.isClient) {\n  _.each(['STRING', 'MONGO'], function (idGeneration) {\n    // Set up a bunch of test collections... on the client! They match the ones\n    // created by setUpAllowTestsCollections.\n\n    var nonce = Random.id();\n    // Tell the server to make, configure, and publish a set of collections unique\n    // to our test run. Since the method does not unblock, this will complete\n    // running on the server before anything else happens.\n    Meteor.subscribe('allowTests', nonce, idGeneration);\n\n    // helper for defining a collection, subscribing to it, and defining\n    // a method to clear it\n    var defineCollection = function defineCollection(name, transform) {\n      var fullName = name + idGeneration + nonce;\n      var collection = new Mongo.Collection(fullName, { idGeneration: idGeneration, transform: transform });\n\n      collection.callClearMethod = function (callback) {\n        Meteor.call(\"clear-collection-\" + fullName, callback);\n      };\n      collection.unnoncedName = name + idGeneration;\n      return collection;\n    };\n\n    // totally insecure collection\n    var insecureCollection = defineCollection(\"collection-insecure\");\n\n    // totally locked down collection\n    var lockedDownCollection = defineCollection(\"collection-locked-down\");\n\n    // restricted collection with same allowed modifications, both with and\n    // without the `insecure` package\n    var restrictedCollectionDefaultSecure = defineCollection(\"collection-restrictedDefaultSecure\");\n    var restrictedCollectionDefaultInsecure = defineCollection(\"collection-restrictedDefaultInsecure\");\n    var restrictedCollectionForUpdateOptionsTest = defineCollection(\"collection-restrictedForUpdateOptionsTest\");\n    var restrictedCollectionForPartialAllowTest = defineCollection(\"collection-restrictedForPartialAllowTest\");\n    var restrictedCollectionForPartialDenyTest = defineCollection(\"collection-restrictedForPartialDenyTest\");\n    var restrictedCollectionForFetchTest = defineCollection(\"collection-restrictedForFetchTest\");\n    var restrictedCollectionForFetchAllTest = defineCollection(\"collection-restrictedForFetchAllTest\");\n    var restrictedCollectionWithTransform = defineCollection(\"withTransform\", function (doc) {\n      return doc.a;\n    });\n    var restrictedCollectionForInvalidTransformTest = defineCollection(\"collection-restrictedForInvalidTransform\");\n    var restrictedCollectionForClientIdTest = defineCollection(\"collection-restrictedForClientIdTest\");\n\n    // test that if allow is called once then the collection is\n    // restricted, and that other mutations aren't allowed\n    testAsyncMulti(\"collection - partial allow, \" + idGeneration, [function (test, expect) {\n      restrictedCollectionForPartialAllowTest.update('foo', { $set: { updated: true } }, expect(function (err, res) {\n        test.equal(err.error, 403);\n      }));\n    }]);\n\n    // test that if deny is called once then the collection is\n    // restricted, and that other mutations aren't allowed\n    testAsyncMulti(\"collection - partial deny, \" + idGeneration, [function (test, expect) {\n      restrictedCollectionForPartialDenyTest.update('foo', { $set: { updated: true } }, expect(function (err, res) {\n        test.equal(err.error, 403);\n      }));\n    }]);\n\n    // test that we only fetch the fields specified\n    testAsyncMulti(\"collection - fetch, \" + idGeneration, [function (test, expect) {\n      var fetchId = restrictedCollectionForFetchTest.insert({ field1: 1, field2: 1, field3: 1, field4: 1 });\n      var fetchAllId = restrictedCollectionForFetchAllTest.insert({ field1: 1, field2: 1, field3: 1, field4: 1 });\n      restrictedCollectionForFetchTest.update(fetchId, { $set: { updated: true } }, expect(function (err, res) {\n        test.equal(err.reason, \"Test: Fields in doc: _id,field1,field2,field3\");\n      }));\n      restrictedCollectionForFetchTest.remove(fetchId, expect(function (err, res) {\n        test.equal(err.reason, \"Test: Fields in doc: _id,field1,field2,field3\");\n      }));\n\n      restrictedCollectionForFetchAllTest.update(fetchAllId, { $set: { updated: true } }, expect(function (err, res) {\n        test.equal(err.reason, \"Test: Fields in doc: _id,field1,field2,field3,field4\");\n      }));\n      restrictedCollectionForFetchAllTest.remove(fetchAllId, expect(function (err, res) {\n        test.equal(err.reason, \"Test: Fields in doc: _id,field1,field2,field3,field4\");\n      }));\n    }]);\n\n    (function () {\n      testAsyncMulti(\"collection - restricted factories \" + idGeneration, [function (test, expect) {\n        restrictedCollectionWithTransform.callClearMethod(expect(function () {\n          test.equal(restrictedCollectionWithTransform.find().count(), 0);\n        }));\n      }, function (test, expect) {\n        var self = this;\n        restrictedCollectionWithTransform.insert({\n          a: { foo: \"foo\", bar: \"bar\", baz: \"baz\" }\n        }, expect(function (e, res) {\n          test.isFalse(e);\n          test.isTrue(res);\n          self.item1 = res;\n        }));\n        restrictedCollectionWithTransform.insert({\n          a: { foo: \"foo\", bar: \"quux\", baz: \"quux\" },\n          b: \"potato\"\n        }, expect(function (e, res) {\n          test.isFalse(e);\n          test.isTrue(res);\n          self.item2 = res;\n        }));\n        restrictedCollectionWithTransform.insert({\n          a: { foo: \"adsfadf\", bar: \"quux\", baz: \"quux\" },\n          b: \"potato\"\n        }, expect(function (e, res) {\n          test.isTrue(e);\n        }));\n        restrictedCollectionWithTransform.insert({\n          a: { foo: \"bar\" },\n          topLevelField: true\n        }, expect(function (e, res) {\n          test.isFalse(e);\n          test.isTrue(res);\n          self.item3 = res;\n        }));\n      }, function (test, expect) {\n        var self = this;\n        // This should work, because there is an update allow for things with\n        // topLevelField.\n        restrictedCollectionWithTransform.update(self.item3, { $set: { xxx: true } }, expect(function (e, res) {\n          test.isFalse(e);\n          test.equal(1, res);\n        }));\n      }, function (test, expect) {\n        var self = this;\n        test.equal(restrictedCollectionWithTransform.findOne(self.item1), { _id: self.item1, foo: \"foo\", bar: \"bar\", baz: \"baz\" });\n        restrictedCollectionWithTransform.remove(self.item1, expect(function (e, res) {\n          test.isFalse(e);\n        }));\n        restrictedCollectionWithTransform.remove(self.item2, expect(function (e, res) {\n          test.isTrue(e);\n        }));\n      }]);\n    })();\n\n    testAsyncMulti(\"collection - insecure, \" + idGeneration, [function (test, expect) {\n      insecureCollection.callClearMethod(expect(function () {\n        test.equal(insecureCollection.find().count(), 0);\n      }));\n    }, function (test, expect) {\n      var id = insecureCollection.insert({ foo: 'bar' }, expect(function (err, res) {\n        test.equal(res, id);\n        test.equal(insecureCollection.find(id).count(), 1);\n        test.equal(insecureCollection.findOne(id).foo, 'bar');\n      }));\n      test.equal(insecureCollection.find(id).count(), 1);\n      test.equal(insecureCollection.findOne(id).foo, 'bar');\n    }]);\n\n    testAsyncMulti(\"collection - locked down, \" + idGeneration, [function (test, expect) {\n      lockedDownCollection.callClearMethod(expect(function () {\n        test.equal(lockedDownCollection.find().count(), 0);\n      }));\n    }, function (test, expect) {\n      lockedDownCollection.insert({ foo: 'bar' }, expect(function (err, res) {\n        test.equal(err.error, 403);\n        test.equal(lockedDownCollection.find().count(), 0);\n      }));\n    }]);\n\n    (function () {\n      var collection = restrictedCollectionForUpdateOptionsTest;\n      var id1, id2;\n      testAsyncMulti(\"collection - update options, \" + idGeneration, [\n      // init\n      function (test, expect) {\n        collection.callClearMethod(expect(function () {\n          test.equal(collection.find().count(), 0);\n        }));\n      },\n      // put a few objects\n      function (test, expect) {\n        var doc = { canInsert: true, canUpdate: true };\n        id1 = collection.insert(doc);\n        id2 = collection.insert(doc);\n        collection.insert(doc);\n        collection.insert(doc, expect(function (err, res) {\n          test.isFalse(err);\n          test.equal(collection.find().count(), 4);\n        }));\n      },\n      // update by id\n      function (test, expect) {\n        collection.update(id1, { $set: { updated: true } }, expect(function (err, res) {\n          test.isFalse(err);\n          test.equal(res, 1);\n          test.equal(collection.find({ updated: true }).count(), 1);\n        }));\n      },\n      // update by id in an object\n      function (test, expect) {\n        collection.update({ _id: id2 }, { $set: { updated: true } }, expect(function (err, res) {\n          test.isFalse(err);\n          test.equal(res, 1);\n          test.equal(collection.find({ updated: true }).count(), 2);\n        }));\n      },\n      // update with replacement operator not allowed, and has nice error.\n      function (test, expect) {\n        collection.update({ _id: id2 }, { _id: id2, updated: true }, expect(function (err, res) {\n          test.equal(err.error, 403);\n          test.matches(err.reason, /In a restricted/);\n          // unchanged\n          test.equal(collection.find({ updated: true }).count(), 2);\n        }));\n      },\n      // upsert not allowed, and has nice error.\n      function (test, expect) {\n        collection.update({ _id: id2 }, { $set: { upserted: true } }, { upsert: true }, expect(function (err, res) {\n          test.equal(err.error, 403);\n          test.matches(err.reason, /in a restricted/);\n          test.equal(collection.find({ upserted: true }).count(), 0);\n        }));\n      },\n      // update with rename operator not allowed, and has nice error.\n      function (test, expect) {\n        collection.update({ _id: id2 }, { $rename: { updated: 'asdf' } }, expect(function (err, res) {\n          test.equal(err.error, 403);\n          test.matches(err.reason, /not allowed/);\n          // unchanged\n          test.equal(collection.find({ updated: true }).count(), 2);\n        }));\n      },\n      // update method with a non-ID selector is not allowed\n      function (test, expect) {\n        // We shouldn't even send the method...\n        test.throws(function () {\n          collection.update({ updated: { $exists: false } }, { $set: { updated: true } });\n        });\n        // ... but if we did, the server would reject it too.\n        Meteor.call('/' + collection._name + '/update', { updated: { $exists: false } }, { $set: { updated: true } }, expect(function (err, res) {\n          test.equal(err.error, 403);\n          // unchanged\n          test.equal(collection.find({ updated: true }).count(), 2);\n        }));\n      },\n      // make sure it doesn't think that {_id: 'foo', something: else} is ok.\n      function (test, expect) {\n        test.throws(function () {\n          collection.update({ _id: id1, updated: { $exists: false } }, { $set: { updated: true } });\n        });\n      },\n      // remove method with a non-ID selector is not allowed\n      function (test, expect) {\n        // We shouldn't even send the method...\n        test.throws(function () {\n          collection.remove({ updated: true });\n        });\n        // ... but if we did, the server would reject it too.\n        Meteor.call('/' + collection._name + '/remove', { updated: true }, expect(function (err, res) {\n          test.equal(err.error, 403);\n          // unchanged\n          test.equal(collection.find({ updated: true }).count(), 2);\n        }));\n      }]);\n    })();\n\n    _.each([restrictedCollectionDefaultInsecure, restrictedCollectionDefaultSecure], function (collection) {\n      var canUpdateId, canRemoveId;\n\n      testAsyncMulti(\"collection - \" + collection.unnoncedName, [\n      // init\n      function (test, expect) {\n        collection.callClearMethod(expect(function () {\n          test.equal(collection.find().count(), 0);\n        }));\n      },\n\n      // insert with no allows passing. request is denied.\n      function (test, expect) {\n        collection.insert({}, expect(function (err, res) {\n          test.equal(err.error, 403);\n          test.equal(collection.find().count(), 0);\n        }));\n      },\n      // insert with one allow and one deny. denied.\n      function (test, expect) {\n        collection.insert({ canInsert: true, cantInsert: true }, expect(function (err, res) {\n          test.equal(err.error, 403);\n          test.equal(collection.find().count(), 0);\n        }));\n      },\n      // insert with one allow and other deny. denied.\n      function (test, expect) {\n        collection.insert({ canInsert: true, _id: Random.id() }, expect(function (err, res) {\n          test.equal(err.error, 403);\n          test.equal(collection.find().count(), 0);\n        }));\n      },\n      // insert one allow passes. allowed.\n      function (test, expect) {\n        collection.insert({ canInsert: true }, expect(function (err, res) {\n          test.isFalse(err);\n          test.equal(collection.find().count(), 1);\n        }));\n      },\n      // insert other allow passes. allowed.\n      // includes canUpdate for later.\n      function (test, expect) {\n        canUpdateId = collection.insert({ canInsert2: true, canUpdate: true }, expect(function (err, res) {\n          test.isFalse(err);\n          test.equal(collection.find().count(), 2);\n        }));\n      },\n      // yet a third insert executes. this one has canRemove and\n      // cantRemove set for later.\n      function (test, expect) {\n        canRemoveId = collection.insert({ canInsert: true, canRemove: true, cantRemove: true }, expect(function (err, res) {\n          test.isFalse(err);\n          test.equal(collection.find().count(), 3);\n        }));\n      },\n\n      // can't update with a non-operator mutation\n      function (test, expect) {\n        collection.update(canUpdateId, { newObject: 1 }, expect(function (err, res) {\n          test.equal(err.error, 403);\n          test.equal(collection.find().count(), 3);\n        }));\n      },\n\n      // updating dotted fields works as if we are changing their\n      // top part\n      function (test, expect) {\n        collection.update(canUpdateId, { $set: { \"dotted.field\": 1 } }, expect(function (err, res) {\n          test.isFalse(err);\n          test.equal(res, 1);\n          test.equal(collection.findOne(canUpdateId).dotted.field, 1);\n        }));\n      }, function (test, expect) {\n        collection.update(canUpdateId, { $set: { \"verySecret.field\": 1 } }, expect(function (err, res) {\n          test.equal(err.error, 403);\n          test.equal(collection.find({ verySecret: { $exists: true } }).count(), 0);\n        }));\n      },\n\n      // update doesn't do anything if no docs match\n      function (test, expect) {\n        collection.update(\"doesn't exist\", { $set: { updated: true } }, expect(function (err, res) {\n          test.isFalse(err);\n          test.equal(res, 0);\n          // nothing has changed\n          test.equal(collection.find().count(), 3);\n          test.equal(collection.find({ updated: true }).count(), 0);\n        }));\n      },\n      // update fails when access is denied trying to set `verySecret`\n      function (test, expect) {\n        collection.update(canUpdateId, { $set: { verySecret: true } }, expect(function (err, res) {\n          test.equal(err.error, 403);\n          // nothing has changed\n          test.equal(collection.find().count(), 3);\n          test.equal(collection.find({ updated: true }).count(), 0);\n        }));\n      },\n      // update fails when trying to set two fields, one of which is\n      // `verySecret`\n      function (test, expect) {\n        collection.update(canUpdateId, { $set: { updated: true, verySecret: true } }, expect(function (err, res) {\n          test.equal(err.error, 403);\n          // nothing has changed\n          test.equal(collection.find().count(), 3);\n          test.equal(collection.find({ updated: true }).count(), 0);\n        }));\n      },\n      // update fails when trying to modify docs that don't\n      // have `canUpdate` set\n      function (test, expect) {\n        collection.update(canRemoveId, { $set: { updated: true } }, expect(function (err, res) {\n          test.equal(err.error, 403);\n          // nothing has changed\n          test.equal(collection.find().count(), 3);\n          test.equal(collection.find({ updated: true }).count(), 0);\n        }));\n      },\n      // update executes when it should\n      function (test, expect) {\n        collection.update(canUpdateId, { $set: { updated: true } }, expect(function (err, res) {\n          test.isFalse(err);\n          test.equal(res, 1);\n          test.equal(collection.find({ updated: true }).count(), 1);\n        }));\n      },\n\n      // remove fails when trying to modify a doc with no `canRemove` set\n      function (test, expect) {\n        collection.remove(canUpdateId, expect(function (err, res) {\n          test.equal(err.error, 403);\n          // nothing has changed\n          test.equal(collection.find().count(), 3);\n        }));\n      },\n      // remove fails when trying to modify an doc with `cantRemove`\n      // set\n      function (test, expect) {\n        collection.remove(canRemoveId, expect(function (err, res) {\n          test.equal(err.error, 403);\n          // nothing has changed\n          test.equal(collection.find().count(), 3);\n        }));\n      },\n\n      // update the doc to remove cantRemove.\n      function (test, expect) {\n        collection.update(canRemoveId, { $set: { cantRemove: false, canUpdate2: true } }, expect(function (err, res) {\n          test.isFalse(err);\n          test.equal(res, 1);\n          test.equal(collection.find({ cantRemove: true }).count(), 0);\n        }));\n      },\n\n      // now remove can remove it.\n      function (test, expect) {\n        collection.remove(canRemoveId, expect(function (err, res) {\n          test.isFalse(err);\n          test.equal(res, 1);\n          // successfully removed\n          test.equal(collection.find().count(), 2);\n        }));\n      },\n\n      // try to remove a doc that doesn't exist. see we remove no docs.\n      function (test, expect) {\n        collection.remove('some-random-id-that-never-matches', expect(function (err, res) {\n          test.isFalse(err);\n          test.equal(res, 0);\n          // nothing removed\n          test.equal(collection.find().count(), 2);\n        }));\n      },\n\n      // methods can still bypass restrictions\n      function (test, expect) {\n        collection.callClearMethod(expect(function (err, res) {\n          test.isFalse(err);\n          // successfully removed\n          test.equal(collection.find().count(), 0);\n        }));\n      }]);\n    });\n    testAsyncMulti(\"collection - allow/deny transform must return object, \" + idGeneration, [function (test, expect) {\n      restrictedCollectionForInvalidTransformTest.insert({}, expect(function (err, res) {\n        test.isTrue(err);\n      }));\n    }]);\n    testAsyncMulti(\"collection - restricted collection allows client-side id, \" + idGeneration, [function (test, expect) {\n      var self = this;\n      self.id = Random.id();\n      restrictedCollectionForClientIdTest.insert({ _id: self.id }, expect(function (err, res) {\n        test.isFalse(err);\n        test.equal(res, self.id);\n        test.equal(restrictedCollectionForClientIdTest.findOne(self.id), { _id: self.id });\n      }));\n    }]);\n  }); // end idGeneration loop\n} // end if isClient\n\n// A few simple server-only tests which don't need to coordinate collections\n// with the client..\nif (Meteor.isServer) {\n  Tinytest.add(\"collection - allow and deny validate options\", function (test) {\n    var collection = new Mongo.Collection(null);\n\n    test.throws(function () {\n      collection.allow({ invalidOption: true });\n    });\n    test.throws(function () {\n      collection.deny({ invalidOption: true });\n    });\n\n    _.each(['insert', 'update', 'remove', 'fetch'], function (key) {\n      var options = {};\n      options[key] = true;\n      test.throws(function () {\n        collection.allow(options);\n      });\n      test.throws(function () {\n        collection.deny(options);\n      });\n    });\n\n    _.each(['insert', 'update', 'remove'], function (key) {\n      var options = {};\n      options[key] = false;\n      test.throws(function () {\n        collection.allow(options);\n      });\n      test.throws(function () {\n        collection.deny(options);\n      });\n    });\n\n    _.each(['insert', 'update', 'remove'], function (key) {\n      var options = {};\n      options[key] = undefined;\n      test.throws(function () {\n        collection.allow(options);\n      });\n      test.throws(function () {\n        collection.deny(options);\n      });\n    });\n\n    _.each(['insert', 'update', 'remove'], function (key) {\n      var options = {};\n      options[key] = ['an array']; // this should be a function, not an array\n      test.throws(function () {\n        collection.allow(options);\n      });\n      test.throws(function () {\n        collection.deny(options);\n      });\n    });\n\n    test.throws(function () {\n      collection.allow({ fetch: function () {\n          function fetch() {}\n\n          return fetch;\n        }() }); // this should be an array\n    });\n  });\n\n  Tinytest.add(\"collection - calling allow restricts\", function (test) {\n    var collection = new Mongo.Collection(null);\n    test.equal(collection._restricted, false);\n    collection.allow({\n      insert: function () {\n        function insert() {}\n\n        return insert;\n      }()\n    });\n    test.equal(collection._restricted, true);\n  });\n\n  Tinytest.add(\"collection - global insecure\", function (test) {\n    // note: This test alters the global insecure status, by sneakily hacking\n    // the global Package object!\n    var insecurePackage = Package.insecure;\n\n    Package.insecure = {};\n    var collection = new Mongo.Collection(null);\n    test.equal(collection._isInsecure(), true);\n\n    Package.insecure = undefined;\n    test.equal(collection._isInsecure(), false);\n\n    delete Package.insecure;\n    test.equal(collection._isInsecure(), false);\n\n    collection._insecure = true;\n    test.equal(collection._isInsecure(), true);\n\n    if (insecurePackage) Package.insecure = insecurePackage;else delete Package.insecure;\n  });\n}","ast":null,"map":{"version":3,"sources":["/packages/mongo/allow_tests.js"],"names":[],"mappings":"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","file":"/packages/mongo/allow_tests.js.map","sourcesContent":["if (Meteor.isServer) {\n  // Set up allow/deny rules for test collections\n\n  var allowCollections = {};\n\n  // We create the collections in the publisher (instead of using a method or\n  // something) because if we made them with a method, we'd need to follow the\n  // method with some subscribes, and it's possible that the method call would\n  // be delayed by a wait method and the subscribe messages would be sent before\n  // it and fail due to the collection not yet existing. So we are very hacky\n  // and use a publish.\n  Meteor.publish(\"allowTests\", function (nonce, idGeneration) {\n    check(nonce, String);\n    check(idGeneration, String);\n    var cursors = [];\n    var needToConfigure = undefined;\n\n    // helper for defining a collection. we are careful to create just one\n    // Mongo.Collection even if the sub body is rerun, by caching them.\n    var defineCollection = function(name, insecure, transform) {\n      var fullName = name + idGeneration + nonce;\n\n      var collection;\n      if (_.has(allowCollections, fullName)) {\n        collection = allowCollections[fullName];\n        if (needToConfigure === true)\n          throw new Error(\"collections inconsistently exist\");\n        needToConfigure = false;\n      } else {\n        collection = new Mongo.Collection(\n          fullName, {idGeneration: idGeneration, transform: transform});\n        allowCollections[fullName] = collection;\n        if (needToConfigure === false)\n          throw new Error(\"collections inconsistently don't exist\");\n        needToConfigure = true;\n        collection._insecure = insecure;\n        var m = {};\n        m[\"clear-collection-\" + fullName] = function() {\n          collection.remove({});\n        };\n        Meteor.methods(m);\n      }\n\n      cursors.push(collection.find());\n      return collection;\n    };\n\n    var insecureCollection = defineCollection(\n      \"collection-insecure\", true /*insecure*/);\n    // totally locked down collection\n    var lockedDownCollection = defineCollection(\n      \"collection-locked-down\", false /*insecure*/);\n    // restricted collection with same allowed modifications, both with and\n    // without the `insecure` package\n    var restrictedCollectionDefaultSecure = defineCollection(\n      \"collection-restrictedDefaultSecure\", false /*insecure*/);\n    var restrictedCollectionDefaultInsecure = defineCollection(\n      \"collection-restrictedDefaultInsecure\", true /*insecure*/);\n    var restrictedCollectionForUpdateOptionsTest = defineCollection(\n      \"collection-restrictedForUpdateOptionsTest\", true /*insecure*/);\n    var restrictedCollectionForPartialAllowTest = defineCollection(\n      \"collection-restrictedForPartialAllowTest\", true /*insecure*/);\n    var restrictedCollectionForPartialDenyTest = defineCollection(\n      \"collection-restrictedForPartialDenyTest\", true /*insecure*/);\n    var restrictedCollectionForFetchTest = defineCollection(\n      \"collection-restrictedForFetchTest\", true /*insecure*/);\n    var restrictedCollectionForFetchAllTest = defineCollection(\n      \"collection-restrictedForFetchAllTest\", true /*insecure*/);\n    var restrictedCollectionWithTransform = defineCollection(\n      \"withTransform\", false, function (doc) {\n        return doc.a;\n      });\n    var restrictedCollectionForInvalidTransformTest = defineCollection(\n      \"collection-restrictedForInvalidTransform\", false /*insecure*/);\n    var restrictedCollectionForClientIdTest = defineCollection(\n      \"collection-restrictedForClientIdTest\", false /*insecure*/);\n\n    if (needToConfigure) {\n      restrictedCollectionWithTransform.allow({\n        insert: function (userId, doc) {\n          return doc.foo === \"foo\";\n        },\n        update: function (userId, doc) {\n          return doc.foo === \"foo\";\n        },\n        remove: function (userId, doc) {\n          return doc.bar === \"bar\";\n        }\n      });\n      restrictedCollectionWithTransform.allow({\n        // transform: null means that doc here is the top level, not the 'a'\n        // element.\n        transform: null,\n        insert: function (userId, doc) {\n          return !!doc.topLevelField;\n        },\n        update: function (userId, doc) {\n          return !!doc.topLevelField;\n        }\n      });\n      restrictedCollectionForInvalidTransformTest.allow({\n        // transform must return an object which is not a mongo id\n        transform: function (doc) { return doc._id; },\n        insert: function () { return true; }\n      });\n      restrictedCollectionForClientIdTest.allow({\n        // This test just requires the collection to trigger the restricted\n        // case.\n        insert: function () { return true; }\n      });\n\n      // two calls to allow to verify that either validator is sufficient.\n      var allows = [{\n        insert: function(userId, doc) {\n          return doc.canInsert;\n        },\n        update: function(userId, doc) {\n          return doc.canUpdate;\n        },\n        remove: function (userId, doc) {\n          return doc.canRemove;\n        }\n      }, {\n        insert: function(userId, doc) {\n          return doc.canInsert2;\n        },\n        update: function(userId, doc, fields, modifier) {\n          return -1 !== _.indexOf(fields, 'canUpdate2');\n        },\n        remove: function(userId, doc) {\n          return doc.canRemove2;\n        }\n      }];\n\n      // two calls to deny to verify that either one blocks the change.\n      var denies = [{\n        insert: function(userId, doc) {\n          return doc.cantInsert;\n        },\n        remove: function (userId, doc) {\n          return doc.cantRemove;\n        }\n      }, {\n        insert: function(userId, doc) {\n          // Don't allow explicit ID to be set by the client.\n          return _.has(doc, '_id');\n        },\n        update: function(userId, doc, fields, modifier) {\n          return -1 !== _.indexOf(fields, 'verySecret');\n        }\n      }];\n\n      _.each([\n        restrictedCollectionDefaultSecure,\n        restrictedCollectionDefaultInsecure,\n        restrictedCollectionForUpdateOptionsTest\n      ], function (collection) {\n        _.each(allows, function (allow) {\n          collection.allow(allow);\n        });\n        _.each(denies, function (deny) {\n          collection.deny(deny);\n        });\n      });\n\n      // just restrict one operation so that we can verify that others\n      // fail\n      restrictedCollectionForPartialAllowTest.allow({\n        insert: function() {}\n      });\n      restrictedCollectionForPartialDenyTest.deny({\n        insert: function() {}\n      });\n\n      // verify that we only fetch the fields specified - we should\n      // be fetching just field1, field2, and field3.\n      restrictedCollectionForFetchTest.allow({\n        insert: function() { return true; },\n        update: function(userId, doc) {\n          // throw fields in doc so that we can inspect them in test\n          throw new Meteor.Error(\n            999, \"Test: Fields in doc: \" + _.keys(doc).sort().join(','));\n        },\n        remove: function(userId, doc) {\n          // throw fields in doc so that we can inspect them in test\n          throw new Meteor.Error(\n            999, \"Test: Fields in doc: \" + _.keys(doc).sort().join(','));\n        },\n        fetch: ['field1']\n      });\n      restrictedCollectionForFetchTest.allow({\n        fetch: ['field2']\n      });\n      restrictedCollectionForFetchTest.deny({\n        fetch: ['field3']\n      });\n\n      // verify that not passing fetch to one of the calls to allow\n      // causes all fields to be fetched\n      restrictedCollectionForFetchAllTest.allow({\n        insert: function() { return true; },\n        update: function(userId, doc) {\n          // throw fields in doc so that we can inspect them in test\n          throw new Meteor.Error(\n            999, \"Test: Fields in doc: \" + _.keys(doc).sort().join(','));\n        },\n        remove: function(userId, doc) {\n          // throw fields in doc so that we can inspect them in test\n          throw new Meteor.Error(\n            999, \"Test: Fields in doc: \" + _.keys(doc).sort().join(','));\n        },\n        fetch: ['field1']\n      });\n      restrictedCollectionForFetchAllTest.allow({\n        update: function() { return true; }\n      });\n    }\n\n    return cursors;\n  });\n}\n\nif (Meteor.isClient) {\n  _.each(['STRING', 'MONGO'], function (idGeneration) {\n    // Set up a bunch of test collections... on the client! They match the ones\n    // created by setUpAllowTestsCollections.\n\n    var nonce = Random.id();\n    // Tell the server to make, configure, and publish a set of collections unique\n    // to our test run. Since the method does not unblock, this will complete\n    // running on the server before anything else happens.\n    Meteor.subscribe('allowTests', nonce, idGeneration);\n\n    // helper for defining a collection, subscribing to it, and defining\n    // a method to clear it\n    var defineCollection = function(name, transform) {\n      var fullName = name + idGeneration + nonce;\n      var collection = new Mongo.Collection(\n        fullName, {idGeneration: idGeneration, transform: transform});\n\n      collection.callClearMethod = function (callback) {\n        Meteor.call(\"clear-collection-\" + fullName, callback);\n      };\n      collection.unnoncedName = name + idGeneration;\n      return collection;\n    };\n\n    // totally insecure collection\n    var insecureCollection = defineCollection(\"collection-insecure\");\n\n    // totally locked down collection\n    var lockedDownCollection = defineCollection(\"collection-locked-down\");\n\n    // restricted collection with same allowed modifications, both with and\n    // without the `insecure` package\n    var restrictedCollectionDefaultSecure = defineCollection(\n      \"collection-restrictedDefaultSecure\");\n    var restrictedCollectionDefaultInsecure = defineCollection(\n      \"collection-restrictedDefaultInsecure\");\n    var restrictedCollectionForUpdateOptionsTest = defineCollection(\n      \"collection-restrictedForUpdateOptionsTest\");\n    var restrictedCollectionForPartialAllowTest = defineCollection(\n      \"collection-restrictedForPartialAllowTest\");\n    var restrictedCollectionForPartialDenyTest = defineCollection(\n      \"collection-restrictedForPartialDenyTest\");\n    var restrictedCollectionForFetchTest = defineCollection(\n      \"collection-restrictedForFetchTest\");\n    var restrictedCollectionForFetchAllTest = defineCollection(\n      \"collection-restrictedForFetchAllTest\");\n    var restrictedCollectionWithTransform = defineCollection(\n      \"withTransform\", function (doc) {\n        return doc.a;\n      });\n    var restrictedCollectionForInvalidTransformTest = defineCollection(\n      \"collection-restrictedForInvalidTransform\");\n    var restrictedCollectionForClientIdTest = defineCollection(\n      \"collection-restrictedForClientIdTest\");\n\n    // test that if allow is called once then the collection is\n    // restricted, and that other mutations aren't allowed\n    testAsyncMulti(\"collection - partial allow, \" + idGeneration, [\n      function (test, expect) {\n        restrictedCollectionForPartialAllowTest.update(\n          'foo', {$set: {updated: true}}, expect(function (err, res) {\n            test.equal(err.error, 403);\n          }));\n      }\n    ]);\n\n    // test that if deny is called once then the collection is\n    // restricted, and that other mutations aren't allowed\n    testAsyncMulti(\"collection - partial deny, \" + idGeneration, [\n      function (test, expect) {\n        restrictedCollectionForPartialDenyTest.update(\n          'foo', {$set: {updated: true}}, expect(function (err, res) {\n            test.equal(err.error, 403);\n          }));\n      }\n    ]);\n\n\n    // test that we only fetch the fields specified\n    testAsyncMulti(\"collection - fetch, \" + idGeneration, [\n      function (test, expect) {\n        var fetchId = restrictedCollectionForFetchTest.insert(\n          {field1: 1, field2: 1, field3: 1, field4: 1});\n        var fetchAllId = restrictedCollectionForFetchAllTest.insert(\n          {field1: 1, field2: 1, field3: 1, field4: 1});\n        restrictedCollectionForFetchTest.update(\n          fetchId, {$set: {updated: true}}, expect(function (err, res) {\n            test.equal(err.reason,\n                       \"Test: Fields in doc: _id,field1,field2,field3\");\n          }));\n        restrictedCollectionForFetchTest.remove(\n          fetchId, expect(function (err, res) {\n            test.equal(err.reason,\n                       \"Test: Fields in doc: _id,field1,field2,field3\");\n          }));\n\n        restrictedCollectionForFetchAllTest.update(\n          fetchAllId, {$set: {updated: true}}, expect(function (err, res) {\n            test.equal(err.reason,\n                       \"Test: Fields in doc: _id,field1,field2,field3,field4\");\n          }));\n        restrictedCollectionForFetchAllTest.remove(\n          fetchAllId, expect(function (err, res) {\n            test.equal(err.reason,\n                       \"Test: Fields in doc: _id,field1,field2,field3,field4\");\n          }));\n      }\n    ]);\n\n    (function(){\n      testAsyncMulti(\"collection - restricted factories \" + idGeneration, [\n        function (test, expect) {\n          restrictedCollectionWithTransform.callClearMethod(expect(function () {\n            test.equal(restrictedCollectionWithTransform.find().count(), 0);\n          }));\n        },\n        function (test, expect) {\n          var self = this;\n          restrictedCollectionWithTransform.insert({\n            a: {foo: \"foo\", bar: \"bar\", baz: \"baz\"}\n          }, expect(function (e, res) {\n            test.isFalse(e);\n            test.isTrue(res);\n            self.item1 = res;\n          }));\n          restrictedCollectionWithTransform.insert({\n            a: {foo: \"foo\", bar: \"quux\", baz: \"quux\"},\n            b: \"potato\"\n          }, expect(function (e, res) {\n            test.isFalse(e);\n            test.isTrue(res);\n            self.item2 = res;\n          }));\n          restrictedCollectionWithTransform.insert({\n            a: {foo: \"adsfadf\", bar: \"quux\", baz: \"quux\"},\n            b: \"potato\"\n          }, expect(function (e, res) {\n            test.isTrue(e);\n          }));\n          restrictedCollectionWithTransform.insert({\n            a: {foo: \"bar\"},\n            topLevelField: true\n          }, expect(function (e, res) {\n            test.isFalse(e);\n            test.isTrue(res);\n            self.item3 = res;\n          }));\n        },\n        function (test, expect) {\n          var self = this;\n          // This should work, because there is an update allow for things with\n          // topLevelField.\n          restrictedCollectionWithTransform.update(\n            self.item3, { $set: { xxx: true } }, expect(function (e, res) {\n              test.isFalse(e);\n              test.equal(1, res);\n            }));\n        },\n        function (test, expect) {\n          var self = this;\n          test.equal(\n            restrictedCollectionWithTransform.findOne(self.item1),\n            {_id: self.item1, foo: \"foo\", bar: \"bar\", baz: \"baz\"});\n          restrictedCollectionWithTransform.remove(\n            self.item1, expect(function (e, res) {\n              test.isFalse(e);\n            }));\n          restrictedCollectionWithTransform.remove(\n            self.item2, expect(function (e, res) {\n              test.isTrue(e);\n            }));\n        }\n      ]);\n    })();\n\n    testAsyncMulti(\"collection - insecure, \" + idGeneration, [\n      function (test, expect) {\n        insecureCollection.callClearMethod(expect(function () {\n          test.equal(insecureCollection.find().count(), 0);\n        }));\n      },\n      function (test, expect) {\n        var id = insecureCollection.insert({foo: 'bar'}, expect(function(err, res) {\n          test.equal(res, id);\n          test.equal(insecureCollection.find(id).count(), 1);\n          test.equal(insecureCollection.findOne(id).foo, 'bar');\n        }));\n        test.equal(insecureCollection.find(id).count(), 1);\n        test.equal(insecureCollection.findOne(id).foo, 'bar');\n      }\n    ]);\n\n    testAsyncMulti(\"collection - locked down, \" + idGeneration, [\n      function (test, expect) {\n        lockedDownCollection.callClearMethod(expect(function() {\n          test.equal(lockedDownCollection.find().count(), 0);\n        }));\n      },\n      function (test, expect) {\n        lockedDownCollection.insert({foo: 'bar'}, expect(function (err, res) {\n          test.equal(err.error, 403);\n          test.equal(lockedDownCollection.find().count(), 0);\n        }));\n      }\n    ]);\n\n    (function () {\n      var collection = restrictedCollectionForUpdateOptionsTest;\n      var id1, id2;\n      testAsyncMulti(\"collection - update options, \" + idGeneration, [\n        // init\n        function (test, expect) {\n          collection.callClearMethod(expect(function () {\n            test.equal(collection.find().count(), 0);\n          }));\n        },\n        // put a few objects\n        function (test, expect) {\n          var doc = {canInsert: true, canUpdate: true};\n          id1 = collection.insert(doc);\n          id2 = collection.insert(doc);\n          collection.insert(doc);\n          collection.insert(doc, expect(function (err, res) {\n            test.isFalse(err);\n            test.equal(collection.find().count(), 4);\n          }));\n        },\n        // update by id\n        function (test, expect) {\n          collection.update(\n            id1,\n            {$set: {updated: true}},\n            expect(function (err, res) {\n              test.isFalse(err);\n              test.equal(res, 1);\n              test.equal(collection.find({updated: true}).count(), 1);\n            }));\n        },\n        // update by id in an object\n        function (test, expect) {\n          collection.update(\n            {_id: id2},\n            {$set: {updated: true}},\n            expect(function (err, res) {\n              test.isFalse(err);\n              test.equal(res, 1);\n              test.equal(collection.find({updated: true}).count(), 2);\n            }));\n        },\n        // update with replacement operator not allowed, and has nice error.\n        function (test, expect) {\n          collection.update(\n            {_id: id2},\n            {_id: id2, updated: true},\n            expect(function (err, res) {\n              test.equal(err.error, 403);\n              test.matches(err.reason, /In a restricted/);\n              // unchanged\n              test.equal(collection.find({updated: true}).count(), 2);\n            }));\n        },\n        // upsert not allowed, and has nice error.\n        function (test, expect) {\n          collection.update(\n            {_id: id2},\n            {$set: { upserted: true }},\n            { upsert: true },\n            expect(function (err, res) {\n              test.equal(err.error, 403);\n              test.matches(err.reason, /in a restricted/);\n              test.equal(collection.find({ upserted: true }).count(), 0);\n            }));\n        },\n        // update with rename operator not allowed, and has nice error.\n        function (test, expect) {\n          collection.update(\n            {_id: id2},\n            {$rename: {updated: 'asdf'}},\n            expect(function (err, res) {\n              test.equal(err.error, 403);\n              test.matches(err.reason, /not allowed/);\n              // unchanged\n              test.equal(collection.find({updated: true}).count(), 2);\n            }));\n        },\n        // update method with a non-ID selector is not allowed\n        function (test, expect) {\n          // We shouldn't even send the method...\n          test.throws(function () {\n            collection.update(\n              {updated: {$exists: false}},\n              {$set: {updated: true}});\n          });\n          // ... but if we did, the server would reject it too.\n          Meteor.call(\n            '/' + collection._name + '/update',\n            {updated: {$exists: false}},\n            {$set: {updated: true}},\n            expect(function (err, res) {\n              test.equal(err.error, 403);\n              // unchanged\n              test.equal(collection.find({updated: true}).count(), 2);\n            }));\n        },\n        // make sure it doesn't think that {_id: 'foo', something: else} is ok.\n        function (test, expect) {\n          test.throws(function () {\n            collection.update(\n              {_id: id1, updated: {$exists: false}},\n              {$set: {updated: true}});\n          });\n        },\n        // remove method with a non-ID selector is not allowed\n        function (test, expect) {\n          // We shouldn't even send the method...\n          test.throws(function () {\n            collection.remove({updated: true});\n          });\n          // ... but if we did, the server would reject it too.\n          Meteor.call(\n            '/' + collection._name + '/remove',\n            {updated: true},\n            expect(function (err, res) {\n              test.equal(err.error, 403);\n              // unchanged\n              test.equal(collection.find({updated: true}).count(), 2);\n            }));\n        }\n      ]);\n    }) ();\n\n    _.each(\n      [restrictedCollectionDefaultInsecure, restrictedCollectionDefaultSecure],\n      function(collection) {\n        var canUpdateId, canRemoveId;\n\n        testAsyncMulti(\"collection - \" + collection.unnoncedName, [\n          // init\n          function (test, expect) {\n            collection.callClearMethod(expect(function () {\n              test.equal(collection.find().count(), 0);\n            }));\n          },\n\n          // insert with no allows passing. request is denied.\n          function (test, expect) {\n            collection.insert(\n              {},\n              expect(function (err, res) {\n                test.equal(err.error, 403);\n                test.equal(collection.find().count(), 0);\n              }));\n          },\n          // insert with one allow and one deny. denied.\n          function (test, expect) {\n            collection.insert(\n              {canInsert: true, cantInsert: true},\n              expect(function (err, res) {\n                test.equal(err.error, 403);\n                test.equal(collection.find().count(), 0);\n              }));\n          },\n          // insert with one allow and other deny. denied.\n          function (test, expect) {\n            collection.insert(\n              {canInsert: true, _id: Random.id()},\n              expect(function (err, res) {\n                test.equal(err.error, 403);\n                test.equal(collection.find().count(), 0);\n              }));\n          },\n          // insert one allow passes. allowed.\n          function (test, expect) {\n            collection.insert(\n              {canInsert: true},\n              expect(function (err, res) {\n                test.isFalse(err);\n                test.equal(collection.find().count(), 1);\n              }));\n          },\n          // insert other allow passes. allowed.\n          // includes canUpdate for later.\n          function (test, expect) {\n            canUpdateId = collection.insert(\n              {canInsert2: true, canUpdate: true},\n              expect(function (err, res) {\n                test.isFalse(err);\n                test.equal(collection.find().count(), 2);\n              }));\n          },\n          // yet a third insert executes. this one has canRemove and\n          // cantRemove set for later.\n          function (test, expect) {\n            canRemoveId = collection.insert(\n              {canInsert: true, canRemove: true, cantRemove: true},\n              expect(function (err, res) {\n                test.isFalse(err);\n                test.equal(collection.find().count(), 3);\n              }));\n          },\n\n          // can't update with a non-operator mutation\n          function (test, expect) {\n            collection.update(\n              canUpdateId, {newObject: 1},\n              expect(function (err, res) {\n                test.equal(err.error, 403);\n                test.equal(collection.find().count(), 3);\n              }));\n          },\n\n          // updating dotted fields works as if we are changing their\n          // top part\n          function (test, expect) {\n            collection.update(\n              canUpdateId, {$set: {\"dotted.field\": 1}},\n              expect(function (err, res) {\n                test.isFalse(err);\n                test.equal(res, 1);\n                test.equal(collection.findOne(canUpdateId).dotted.field, 1);\n              }));\n          },\n          function (test, expect) {\n            collection.update(\n              canUpdateId, {$set: {\"verySecret.field\": 1}},\n              expect(function (err, res) {\n                test.equal(err.error, 403);\n                test.equal(collection.find({verySecret: {$exists: true}}).count(), 0);\n              }));\n          },\n\n          // update doesn't do anything if no docs match\n          function (test, expect) {\n            collection.update(\n              \"doesn't exist\",\n              {$set: {updated: true}},\n              expect(function (err, res) {\n                test.isFalse(err);\n                test.equal(res, 0);\n                // nothing has changed\n                test.equal(collection.find().count(), 3);\n                test.equal(collection.find({updated: true}).count(), 0);\n              }));\n          },\n          // update fails when access is denied trying to set `verySecret`\n          function (test, expect) {\n            collection.update(\n              canUpdateId, {$set: {verySecret: true}},\n              expect(function (err, res) {\n                test.equal(err.error, 403);\n                // nothing has changed\n                test.equal(collection.find().count(), 3);\n                test.equal(collection.find({updated: true}).count(), 0);\n              }));\n          },\n          // update fails when trying to set two fields, one of which is\n          // `verySecret`\n          function (test, expect) {\n            collection.update(\n              canUpdateId, {$set: {updated: true, verySecret: true}},\n              expect(function (err, res) {\n                test.equal(err.error, 403);\n                // nothing has changed\n                test.equal(collection.find().count(), 3);\n                test.equal(collection.find({updated: true}).count(), 0);\n              }));\n          },\n          // update fails when trying to modify docs that don't\n          // have `canUpdate` set\n          function (test, expect) {\n            collection.update(\n              canRemoveId,\n              {$set: {updated: true}},\n              expect(function (err, res) {\n                test.equal(err.error, 403);\n                // nothing has changed\n                test.equal(collection.find().count(), 3);\n                test.equal(collection.find({updated: true}).count(), 0);\n              }));\n          },\n          // update executes when it should\n          function (test, expect) {\n            collection.update(\n              canUpdateId,\n              {$set: {updated: true}},\n              expect(function (err, res) {\n                test.isFalse(err);\n                test.equal(res, 1);\n                test.equal(collection.find({updated: true}).count(), 1);\n              }));\n          },\n\n          // remove fails when trying to modify a doc with no `canRemove` set\n          function (test, expect) {\n            collection.remove(canUpdateId,\n                              expect(function (err, res) {\n              test.equal(err.error, 403);\n              // nothing has changed\n              test.equal(collection.find().count(), 3);\n            }));\n          },\n          // remove fails when trying to modify an doc with `cantRemove`\n          // set\n          function (test, expect) {\n            collection.remove(canRemoveId,\n                              expect(function (err, res) {\n              test.equal(err.error, 403);\n              // nothing has changed\n              test.equal(collection.find().count(), 3);\n            }));\n          },\n\n          // update the doc to remove cantRemove.\n          function (test, expect) {\n            collection.update(\n              canRemoveId,\n              {$set: {cantRemove: false, canUpdate2: true}},\n              expect(function (err, res) {\n                test.isFalse(err);\n                test.equal(res, 1);\n                test.equal(collection.find({cantRemove: true}).count(), 0);\n              }));\n          },\n\n          // now remove can remove it.\n          function (test, expect) {\n            collection.remove(canRemoveId,\n                              expect(function (err, res) {\n              test.isFalse(err);\n              test.equal(res, 1);\n              // successfully removed\n              test.equal(collection.find().count(), 2);\n            }));\n          },\n\n          // try to remove a doc that doesn't exist. see we remove no docs.\n          function (test, expect) {\n            collection.remove('some-random-id-that-never-matches',\n                              expect(function (err, res) {\n              test.isFalse(err);\n              test.equal(res, 0);\n              // nothing removed\n              test.equal(collection.find().count(), 2);\n            }));\n          },\n\n          // methods can still bypass restrictions\n          function (test, expect) {\n            collection.callClearMethod(\n              expect(function (err, res) {\n                test.isFalse(err);\n                // successfully removed\n                test.equal(collection.find().count(), 0);\n            }));\n          }\n        ]);\n      });\n    testAsyncMulti(\n      \"collection - allow/deny transform must return object, \" + idGeneration,\n      [function (test, expect) {\n        restrictedCollectionForInvalidTransformTest.insert({}, expect(function (err, res) {\n          test.isTrue(err);\n        }));\n      }]);\n    testAsyncMulti(\n      \"collection - restricted collection allows client-side id, \" + idGeneration,\n      [function (test, expect) {\n        var self = this;\n        self.id = Random.id();\n        restrictedCollectionForClientIdTest.insert({_id: self.id}, expect(function (err, res) {\n          test.isFalse(err);\n          test.equal(res, self.id);\n          test.equal(restrictedCollectionForClientIdTest.findOne(self.id),\n                     {_id: self.id});\n        }));\n      }]);\n  });  // end idGeneration loop\n}  // end if isClient\n\n\n\n// A few simple server-only tests which don't need to coordinate collections\n// with the client..\nif (Meteor.isServer) {\n  Tinytest.add(\"collection - allow and deny validate options\", function (test) {\n    var collection = new Mongo.Collection(null);\n\n    test.throws(function () {\n      collection.allow({invalidOption: true});\n    });\n    test.throws(function () {\n      collection.deny({invalidOption: true});\n    });\n\n    _.each(['insert', 'update', 'remove', 'fetch'], function (key) {\n      var options = {};\n      options[key] = true;\n      test.throws(function () {\n        collection.allow(options);\n      });\n      test.throws(function () {\n        collection.deny(options);\n      });\n    });\n\n    _.each(['insert', 'update', 'remove'], function (key) {\n      var options = {};\n      options[key] = false;\n      test.throws(function () {\n        collection.allow(options);\n      });\n      test.throws(function () {\n        collection.deny(options);\n      });\n    });\n\n    _.each(['insert', 'update', 'remove'], function (key) {\n      var options = {};\n      options[key] = undefined;\n      test.throws(function () {\n        collection.allow(options);\n      });\n      test.throws(function () {\n        collection.deny(options);\n      });\n    });\n\n    _.each(['insert', 'update', 'remove'], function (key) {\n      var options = {};\n      options[key] = ['an array']; // this should be a function, not an array\n      test.throws(function () {\n        collection.allow(options);\n      });\n      test.throws(function () {\n        collection.deny(options);\n      });\n    });\n\n    test.throws(function () {\n      collection.allow({fetch: function () {}}); // this should be an array\n    });\n  });\n\n  Tinytest.add(\"collection - calling allow restricts\", function (test) {\n    var collection = new Mongo.Collection(null);\n    test.equal(collection._restricted, false);\n    collection.allow({\n      insert: function() {}\n    });\n    test.equal(collection._restricted, true);\n  });\n\n  Tinytest.add(\"collection - global insecure\", function (test) {\n    // note: This test alters the global insecure status, by sneakily hacking\n    // the global Package object!\n    var insecurePackage = Package.insecure;\n\n    Package.insecure = {};\n    var collection = new Mongo.Collection(null);\n    test.equal(collection._isInsecure(), true);\n\n    Package.insecure = undefined;\n    test.equal(collection._isInsecure(), false);\n\n    delete Package.insecure;\n    test.equal(collection._isInsecure(), false);\n\n    collection._insecure = true;\n    test.equal(collection._isInsecure(), true);\n\n    if (insecurePackage)\n      Package.insecure = insecurePackage;\n    else\n      delete Package.insecure;\n  });\n}\n"]},"hash":"4c56b2a23d105474931ba89ac29306618b858bef"}
