{"metadata":{"usedHelpers":[],"marked":[],"modules":{"imports":[],"exports":{"exported":[],"specifiers":[]}}},"options":{"filename":"/packages/webapp-hashing/webapp-hashing.js","filenameRelative":"/packages/webapp-hashing/webapp-hashing.js","env":{},"retainLines":false,"highlightCode":true,"suppressDeprecationMessages":false,"presets":[],"plugins":[[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],{"polyfill":false}],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],{"loose":true}],[[],{"loose":true}],[[],null],[[],{"loose":true}],[[],null],[[],null],[[],{"allowTopLevelThis":true,"strict":false,"loose":true}],[[],null],[[],null],[[],null],[[],null],[[],null],[[],{"loose":true}],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null]],"ignore":[],"code":true,"metadata":true,"ast":false,"comments":true,"compact":false,"minified":false,"sourceMap":true,"sourceMaps":true,"sourceMapTarget":"/packages/webapp-hashing/webapp-hashing.js.map","sourceFileName":"/packages/webapp-hashing/webapp-hashing.js","babelrc":false,"sourceType":"module","moduleIds":false,"passPerPreset":false,"basename":"webapp-hashing"},"ignored":false,"code":"var crypto = Npm.require(\"crypto\");\n\nWebAppHashing = {};\n\n// Calculate a hash of all the client resources downloaded by the\n// browser, including the application HTML, runtime config, code, and\n// static files.\n//\n// This hash *must* change if any resources seen by the browser\n// change, and ideally *doesn't* change for any server-only changes\n// (but the second is a performance enhancement, not a hard\n// requirement).\n\nWebAppHashing.calculateClientHash = function (manifest, includeFilter, runtimeConfigOverride) {\n  var hash = crypto.createHash('sha1');\n\n  // Omit the old hashed client values in the new hash. These may be\n  // modified in the new boilerplate.\n  var runtimeCfg = _.omit(__meteor_runtime_config__, ['autoupdateVersion', 'autoupdateVersionRefreshable', 'autoupdateVersionCordova']);\n\n  if (runtimeConfigOverride) {\n    runtimeCfg = runtimeConfigOverride;\n  }\n\n  hash.update(JSON.stringify(runtimeCfg, 'utf8'));\n\n  _.each(manifest, function (resource) {\n    if ((!includeFilter || includeFilter(resource.type)) && (resource.where === 'client' || resource.where === 'internal')) {\n      hash.update(resource.path);\n      hash.update(resource.hash);\n    }\n  });\n  return hash.digest('hex');\n};\n\nWebAppHashing.calculateCordovaCompatibilityHash = function (platformVersion, pluginVersions) {\n  var hash = crypto.createHash('sha1');\n\n  hash.update(platformVersion);\n\n  // Sort plugins first so iteration order doesn't affect the hash\n  var plugins = Object.keys(pluginVersions).sort();\n  for (var _iterator = plugins, _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : _iterator[Symbol.iterator]();;) {\n    var _ref;\n\n    if (_isArray) {\n      if (_i >= _iterator.length) break;\n      _ref = _iterator[_i++];\n    } else {\n      _i = _iterator.next();\n      if (_i.done) break;\n      _ref = _i.value;\n    }\n\n    var plugin = _ref;\n\n    var version = pluginVersions[plugin];\n    hash.update(plugin);\n    hash.update(version);\n  }\n\n  return hash.digest('hex');\n};","ast":null,"map":{"version":3,"sources":["/packages/webapp-hashing/webapp-hashing.js"],"names":[],"mappings":"AAAA,IAAI,SAAS,IAAI,OAAJ,CAAY,QAAZ,CAAT;;AAEJ,gBAAgB,EAAhB;;;;;;;;;;;AAWA,cAAc,mBAAd,GACE,UAAU,QAAV,EAAoB,aAApB,EAAmC,qBAAnC,EAA0D;AAC1D,MAAI,OAAO,OAAO,UAAP,CAAkB,MAAlB,CAAP;;;;AADsD,MAKtD,aAAa,EAAE,IAAF,CAAO,yBAAP,EACf,CAAC,mBAAD,EAAsB,8BAAtB,EACC,0BADD,CADe,CAAb,CALsD;;AAS1D,MAAI,qBAAJ,EAA2B;AACzB,iBAAa,qBAAb,CADyB;GAA3B;;AAIA,OAAK,MAAL,CAAY,KAAK,SAAL,CAAe,UAAf,EAA2B,MAA3B,CAAZ,EAb0D;;AAe1D,IAAE,IAAF,CAAO,QAAP,EAAiB,UAAU,QAAV,EAAoB;AACjC,QAAI,CAAC,CAAE,aAAF,IAAmB,cAAc,SAAS,IAAT,CAAjC,CAAD,KACC,SAAS,KAAT,KAAmB,QAAnB,IAA+B,SAAS,KAAT,KAAmB,UAAnB,CADhC,EACgE;AACpE,WAAK,MAAL,CAAY,SAAS,IAAT,CAAZ,CADoE;AAEpE,WAAK,MAAL,CAAY,SAAS,IAAT,CAAZ,CAFoE;KADpE;GADa,CAAjB,CAf0D;AAsB1D,SAAO,KAAK,MAAL,CAAY,KAAZ,CAAP,CAtB0D;CAA1D;;AAyBF,cAAc,iCAAd,GACE,UAAS,eAAT,EAA0B,cAA1B,EAA0C;AAC1C,MAAM,OAAO,OAAO,UAAP,CAAkB,MAAlB,CAAP,CADoC;;AAG1C,OAAK,MAAL,CAAY,eAAZ;;;AAH0C,MAMpC,UAAU,OAAO,IAAP,CAAY,cAAZ,EAA4B,IAA5B,EAAV,CANoC;AAO1C,uBAAmB,qHAAnB,IAA4B;;;;;;;;;;;;QAAnB,cAAmB;;AAC1B,QAAM,UAAU,eAAe,MAAf,CAAV,CADoB;AAE1B,SAAK,MAAL,CAAY,MAAZ,EAF0B;AAG1B,SAAK,MAAL,CAAY,OAAZ,EAH0B;GAA5B;;AAMA,SAAO,KAAK,MAAL,CAAY,KAAZ,CAAP,CAb0C;CAA1C","file":"/packages/webapp-hashing/webapp-hashing.js.map","sourcesContent":["var crypto = Npm.require(\"crypto\");\n\nWebAppHashing = {};\n\n// Calculate a hash of all the client resources downloaded by the\n// browser, including the application HTML, runtime config, code, and\n// static files.\n//\n// This hash *must* change if any resources seen by the browser\n// change, and ideally *doesn't* change for any server-only changes\n// (but the second is a performance enhancement, not a hard\n// requirement).\n\nWebAppHashing.calculateClientHash =\n  function (manifest, includeFilter, runtimeConfigOverride) {\n  var hash = crypto.createHash('sha1');\n\n  // Omit the old hashed client values in the new hash. These may be\n  // modified in the new boilerplate.\n  var runtimeCfg = _.omit(__meteor_runtime_config__,\n    ['autoupdateVersion', 'autoupdateVersionRefreshable',\n     'autoupdateVersionCordova']);\n\n  if (runtimeConfigOverride) {\n    runtimeCfg = runtimeConfigOverride;\n  }\n\n  hash.update(JSON.stringify(runtimeCfg, 'utf8'));\n\n  _.each(manifest, function (resource) {\n      if ((! includeFilter || includeFilter(resource.type)) &&\n          (resource.where === 'client' || resource.where === 'internal')) {\n      hash.update(resource.path);\n      hash.update(resource.hash);\n    }\n  });\n  return hash.digest('hex');\n};\n\nWebAppHashing.calculateCordovaCompatibilityHash =\n  function(platformVersion, pluginVersions) {\n  const hash = crypto.createHash('sha1');\n\n  hash.update(platformVersion);\n\n  // Sort plugins first so iteration order doesn't affect the hash\n  const plugins = Object.keys(pluginVersions).sort();\n  for (let plugin of plugins) {\n    const version = pluginVersions[plugin];\n    hash.update(plugin);\n    hash.update(version);\n  }\n\n  return hash.digest('hex');\n};\n"]},"hash":"8bf0826efa961eb293b50d8e4a7b83c2d5a33db6"}
