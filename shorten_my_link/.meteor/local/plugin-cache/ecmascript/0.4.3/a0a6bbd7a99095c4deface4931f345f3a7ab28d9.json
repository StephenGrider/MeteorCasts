{"metadata":{"usedHelpers":[],"marked":[],"modules":{"imports":[],"exports":{"exported":[],"specifiers":[]}}},"options":{"filename":"/packages/mongo/oplog_observe_driver.js","filenameRelative":"/packages/mongo/oplog_observe_driver.js","env":{},"retainLines":false,"highlightCode":true,"suppressDeprecationMessages":false,"presets":[],"plugins":[[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],{"polyfill":false}],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],{"loose":true}],[[],{"loose":true}],[[],null],[[],{"loose":true}],[[],null],[[],null],[[],{"allowTopLevelThis":true,"strict":false,"loose":true}],[[],null],[[],null],[[],null],[[],null],[[],null],[[],{"loose":true}],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null]],"ignore":[],"code":true,"metadata":true,"ast":false,"comments":true,"compact":false,"minified":false,"sourceMap":true,"sourceMaps":true,"sourceMapTarget":"/packages/mongo/oplog_observe_driver.js.map","sourceFileName":"/packages/mongo/oplog_observe_driver.js","babelrc":false,"sourceType":"module","moduleIds":false,"passPerPreset":false,"basename":"oplog_observe_driver"},"ignored":false,"code":"var Fiber = Npm.require('fibers');\nvar Future = Npm.require('fibers/future');\n\nvar PHASE = {\n  QUERYING: \"QUERYING\",\n  FETCHING: \"FETCHING\",\n  STEADY: \"STEADY\"\n};\n\n// Exception thrown by _needToPollQuery which unrolls the stack up to the\n// enclosing call to finishIfNeedToPollQuery.\nvar SwitchedToQuery = function SwitchedToQuery() {};\nvar finishIfNeedToPollQuery = function finishIfNeedToPollQuery(f) {\n  return function () {\n    try {\n      f.apply(this, arguments);\n    } catch (e) {\n      if (!(e instanceof SwitchedToQuery)) throw e;\n    }\n  };\n};\n\nvar currentId = 0;\n\n// OplogObserveDriver is an alternative to PollingObserveDriver which follows\n// the Mongo operation log instead of just re-polling the query. It obeys the\n// same simple interface: constructing it starts sending observeChanges\n// callbacks (and a ready() invocation) to the ObserveMultiplexer, and you stop\n// it by calling the stop() method.\nOplogObserveDriver = function OplogObserveDriver(options) {\n  var self = this;\n  self._usesOplog = true; // tests look at this\n\n  self._id = currentId;\n  currentId++;\n\n  self._cursorDescription = options.cursorDescription;\n  self._mongoHandle = options.mongoHandle;\n  self._multiplexer = options.multiplexer;\n\n  if (options.ordered) {\n    throw Error(\"OplogObserveDriver only supports unordered observeChanges\");\n  }\n\n  var sorter = options.sorter;\n  // We don't support $near and other geo-queries so it's OK to initialize the\n  // comparator only once in the constructor.\n  var comparator = sorter && sorter.getComparator();\n\n  if (options.cursorDescription.options.limit) {\n    // There are several properties ordered driver implements:\n    // - _limit is a positive number\n    // - _comparator is a function-comparator by which the query is ordered\n    // - _unpublishedBuffer is non-null Min/Max Heap,\n    //                      the empty buffer in STEADY phase implies that the\n    //                      everything that matches the queries selector fits\n    //                      into published set.\n    // - _published - Min Heap (also implements IdMap methods)\n\n    var heapOptions = { IdMap: LocalCollection._IdMap };\n    self._limit = self._cursorDescription.options.limit;\n    self._comparator = comparator;\n    self._sorter = sorter;\n    self._unpublishedBuffer = new MinMaxHeap(comparator, heapOptions);\n    // We need something that can find Max value in addition to IdMap interface\n    self._published = new MaxHeap(comparator, heapOptions);\n  } else {\n    self._limit = 0;\n    self._comparator = null;\n    self._sorter = null;\n    self._unpublishedBuffer = null;\n    self._published = new LocalCollection._IdMap();\n  }\n\n  // Indicates if it is safe to insert a new document at the end of the buffer\n  // for this query. i.e. it is known that there are no documents matching the\n  // selector those are not in published or buffer.\n  self._safeAppendToBuffer = false;\n\n  self._stopped = false;\n  self._stopHandles = [];\n\n  Package.facts && Package.facts.Facts.incrementServerFact(\"mongo-livedata\", \"observe-drivers-oplog\", 1);\n\n  self._registerPhaseChange(PHASE.QUERYING);\n\n  var selector = self._cursorDescription.selector;\n  self._matcher = options.matcher;\n  var projection = self._cursorDescription.options.fields || {};\n  self._projectionFn = LocalCollection._compileProjection(projection);\n  // Projection function, result of combining important fields for selector and\n  // existing fields projection\n  self._sharedProjection = self._matcher.combineIntoProjection(projection);\n  if (sorter) self._sharedProjection = sorter.combineIntoProjection(self._sharedProjection);\n  self._sharedProjectionFn = LocalCollection._compileProjection(self._sharedProjection);\n\n  self._needToFetch = new LocalCollection._IdMap();\n  self._currentlyFetching = null;\n  self._fetchGeneration = 0;\n\n  self._requeryWhenDoneThisQuery = false;\n  self._writesToCommitWhenWeReachSteady = [];\n\n  // If the oplog handle tells us that it skipped some entries (because it got\n  // behind, say), re-poll.\n  self._stopHandles.push(self._mongoHandle._oplogHandle.onSkippedEntries(finishIfNeedToPollQuery(function () {\n    self._needToPollQuery();\n  })));\n\n  forEachTrigger(self._cursorDescription, function (trigger) {\n    self._stopHandles.push(self._mongoHandle._oplogHandle.onOplogEntry(trigger, function (notification) {\n      Meteor._noYieldsAllowed(finishIfNeedToPollQuery(function () {\n        var op = notification.op;\n        if (notification.dropCollection || notification.dropDatabase) {\n          // Note: this call is not allowed to block on anything (especially\n          // on waiting for oplog entries to catch up) because that will block\n          // onOplogEntry!\n          self._needToPollQuery();\n        } else {\n          // All other operators should be handled depending on phase\n          if (self._phase === PHASE.QUERYING) self._handleOplogEntryQuerying(op);else self._handleOplogEntrySteadyOrFetching(op);\n        }\n      }));\n    }));\n  });\n\n  // XXX ordering w.r.t. everything else?\n  self._stopHandles.push(listenAll(self._cursorDescription, function (notification) {\n    // If we're not in a pre-fire write fence, we don't have to do anything.\n    var fence = DDPServer._CurrentWriteFence.get();\n    if (!fence || fence.fired) return;\n\n    if (fence._oplogObserveDrivers) {\n      fence._oplogObserveDrivers[self._id] = self;\n      return;\n    }\n\n    fence._oplogObserveDrivers = {};\n    fence._oplogObserveDrivers[self._id] = self;\n\n    fence.onBeforeFire(function () {\n      var drivers = fence._oplogObserveDrivers;\n      delete fence._oplogObserveDrivers;\n\n      // This fence cannot fire until we've caught up to \"this point\" in the\n      // oplog, and all observers made it back to the steady state.\n      self._mongoHandle._oplogHandle.waitUntilCaughtUp();\n\n      _.each(drivers, function (driver) {\n        if (driver._stopped) return;\n\n        var write = fence.beginWrite();\n        if (driver._phase === PHASE.STEADY) {\n          // Make sure that all of the callbacks have made it through the\n          // multiplexer and been delivered to ObserveHandles before committing\n          // writes.\n          driver._multiplexer.onFlush(function () {\n            write.committed();\n          });\n        } else {\n          driver._writesToCommitWhenWeReachSteady.push(write);\n        }\n      });\n    });\n  }));\n\n  // When Mongo fails over, we need to repoll the query, in case we processed an\n  // oplog entry that got rolled back.\n  self._stopHandles.push(self._mongoHandle._onFailover(finishIfNeedToPollQuery(function () {\n    self._needToPollQuery();\n  })));\n\n  // Give _observeChanges a chance to add the new ObserveHandle to our\n  // multiplexer, so that the added calls get streamed.\n  Meteor.defer(finishIfNeedToPollQuery(function () {\n    self._runInitialQuery();\n  }));\n};\n\n_.extend(OplogObserveDriver.prototype, {\n  _addPublished: function () {\n    function _addPublished(id, doc) {\n      var self = this;\n      Meteor._noYieldsAllowed(function () {\n        var fields = _.clone(doc);\n        delete fields._id;\n        self._published.set(id, self._sharedProjectionFn(doc));\n        self._multiplexer.added(id, self._projectionFn(fields));\n\n        // After adding this document, the published set might be overflowed\n        // (exceeding capacity specified by limit). If so, push the maximum\n        // element to the buffer, we might want to save it in memory to reduce the\n        // amount of Mongo lookups in the future.\n        if (self._limit && self._published.size() > self._limit) {\n          // XXX in theory the size of published is no more than limit+1\n          if (self._published.size() !== self._limit + 1) {\n            throw new Error(\"After adding to published, \" + (self._published.size() - self._limit) + \" documents are overflowing the set\");\n          }\n\n          var overflowingDocId = self._published.maxElementId();\n          var overflowingDoc = self._published.get(overflowingDocId);\n\n          if (EJSON.equals(overflowingDocId, id)) {\n            throw new Error(\"The document just added is overflowing the published set\");\n          }\n\n          self._published.remove(overflowingDocId);\n          self._multiplexer.removed(overflowingDocId);\n          self._addBuffered(overflowingDocId, overflowingDoc);\n        }\n      });\n    }\n\n    return _addPublished;\n  }(),\n  _removePublished: function () {\n    function _removePublished(id) {\n      var self = this;\n      Meteor._noYieldsAllowed(function () {\n        self._published.remove(id);\n        self._multiplexer.removed(id);\n        if (!self._limit || self._published.size() === self._limit) return;\n\n        if (self._published.size() > self._limit) throw Error(\"self._published got too big\");\n\n        // OK, we are publishing less than the limit. Maybe we should look in the\n        // buffer to find the next element past what we were publishing before.\n\n        if (!self._unpublishedBuffer.empty()) {\n          // There's something in the buffer; move the first thing in it to\n          // _published.\n          var newDocId = self._unpublishedBuffer.minElementId();\n          var newDoc = self._unpublishedBuffer.get(newDocId);\n          self._removeBuffered(newDocId);\n          self._addPublished(newDocId, newDoc);\n          return;\n        }\n\n        // There's nothing in the buffer.  This could mean one of a few things.\n\n        // (a) We could be in the middle of re-running the query (specifically, we\n        // could be in _publishNewResults). In that case, _unpublishedBuffer is\n        // empty because we clear it at the beginning of _publishNewResults. In\n        // this case, our caller already knows the entire answer to the query and\n        // we don't need to do anything fancy here.  Just return.\n        if (self._phase === PHASE.QUERYING) return;\n\n        // (b) We're pretty confident that the union of _published and\n        // _unpublishedBuffer contain all documents that match selector. Because\n        // _unpublishedBuffer is empty, that means we're confident that _published\n        // contains all documents that match selector. So we have nothing to do.\n        if (self._safeAppendToBuffer) return;\n\n        // (c) Maybe there are other documents out there that should be in our\n        // buffer. But in that case, when we emptied _unpublishedBuffer in\n        // _removeBuffered, we should have called _needToPollQuery, which will\n        // either put something in _unpublishedBuffer or set _safeAppendToBuffer\n        // (or both), and it will put us in QUERYING for that whole time. So in\n        // fact, we shouldn't be able to get here.\n\n        throw new Error(\"Buffer inexplicably empty\");\n      });\n    }\n\n    return _removePublished;\n  }(),\n  _changePublished: function () {\n    function _changePublished(id, oldDoc, newDoc) {\n      var self = this;\n      Meteor._noYieldsAllowed(function () {\n        self._published.set(id, self._sharedProjectionFn(newDoc));\n        var projectedNew = self._projectionFn(newDoc);\n        var projectedOld = self._projectionFn(oldDoc);\n        var changed = DiffSequence.makeChangedFields(projectedNew, projectedOld);\n        if (!_.isEmpty(changed)) self._multiplexer.changed(id, changed);\n      });\n    }\n\n    return _changePublished;\n  }(),\n  _addBuffered: function () {\n    function _addBuffered(id, doc) {\n      var self = this;\n      Meteor._noYieldsAllowed(function () {\n        self._unpublishedBuffer.set(id, self._sharedProjectionFn(doc));\n\n        // If something is overflowing the buffer, we just remove it from cache\n        if (self._unpublishedBuffer.size() > self._limit) {\n          var maxBufferedId = self._unpublishedBuffer.maxElementId();\n\n          self._unpublishedBuffer.remove(maxBufferedId);\n\n          // Since something matching is removed from cache (both published set and\n          // buffer), set flag to false\n          self._safeAppendToBuffer = false;\n        }\n      });\n    }\n\n    return _addBuffered;\n  }(),\n  // Is called either to remove the doc completely from matching set or to move\n  // it to the published set later.\n  _removeBuffered: function () {\n    function _removeBuffered(id) {\n      var self = this;\n      Meteor._noYieldsAllowed(function () {\n        self._unpublishedBuffer.remove(id);\n        // To keep the contract \"buffer is never empty in STEADY phase unless the\n        // everything matching fits into published\" true, we poll everything as\n        // soon as we see the buffer becoming empty.\n        if (!self._unpublishedBuffer.size() && !self._safeAppendToBuffer) self._needToPollQuery();\n      });\n    }\n\n    return _removeBuffered;\n  }(),\n  // Called when a document has joined the \"Matching\" results set.\n  // Takes responsibility of keeping _unpublishedBuffer in sync with _published\n  // and the effect of limit enforced.\n  _addMatching: function () {\n    function _addMatching(doc) {\n      var self = this;\n      Meteor._noYieldsAllowed(function () {\n        var id = doc._id;\n        if (self._published.has(id)) throw Error(\"tried to add something already published \" + id);\n        if (self._limit && self._unpublishedBuffer.has(id)) throw Error(\"tried to add something already existed in buffer \" + id);\n\n        var limit = self._limit;\n        var comparator = self._comparator;\n        var maxPublished = limit && self._published.size() > 0 ? self._published.get(self._published.maxElementId()) : null;\n        var maxBuffered = limit && self._unpublishedBuffer.size() > 0 ? self._unpublishedBuffer.get(self._unpublishedBuffer.maxElementId()) : null;\n        // The query is unlimited or didn't publish enough documents yet or the\n        // new document would fit into published set pushing the maximum element\n        // out, then we need to publish the doc.\n        var toPublish = !limit || self._published.size() < limit || comparator(doc, maxPublished) < 0;\n\n        // Otherwise we might need to buffer it (only in case of limited query).\n        // Buffering is allowed if the buffer is not filled up yet and all\n        // matching docs are either in the published set or in the buffer.\n        var canAppendToBuffer = !toPublish && self._safeAppendToBuffer && self._unpublishedBuffer.size() < limit;\n\n        // Or if it is small enough to be safely inserted to the middle or the\n        // beginning of the buffer.\n        var canInsertIntoBuffer = !toPublish && maxBuffered && comparator(doc, maxBuffered) <= 0;\n\n        var toBuffer = canAppendToBuffer || canInsertIntoBuffer;\n\n        if (toPublish) {\n          self._addPublished(id, doc);\n        } else if (toBuffer) {\n          self._addBuffered(id, doc);\n        } else {\n          // dropping it and not saving to the cache\n          self._safeAppendToBuffer = false;\n        }\n      });\n    }\n\n    return _addMatching;\n  }(),\n  // Called when a document leaves the \"Matching\" results set.\n  // Takes responsibility of keeping _unpublishedBuffer in sync with _published\n  // and the effect of limit enforced.\n  _removeMatching: function () {\n    function _removeMatching(id) {\n      var self = this;\n      Meteor._noYieldsAllowed(function () {\n        if (!self._published.has(id) && !self._limit) throw Error(\"tried to remove something matching but not cached \" + id);\n\n        if (self._published.has(id)) {\n          self._removePublished(id);\n        } else if (self._unpublishedBuffer.has(id)) {\n          self._removeBuffered(id);\n        }\n      });\n    }\n\n    return _removeMatching;\n  }(),\n  _handleDoc: function () {\n    function _handleDoc(id, newDoc) {\n      var self = this;\n      Meteor._noYieldsAllowed(function () {\n        var matchesNow = newDoc && self._matcher.documentMatches(newDoc).result;\n\n        var publishedBefore = self._published.has(id);\n        var bufferedBefore = self._limit && self._unpublishedBuffer.has(id);\n        var cachedBefore = publishedBefore || bufferedBefore;\n\n        if (matchesNow && !cachedBefore) {\n          self._addMatching(newDoc);\n        } else if (cachedBefore && !matchesNow) {\n          self._removeMatching(id);\n        } else if (cachedBefore && matchesNow) {\n          var oldDoc = self._published.get(id);\n          var comparator = self._comparator;\n          var minBuffered = self._limit && self._unpublishedBuffer.size() && self._unpublishedBuffer.get(self._unpublishedBuffer.minElementId());\n\n          if (publishedBefore) {\n            // Unlimited case where the document stays in published once it\n            // matches or the case when we don't have enough matching docs to\n            // publish or the changed but matching doc will stay in published\n            // anyways.\n            //\n            // XXX: We rely on the emptiness of buffer. Be sure to maintain the\n            // fact that buffer can't be empty if there are matching documents not\n            // published. Notably, we don't want to schedule repoll and continue\n            // relying on this property.\n            var staysInPublished = !self._limit || self._unpublishedBuffer.size() === 0 || comparator(newDoc, minBuffered) <= 0;\n\n            if (staysInPublished) {\n              self._changePublished(id, oldDoc, newDoc);\n            } else {\n              // after the change doc doesn't stay in the published, remove it\n              self._removePublished(id);\n              // but it can move into buffered now, check it\n              var maxBuffered = self._unpublishedBuffer.get(self._unpublishedBuffer.maxElementId());\n\n              var toBuffer = self._safeAppendToBuffer || maxBuffered && comparator(newDoc, maxBuffered) <= 0;\n\n              if (toBuffer) {\n                self._addBuffered(id, newDoc);\n              } else {\n                // Throw away from both published set and buffer\n                self._safeAppendToBuffer = false;\n              }\n            }\n          } else if (bufferedBefore) {\n            oldDoc = self._unpublishedBuffer.get(id);\n            // remove the old version manually instead of using _removeBuffered so\n            // we don't trigger the querying immediately.  if we end this block\n            // with the buffer empty, we will need to trigger the query poll\n            // manually too.\n            self._unpublishedBuffer.remove(id);\n\n            var maxPublished = self._published.get(self._published.maxElementId());\n            var maxBuffered = self._unpublishedBuffer.size() && self._unpublishedBuffer.get(self._unpublishedBuffer.maxElementId());\n\n            // the buffered doc was updated, it could move to published\n            var toPublish = comparator(newDoc, maxPublished) < 0;\n\n            // or stays in buffer even after the change\n            var staysInBuffer = !toPublish && self._safeAppendToBuffer || !toPublish && maxBuffered && comparator(newDoc, maxBuffered) <= 0;\n\n            if (toPublish) {\n              self._addPublished(id, newDoc);\n            } else if (staysInBuffer) {\n              // stays in buffer but changes\n              self._unpublishedBuffer.set(id, newDoc);\n            } else {\n              // Throw away from both published set and buffer\n              self._safeAppendToBuffer = false;\n              // Normally this check would have been done in _removeBuffered but\n              // we didn't use it, so we need to do it ourself now.\n              if (!self._unpublishedBuffer.size()) {\n                self._needToPollQuery();\n              }\n            }\n          } else {\n            throw new Error(\"cachedBefore implies either of publishedBefore or bufferedBefore is true.\");\n          }\n        }\n      });\n    }\n\n    return _handleDoc;\n  }(),\n  _fetchModifiedDocuments: function () {\n    function _fetchModifiedDocuments() {\n      var self = this;\n      Meteor._noYieldsAllowed(function () {\n        self._registerPhaseChange(PHASE.FETCHING);\n        // Defer, because nothing called from the oplog entry handler may yield,\n        // but fetch() yields.\n        Meteor.defer(finishIfNeedToPollQuery(function () {\n          while (!self._stopped && !self._needToFetch.empty()) {\n            if (self._phase === PHASE.QUERYING) {\n              // While fetching, we decided to go into QUERYING mode, and then we\n              // saw another oplog entry, so _needToFetch is not empty. But we\n              // shouldn't fetch these documents until AFTER the query is done.\n              break;\n            }\n\n            // Being in steady phase here would be surprising.\n            if (self._phase !== PHASE.FETCHING) throw new Error(\"phase in fetchModifiedDocuments: \" + self._phase);\n\n            self._currentlyFetching = self._needToFetch;\n            var thisGeneration = ++self._fetchGeneration;\n            self._needToFetch = new LocalCollection._IdMap();\n            var waiting = 0;\n            var fut = new Future();\n            // This loop is safe, because _currentlyFetching will not be updated\n            // during this loop (in fact, it is never mutated).\n            self._currentlyFetching.forEach(function (cacheKey, id) {\n              waiting++;\n              self._mongoHandle._docFetcher.fetch(self._cursorDescription.collectionName, id, cacheKey, finishIfNeedToPollQuery(function (err, doc) {\n                try {\n                  if (err) {\n                    Meteor._debug(\"Got exception while fetching documents: \" + err);\n                    // If we get an error from the fetcher (eg, trouble\n                    // connecting to Mongo), let's just abandon the fetch phase\n                    // altogether and fall back to polling. It's not like we're\n                    // getting live updates anyway.\n                    if (self._phase !== PHASE.QUERYING) {\n                      self._needToPollQuery();\n                    }\n                  } else if (!self._stopped && self._phase === PHASE.FETCHING && self._fetchGeneration === thisGeneration) {\n                    // We re-check the generation in case we've had an explicit\n                    // _pollQuery call (eg, in another fiber) which should\n                    // effectively cancel this round of fetches.  (_pollQuery\n                    // increments the generation.)\n                    self._handleDoc(id, doc);\n                  }\n                } finally {\n                  waiting--;\n                  // Because fetch() never calls its callback synchronously,\n                  // this is safe (ie, we won't call fut.return() before the\n                  // forEach is done).\n                  if (waiting === 0) fut['return']();\n                }\n              }));\n            });\n            fut.wait();\n            // Exit now if we've had a _pollQuery call (here or in another fiber).\n            if (self._phase === PHASE.QUERYING) return;\n            self._currentlyFetching = null;\n          }\n          // We're done fetching, so we can be steady, unless we've had a\n          // _pollQuery call (here or in another fiber).\n          if (self._phase !== PHASE.QUERYING) self._beSteady();\n        }));\n      });\n    }\n\n    return _fetchModifiedDocuments;\n  }(),\n  _beSteady: function () {\n    function _beSteady() {\n      var self = this;\n      Meteor._noYieldsAllowed(function () {\n        self._registerPhaseChange(PHASE.STEADY);\n        var writes = self._writesToCommitWhenWeReachSteady;\n        self._writesToCommitWhenWeReachSteady = [];\n        self._multiplexer.onFlush(function () {\n          _.each(writes, function (w) {\n            w.committed();\n          });\n        });\n      });\n    }\n\n    return _beSteady;\n  }(),\n  _handleOplogEntryQuerying: function () {\n    function _handleOplogEntryQuerying(op) {\n      var self = this;\n      Meteor._noYieldsAllowed(function () {\n        self._needToFetch.set(idForOp(op), op.ts.toString());\n      });\n    }\n\n    return _handleOplogEntryQuerying;\n  }(),\n  _handleOplogEntrySteadyOrFetching: function () {\n    function _handleOplogEntrySteadyOrFetching(op) {\n      var self = this;\n      Meteor._noYieldsAllowed(function () {\n        var id = idForOp(op);\n        // If we're already fetching this one, or about to, we can't optimize;\n        // make sure that we fetch it again if necessary.\n        if (self._phase === PHASE.FETCHING && (self._currentlyFetching && self._currentlyFetching.has(id) || self._needToFetch.has(id))) {\n          self._needToFetch.set(id, op.ts.toString());\n          return;\n        }\n\n        if (op.op === 'd') {\n          if (self._published.has(id) || self._limit && self._unpublishedBuffer.has(id)) self._removeMatching(id);\n        } else if (op.op === 'i') {\n          if (self._published.has(id)) throw new Error(\"insert found for already-existing ID in published\");\n          if (self._unpublishedBuffer && self._unpublishedBuffer.has(id)) throw new Error(\"insert found for already-existing ID in buffer\");\n\n          // XXX what if selector yields?  for now it can't but later it could\n          // have $where\n          if (self._matcher.documentMatches(op.o).result) self._addMatching(op.o);\n        } else if (op.op === 'u') {\n          // Is this a modifier ($set/$unset, which may require us to poll the\n          // database to figure out if the whole document matches the selector) or\n          // a replacement (in which case we can just directly re-evaluate the\n          // selector)?\n          var isReplace = !_.has(op.o, '$set') && !_.has(op.o, '$unset');\n          // If this modifier modifies something inside an EJSON custom type (ie,\n          // anything with EJSON$), then we can't try to use\n          // LocalCollection._modify, since that just mutates the EJSON encoding,\n          // not the actual object.\n          var canDirectlyModifyDoc = !isReplace && modifierCanBeDirectlyApplied(op.o);\n\n          var publishedBefore = self._published.has(id);\n          var bufferedBefore = self._limit && self._unpublishedBuffer.has(id);\n\n          if (isReplace) {\n            self._handleDoc(id, _.extend({ _id: id }, op.o));\n          } else if ((publishedBefore || bufferedBefore) && canDirectlyModifyDoc) {\n            // Oh great, we actually know what the document is, so we can apply\n            // this directly.\n            var newDoc = self._published.has(id) ? self._published.get(id) : self._unpublishedBuffer.get(id);\n            newDoc = EJSON.clone(newDoc);\n\n            newDoc._id = id;\n            try {\n              LocalCollection._modify(newDoc, op.o);\n            } catch (e) {\n              if (e.name !== \"MinimongoError\") throw e;\n              // We didn't understand the modifier.  Re-fetch.\n              self._needToFetch.set(id, op.ts.toString());\n              if (self._phase === PHASE.STEADY) {\n                self._fetchModifiedDocuments();\n              }\n              return;\n            }\n            self._handleDoc(id, self._sharedProjectionFn(newDoc));\n          } else if (!canDirectlyModifyDoc || self._matcher.canBecomeTrueByModifier(op.o) || self._sorter && self._sorter.affectedByModifier(op.o)) {\n            self._needToFetch.set(id, op.ts.toString());\n            if (self._phase === PHASE.STEADY) self._fetchModifiedDocuments();\n          }\n        } else {\n          throw Error(\"XXX SURPRISING OPERATION: \" + op);\n        }\n      });\n    }\n\n    return _handleOplogEntrySteadyOrFetching;\n  }(),\n  // Yields!\n  _runInitialQuery: function () {\n    function _runInitialQuery() {\n      var self = this;\n      if (self._stopped) throw new Error(\"oplog stopped surprisingly early\");\n\n      self._runQuery({ initial: true }); // yields\n\n      if (self._stopped) return; // can happen on queryError\n\n      // Allow observeChanges calls to return. (After this, it's possible for\n      // stop() to be called.)\n      self._multiplexer.ready();\n\n      self._doneQuerying(); // yields\n    }\n\n    return _runInitialQuery;\n  }(),\n\n  // In various circumstances, we may just want to stop processing the oplog and\n  // re-run the initial query, just as if we were a PollingObserveDriver.\n  //\n  // This function may not block, because it is called from an oplog entry\n  // handler.\n  //\n  // XXX We should call this when we detect that we've been in FETCHING for \"too\n  // long\".\n  //\n  // XXX We should call this when we detect Mongo failover (since that might\n  // mean that some of the oplog entries we have processed have been rolled\n  // back). The Node Mongo driver is in the middle of a bunch of huge\n  // refactorings, including the way that it notifies you when primary\n  // changes. Will put off implementing this until driver 1.4 is out.\n  _pollQuery: function () {\n    function _pollQuery() {\n      var self = this;\n      Meteor._noYieldsAllowed(function () {\n        if (self._stopped) return;\n\n        // Yay, we get to forget about all the things we thought we had to fetch.\n        self._needToFetch = new LocalCollection._IdMap();\n        self._currentlyFetching = null;\n        ++self._fetchGeneration; // ignore any in-flight fetches\n        self._registerPhaseChange(PHASE.QUERYING);\n\n        // Defer so that we don't yield.  We don't need finishIfNeedToPollQuery\n        // here because SwitchedToQuery is not thrown in QUERYING mode.\n        Meteor.defer(function () {\n          self._runQuery();\n          self._doneQuerying();\n        });\n      });\n    }\n\n    return _pollQuery;\n  }(),\n\n  // Yields!\n  _runQuery: function () {\n    function _runQuery(options) {\n      var self = this;\n      options = options || {};\n      var newResults, newBuffer;\n\n      // This while loop is just to retry failures.\n      while (true) {\n        // If we've been stopped, we don't have to run anything any more.\n        if (self._stopped) return;\n\n        newResults = new LocalCollection._IdMap();\n        newBuffer = new LocalCollection._IdMap();\n\n        // Query 2x documents as the half excluded from the original query will go\n        // into unpublished buffer to reduce additional Mongo lookups in cases\n        // when documents are removed from the published set and need a\n        // replacement.\n        // XXX needs more thought on non-zero skip\n        // XXX 2 is a \"magic number\" meaning there is an extra chunk of docs for\n        // buffer if such is needed.\n        var cursor = self._cursorForQuery({ limit: self._limit * 2 });\n        try {\n          cursor.forEach(function (doc, i) {\n            // yields\n            if (!self._limit || i < self._limit) newResults.set(doc._id, doc);else newBuffer.set(doc._id, doc);\n          });\n          break;\n        } catch (e) {\n          if (options.initial && typeof e.code === 'number') {\n            // This is an error document sent to us by mongod, not a connection\n            // error generated by the client. And we've never seen this query work\n            // successfully. Probably it's a bad selector or something, so we\n            // should NOT retry. Instead, we should halt the observe (which ends\n            // up calling `stop` on us).\n            self._multiplexer.queryError(e);\n            return;\n          }\n\n          // During failover (eg) if we get an exception we should log and retry\n          // instead of crashing.\n          Meteor._debug(\"Got exception while polling query: \" + e);\n          Meteor._sleepForMs(100);\n        }\n      }\n\n      if (self._stopped) return;\n\n      self._publishNewResults(newResults, newBuffer);\n    }\n\n    return _runQuery;\n  }(),\n\n  // Transitions to QUERYING and runs another query, or (if already in QUERYING)\n  // ensures that we will query again later.\n  //\n  // This function may not block, because it is called from an oplog entry\n  // handler. However, if we were not already in the QUERYING phase, it throws\n  // an exception that is caught by the closest surrounding\n  // finishIfNeedToPollQuery call; this ensures that we don't continue running\n  // close that was designed for another phase inside PHASE.QUERYING.\n  //\n  // (It's also necessary whenever logic in this file yields to check that other\n  // phases haven't put us into QUERYING mode, though; eg,\n  // _fetchModifiedDocuments does this.)\n  _needToPollQuery: function () {\n    function _needToPollQuery() {\n      var self = this;\n      Meteor._noYieldsAllowed(function () {\n        if (self._stopped) return;\n\n        // If we're not already in the middle of a query, we can query now\n        // (possibly pausing FETCHING).\n        if (self._phase !== PHASE.QUERYING) {\n          self._pollQuery();\n          throw new SwitchedToQuery();\n        }\n\n        // We're currently in QUERYING. Set a flag to ensure that we run another\n        // query when we're done.\n        self._requeryWhenDoneThisQuery = true;\n      });\n    }\n\n    return _needToPollQuery;\n  }(),\n\n  // Yields!\n  _doneQuerying: function () {\n    function _doneQuerying() {\n      var self = this;\n\n      if (self._stopped) return;\n      self._mongoHandle._oplogHandle.waitUntilCaughtUp(); // yields\n      if (self._stopped) return;\n      if (self._phase !== PHASE.QUERYING) throw Error(\"Phase unexpectedly \" + self._phase);\n\n      Meteor._noYieldsAllowed(function () {\n        if (self._requeryWhenDoneThisQuery) {\n          self._requeryWhenDoneThisQuery = false;\n          self._pollQuery();\n        } else if (self._needToFetch.empty()) {\n          self._beSteady();\n        } else {\n          self._fetchModifiedDocuments();\n        }\n      });\n    }\n\n    return _doneQuerying;\n  }(),\n\n  _cursorForQuery: function () {\n    function _cursorForQuery(optionsOverwrite) {\n      var self = this;\n      return Meteor._noYieldsAllowed(function () {\n        // The query we run is almost the same as the cursor we are observing,\n        // with a few changes. We need to read all the fields that are relevant to\n        // the selector, not just the fields we are going to publish (that's the\n        // \"shared\" projection). And we don't want to apply any transform in the\n        // cursor, because observeChanges shouldn't use the transform.\n        var options = _.clone(self._cursorDescription.options);\n\n        // Allow the caller to modify the options. Useful to specify different\n        // skip and limit values.\n        _.extend(options, optionsOverwrite);\n\n        options.fields = self._sharedProjection;\n        delete options.transform;\n        // We are NOT deep cloning fields or selector here, which should be OK.\n        var description = new CursorDescription(self._cursorDescription.collectionName, self._cursorDescription.selector, options);\n        return new Cursor(self._mongoHandle, description);\n      });\n    }\n\n    return _cursorForQuery;\n  }(),\n\n  // Replace self._published with newResults (both are IdMaps), invoking observe\n  // callbacks on the multiplexer.\n  // Replace self._unpublishedBuffer with newBuffer.\n  //\n  // XXX This is very similar to LocalCollection._diffQueryUnorderedChanges. We\n  // should really: (a) Unify IdMap and OrderedDict into Unordered/OrderedDict\n  // (b) Rewrite diff.js to use these classes instead of arrays and objects.\n  _publishNewResults: function () {\n    function _publishNewResults(newResults, newBuffer) {\n      var self = this;\n      Meteor._noYieldsAllowed(function () {\n\n        // If the query is limited and there is a buffer, shut down so it doesn't\n        // stay in a way.\n        if (self._limit) {\n          self._unpublishedBuffer.clear();\n        }\n\n        // First remove anything that's gone. Be careful not to modify\n        // self._published while iterating over it.\n        var idsToRemove = [];\n        self._published.forEach(function (doc, id) {\n          if (!newResults.has(id)) idsToRemove.push(id);\n        });\n        _.each(idsToRemove, function (id) {\n          self._removePublished(id);\n        });\n\n        // Now do adds and changes.\n        // If self has a buffer and limit, the new fetched result will be\n        // limited correctly as the query has sort specifier.\n        newResults.forEach(function (doc, id) {\n          self._handleDoc(id, doc);\n        });\n\n        // Sanity-check that everything we tried to put into _published ended up\n        // there.\n        // XXX if this is slow, remove it later\n        if (self._published.size() !== newResults.size()) {\n          throw Error(\"The Mongo server and the Meteor query disagree on how \" + \"many documents match your query. Maybe it is hitting a Mongo \" + \"edge case? The query is: \" + EJSON.stringify(self._cursorDescription.selector));\n        }\n        self._published.forEach(function (doc, id) {\n          if (!newResults.has(id)) throw Error(\"_published has a doc that newResults doesn't; \" + id);\n        });\n\n        // Finally, replace the buffer\n        newBuffer.forEach(function (doc, id) {\n          self._addBuffered(id, doc);\n        });\n\n        self._safeAppendToBuffer = newBuffer.size() < self._limit;\n      });\n    }\n\n    return _publishNewResults;\n  }(),\n\n  // This stop function is invoked from the onStop of the ObserveMultiplexer, so\n  // it shouldn't actually be possible to call it until the multiplexer is\n  // ready.\n  //\n  // It's important to check self._stopped after every call in this file that\n  // can yield!\n  stop: function () {\n    function stop() {\n      var self = this;\n      if (self._stopped) return;\n      self._stopped = true;\n      _.each(self._stopHandles, function (handle) {\n        handle.stop();\n      });\n\n      // Note: we *don't* use multiplexer.onFlush here because this stop\n      // callback is actually invoked by the multiplexer itself when it has\n      // determined that there are no handles left. So nothing is actually going\n      // to get flushed (and it's probably not valid to call methods on the\n      // dying multiplexer).\n      _.each(self._writesToCommitWhenWeReachSteady, function (w) {\n        w.committed(); // maybe yields?\n      });\n      self._writesToCommitWhenWeReachSteady = null;\n\n      // Proactively drop references to potentially big things.\n      self._published = null;\n      self._unpublishedBuffer = null;\n      self._needToFetch = null;\n      self._currentlyFetching = null;\n      self._oplogEntryHandle = null;\n      self._listenersHandle = null;\n\n      Package.facts && Package.facts.Facts.incrementServerFact(\"mongo-livedata\", \"observe-drivers-oplog\", -1);\n    }\n\n    return stop;\n  }(),\n\n  _registerPhaseChange: function () {\n    function _registerPhaseChange(phase) {\n      var self = this;\n      Meteor._noYieldsAllowed(function () {\n        var now = new Date();\n\n        if (self._phase) {\n          var timeDiff = now - self._phaseStartTime;\n          Package.facts && Package.facts.Facts.incrementServerFact(\"mongo-livedata\", \"time-spent-in-\" + self._phase + \"-phase\", timeDiff);\n        }\n\n        self._phase = phase;\n        self._phaseStartTime = now;\n      });\n    }\n\n    return _registerPhaseChange;\n  }()\n});\n\n// Does our oplog tailing code support this cursor? For now, we are being very\n// conservative and allowing only simple queries with simple options.\n// (This is a \"static method\".)\nOplogObserveDriver.cursorSupported = function (cursorDescription, matcher) {\n  // First, check the options.\n  var options = cursorDescription.options;\n\n  // Did the user say no explicitly?\n  // underscored version of the option is COMPAT with 1.2\n  if (options.disableOplog || options._disableOplog) return false;\n\n  // skip is not supported: to support it we would need to keep track of all\n  // \"skipped\" documents or at least their ids.\n  // limit w/o a sort specifier is not supported: current implementation needs a\n  // deterministic way to order documents.\n  if (options.skip || options.limit && !options.sort) return false;\n\n  // If a fields projection option is given check if it is supported by\n  // minimongo (some operators are not supported).\n  if (options.fields) {\n    try {\n      LocalCollection._checkSupportedProjection(options.fields);\n    } catch (e) {\n      if (e.name === \"MinimongoError\") return false;else throw e;\n    }\n  }\n\n  // We don't allow the following selectors:\n  //   - $where (not confident that we provide the same JS environment\n  //             as Mongo, and can yield!)\n  //   - $near (has \"interesting\" properties in MongoDB, like the possibility\n  //            of returning an ID multiple times, though even polling maybe\n  //            have a bug there)\n  //           XXX: once we support it, we would need to think more on how we\n  //           initialize the comparators when we create the driver.\n  return !matcher.hasWhere() && !matcher.hasGeoQuery();\n};\n\nvar modifierCanBeDirectlyApplied = function modifierCanBeDirectlyApplied(modifier) {\n  return _.all(modifier, function (fields, operation) {\n    return _.all(fields, function (value, field) {\n      return !/EJSON\\$/.test(field);\n    });\n  });\n};\n\nMongoInternals.OplogObserveDriver = OplogObserveDriver;","ast":null,"map":{"version":3,"sources":["/packages/mongo/oplog_observe_driver.js"],"names":[],"mappings":"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","file":"/packages/mongo/oplog_observe_driver.js.map","sourcesContent":["var Fiber = Npm.require('fibers');\nvar Future = Npm.require('fibers/future');\n\nvar PHASE = {\n  QUERYING: \"QUERYING\",\n  FETCHING: \"FETCHING\",\n  STEADY: \"STEADY\"\n};\n\n// Exception thrown by _needToPollQuery which unrolls the stack up to the\n// enclosing call to finishIfNeedToPollQuery.\nvar SwitchedToQuery = function () {};\nvar finishIfNeedToPollQuery = function (f) {\n  return function () {\n    try {\n      f.apply(this, arguments);\n    } catch (e) {\n      if (!(e instanceof SwitchedToQuery))\n        throw e;\n    }\n  };\n};\n\nvar currentId = 0;\n\n// OplogObserveDriver is an alternative to PollingObserveDriver which follows\n// the Mongo operation log instead of just re-polling the query. It obeys the\n// same simple interface: constructing it starts sending observeChanges\n// callbacks (and a ready() invocation) to the ObserveMultiplexer, and you stop\n// it by calling the stop() method.\nOplogObserveDriver = function (options) {\n  var self = this;\n  self._usesOplog = true;  // tests look at this\n\n  self._id = currentId;\n  currentId++;\n\n  self._cursorDescription = options.cursorDescription;\n  self._mongoHandle = options.mongoHandle;\n  self._multiplexer = options.multiplexer;\n\n  if (options.ordered) {\n    throw Error(\"OplogObserveDriver only supports unordered observeChanges\");\n  }\n\n  var sorter = options.sorter;\n  // We don't support $near and other geo-queries so it's OK to initialize the\n  // comparator only once in the constructor.\n  var comparator = sorter && sorter.getComparator();\n\n  if (options.cursorDescription.options.limit) {\n    // There are several properties ordered driver implements:\n    // - _limit is a positive number\n    // - _comparator is a function-comparator by which the query is ordered\n    // - _unpublishedBuffer is non-null Min/Max Heap,\n    //                      the empty buffer in STEADY phase implies that the\n    //                      everything that matches the queries selector fits\n    //                      into published set.\n    // - _published - Min Heap (also implements IdMap methods)\n\n    var heapOptions = { IdMap: LocalCollection._IdMap };\n    self._limit = self._cursorDescription.options.limit;\n    self._comparator = comparator;\n    self._sorter = sorter;\n    self._unpublishedBuffer = new MinMaxHeap(comparator, heapOptions);\n    // We need something that can find Max value in addition to IdMap interface\n    self._published = new MaxHeap(comparator, heapOptions);\n  } else {\n    self._limit = 0;\n    self._comparator = null;\n    self._sorter = null;\n    self._unpublishedBuffer = null;\n    self._published = new LocalCollection._IdMap;\n  }\n\n  // Indicates if it is safe to insert a new document at the end of the buffer\n  // for this query. i.e. it is known that there are no documents matching the\n  // selector those are not in published or buffer.\n  self._safeAppendToBuffer = false;\n\n  self._stopped = false;\n  self._stopHandles = [];\n\n  Package.facts && Package.facts.Facts.incrementServerFact(\n    \"mongo-livedata\", \"observe-drivers-oplog\", 1);\n\n  self._registerPhaseChange(PHASE.QUERYING);\n\n  var selector = self._cursorDescription.selector;\n  self._matcher = options.matcher;\n  var projection = self._cursorDescription.options.fields || {};\n  self._projectionFn = LocalCollection._compileProjection(projection);\n  // Projection function, result of combining important fields for selector and\n  // existing fields projection\n  self._sharedProjection = self._matcher.combineIntoProjection(projection);\n  if (sorter)\n    self._sharedProjection = sorter.combineIntoProjection(self._sharedProjection);\n  self._sharedProjectionFn = LocalCollection._compileProjection(\n    self._sharedProjection);\n\n  self._needToFetch = new LocalCollection._IdMap;\n  self._currentlyFetching = null;\n  self._fetchGeneration = 0;\n\n  self._requeryWhenDoneThisQuery = false;\n  self._writesToCommitWhenWeReachSteady = [];\n\n  // If the oplog handle tells us that it skipped some entries (because it got\n  // behind, say), re-poll.\n  self._stopHandles.push(self._mongoHandle._oplogHandle.onSkippedEntries(\n    finishIfNeedToPollQuery(function () {\n      self._needToPollQuery();\n    })\n  ));\n\n  forEachTrigger(self._cursorDescription, function (trigger) {\n    self._stopHandles.push(self._mongoHandle._oplogHandle.onOplogEntry(\n      trigger, function (notification) {\n        Meteor._noYieldsAllowed(finishIfNeedToPollQuery(function () {\n          var op = notification.op;\n          if (notification.dropCollection || notification.dropDatabase) {\n            // Note: this call is not allowed to block on anything (especially\n            // on waiting for oplog entries to catch up) because that will block\n            // onOplogEntry!\n            self._needToPollQuery();\n          } else {\n            // All other operators should be handled depending on phase\n            if (self._phase === PHASE.QUERYING)\n              self._handleOplogEntryQuerying(op);\n            else\n              self._handleOplogEntrySteadyOrFetching(op);\n          }\n        }));\n      }\n    ));\n  });\n\n  // XXX ordering w.r.t. everything else?\n  self._stopHandles.push(listenAll(\n    self._cursorDescription, function (notification) {\n      // If we're not in a pre-fire write fence, we don't have to do anything.\n      var fence = DDPServer._CurrentWriteFence.get();\n      if (!fence || fence.fired)\n        return;\n\n      if (fence._oplogObserveDrivers) {\n        fence._oplogObserveDrivers[self._id] = self;\n        return;\n      }\n\n      fence._oplogObserveDrivers = {};\n      fence._oplogObserveDrivers[self._id] = self;\n\n      fence.onBeforeFire(function () {\n        var drivers = fence._oplogObserveDrivers;\n        delete fence._oplogObserveDrivers;\n\n        // This fence cannot fire until we've caught up to \"this point\" in the\n        // oplog, and all observers made it back to the steady state.\n        self._mongoHandle._oplogHandle.waitUntilCaughtUp();\n\n        _.each(drivers, function (driver) {\n          if (driver._stopped)\n            return;\n\n          var write = fence.beginWrite();\n          if (driver._phase === PHASE.STEADY) {\n            // Make sure that all of the callbacks have made it through the\n            // multiplexer and been delivered to ObserveHandles before committing\n            // writes.\n            driver._multiplexer.onFlush(function () {\n              write.committed();\n            });\n          } else {\n            driver._writesToCommitWhenWeReachSteady.push(write);\n          }\n        });\n      });\n    }\n  ));\n\n  // When Mongo fails over, we need to repoll the query, in case we processed an\n  // oplog entry that got rolled back.\n  self._stopHandles.push(self._mongoHandle._onFailover(finishIfNeedToPollQuery(\n    function () {\n      self._needToPollQuery();\n    })));\n\n  // Give _observeChanges a chance to add the new ObserveHandle to our\n  // multiplexer, so that the added calls get streamed.\n  Meteor.defer(finishIfNeedToPollQuery(function () {\n    self._runInitialQuery();\n  }));\n};\n\n_.extend(OplogObserveDriver.prototype, {\n  _addPublished: function (id, doc) {\n    var self = this;\n    Meteor._noYieldsAllowed(function () {\n      var fields = _.clone(doc);\n      delete fields._id;\n      self._published.set(id, self._sharedProjectionFn(doc));\n      self._multiplexer.added(id, self._projectionFn(fields));\n\n      // After adding this document, the published set might be overflowed\n      // (exceeding capacity specified by limit). If so, push the maximum\n      // element to the buffer, we might want to save it in memory to reduce the\n      // amount of Mongo lookups in the future.\n      if (self._limit && self._published.size() > self._limit) {\n        // XXX in theory the size of published is no more than limit+1\n        if (self._published.size() !== self._limit + 1) {\n          throw new Error(\"After adding to published, \" +\n                          (self._published.size() - self._limit) +\n                          \" documents are overflowing the set\");\n        }\n\n        var overflowingDocId = self._published.maxElementId();\n        var overflowingDoc = self._published.get(overflowingDocId);\n\n        if (EJSON.equals(overflowingDocId, id)) {\n          throw new Error(\"The document just added is overflowing the published set\");\n        }\n\n        self._published.remove(overflowingDocId);\n        self._multiplexer.removed(overflowingDocId);\n        self._addBuffered(overflowingDocId, overflowingDoc);\n      }\n    });\n  },\n  _removePublished: function (id) {\n    var self = this;\n    Meteor._noYieldsAllowed(function () {\n      self._published.remove(id);\n      self._multiplexer.removed(id);\n      if (! self._limit || self._published.size() === self._limit)\n        return;\n\n      if (self._published.size() > self._limit)\n        throw Error(\"self._published got too big\");\n\n      // OK, we are publishing less than the limit. Maybe we should look in the\n      // buffer to find the next element past what we were publishing before.\n\n      if (!self._unpublishedBuffer.empty()) {\n        // There's something in the buffer; move the first thing in it to\n        // _published.\n        var newDocId = self._unpublishedBuffer.minElementId();\n        var newDoc = self._unpublishedBuffer.get(newDocId);\n        self._removeBuffered(newDocId);\n        self._addPublished(newDocId, newDoc);\n        return;\n      }\n\n      // There's nothing in the buffer.  This could mean one of a few things.\n\n      // (a) We could be in the middle of re-running the query (specifically, we\n      // could be in _publishNewResults). In that case, _unpublishedBuffer is\n      // empty because we clear it at the beginning of _publishNewResults. In\n      // this case, our caller already knows the entire answer to the query and\n      // we don't need to do anything fancy here.  Just return.\n      if (self._phase === PHASE.QUERYING)\n        return;\n\n      // (b) We're pretty confident that the union of _published and\n      // _unpublishedBuffer contain all documents that match selector. Because\n      // _unpublishedBuffer is empty, that means we're confident that _published\n      // contains all documents that match selector. So we have nothing to do.\n      if (self._safeAppendToBuffer)\n        return;\n\n      // (c) Maybe there are other documents out there that should be in our\n      // buffer. But in that case, when we emptied _unpublishedBuffer in\n      // _removeBuffered, we should have called _needToPollQuery, which will\n      // either put something in _unpublishedBuffer or set _safeAppendToBuffer\n      // (or both), and it will put us in QUERYING for that whole time. So in\n      // fact, we shouldn't be able to get here.\n\n      throw new Error(\"Buffer inexplicably empty\");\n    });\n  },\n  _changePublished: function (id, oldDoc, newDoc) {\n    var self = this;\n    Meteor._noYieldsAllowed(function () {\n      self._published.set(id, self._sharedProjectionFn(newDoc));\n      var projectedNew = self._projectionFn(newDoc);\n      var projectedOld = self._projectionFn(oldDoc);\n      var changed = DiffSequence.makeChangedFields(\n        projectedNew, projectedOld);\n      if (!_.isEmpty(changed))\n        self._multiplexer.changed(id, changed);\n    });\n  },\n  _addBuffered: function (id, doc) {\n    var self = this;\n    Meteor._noYieldsAllowed(function () {\n      self._unpublishedBuffer.set(id, self._sharedProjectionFn(doc));\n\n      // If something is overflowing the buffer, we just remove it from cache\n      if (self._unpublishedBuffer.size() > self._limit) {\n        var maxBufferedId = self._unpublishedBuffer.maxElementId();\n\n        self._unpublishedBuffer.remove(maxBufferedId);\n\n        // Since something matching is removed from cache (both published set and\n        // buffer), set flag to false\n        self._safeAppendToBuffer = false;\n      }\n    });\n  },\n  // Is called either to remove the doc completely from matching set or to move\n  // it to the published set later.\n  _removeBuffered: function (id) {\n    var self = this;\n    Meteor._noYieldsAllowed(function () {\n      self._unpublishedBuffer.remove(id);\n      // To keep the contract \"buffer is never empty in STEADY phase unless the\n      // everything matching fits into published\" true, we poll everything as\n      // soon as we see the buffer becoming empty.\n      if (! self._unpublishedBuffer.size() && ! self._safeAppendToBuffer)\n        self._needToPollQuery();\n    });\n  },\n  // Called when a document has joined the \"Matching\" results set.\n  // Takes responsibility of keeping _unpublishedBuffer in sync with _published\n  // and the effect of limit enforced.\n  _addMatching: function (doc) {\n    var self = this;\n    Meteor._noYieldsAllowed(function () {\n      var id = doc._id;\n      if (self._published.has(id))\n        throw Error(\"tried to add something already published \" + id);\n      if (self._limit && self._unpublishedBuffer.has(id))\n        throw Error(\"tried to add something already existed in buffer \" + id);\n\n      var limit = self._limit;\n      var comparator = self._comparator;\n      var maxPublished = (limit && self._published.size() > 0) ?\n        self._published.get(self._published.maxElementId()) : null;\n      var maxBuffered = (limit && self._unpublishedBuffer.size() > 0)\n        ? self._unpublishedBuffer.get(self._unpublishedBuffer.maxElementId())\n        : null;\n      // The query is unlimited or didn't publish enough documents yet or the\n      // new document would fit into published set pushing the maximum element\n      // out, then we need to publish the doc.\n      var toPublish = ! limit || self._published.size() < limit ||\n        comparator(doc, maxPublished) < 0;\n\n      // Otherwise we might need to buffer it (only in case of limited query).\n      // Buffering is allowed if the buffer is not filled up yet and all\n      // matching docs are either in the published set or in the buffer.\n      var canAppendToBuffer = !toPublish && self._safeAppendToBuffer &&\n        self._unpublishedBuffer.size() < limit;\n\n      // Or if it is small enough to be safely inserted to the middle or the\n      // beginning of the buffer.\n      var canInsertIntoBuffer = !toPublish && maxBuffered &&\n        comparator(doc, maxBuffered) <= 0;\n\n      var toBuffer = canAppendToBuffer || canInsertIntoBuffer;\n\n      if (toPublish) {\n        self._addPublished(id, doc);\n      } else if (toBuffer) {\n        self._addBuffered(id, doc);\n      } else {\n        // dropping it and not saving to the cache\n        self._safeAppendToBuffer = false;\n      }\n    });\n  },\n  // Called when a document leaves the \"Matching\" results set.\n  // Takes responsibility of keeping _unpublishedBuffer in sync with _published\n  // and the effect of limit enforced.\n  _removeMatching: function (id) {\n    var self = this;\n    Meteor._noYieldsAllowed(function () {\n      if (! self._published.has(id) && ! self._limit)\n        throw Error(\"tried to remove something matching but not cached \" + id);\n\n      if (self._published.has(id)) {\n        self._removePublished(id);\n      } else if (self._unpublishedBuffer.has(id)) {\n        self._removeBuffered(id);\n      }\n    });\n  },\n  _handleDoc: function (id, newDoc) {\n    var self = this;\n    Meteor._noYieldsAllowed(function () {\n      var matchesNow = newDoc && self._matcher.documentMatches(newDoc).result;\n\n      var publishedBefore = self._published.has(id);\n      var bufferedBefore = self._limit && self._unpublishedBuffer.has(id);\n      var cachedBefore = publishedBefore || bufferedBefore;\n\n      if (matchesNow && !cachedBefore) {\n        self._addMatching(newDoc);\n      } else if (cachedBefore && !matchesNow) {\n        self._removeMatching(id);\n      } else if (cachedBefore && matchesNow) {\n        var oldDoc = self._published.get(id);\n        var comparator = self._comparator;\n        var minBuffered = self._limit && self._unpublishedBuffer.size() &&\n          self._unpublishedBuffer.get(self._unpublishedBuffer.minElementId());\n\n        if (publishedBefore) {\n          // Unlimited case where the document stays in published once it\n          // matches or the case when we don't have enough matching docs to\n          // publish or the changed but matching doc will stay in published\n          // anyways.\n          //\n          // XXX: We rely on the emptiness of buffer. Be sure to maintain the\n          // fact that buffer can't be empty if there are matching documents not\n          // published. Notably, we don't want to schedule repoll and continue\n          // relying on this property.\n          var staysInPublished = ! self._limit ||\n            self._unpublishedBuffer.size() === 0 ||\n            comparator(newDoc, minBuffered) <= 0;\n\n          if (staysInPublished) {\n            self._changePublished(id, oldDoc, newDoc);\n          } else {\n            // after the change doc doesn't stay in the published, remove it\n            self._removePublished(id);\n            // but it can move into buffered now, check it\n            var maxBuffered = self._unpublishedBuffer.get(\n              self._unpublishedBuffer.maxElementId());\n\n            var toBuffer = self._safeAppendToBuffer ||\n                  (maxBuffered && comparator(newDoc, maxBuffered) <= 0);\n\n            if (toBuffer) {\n              self._addBuffered(id, newDoc);\n            } else {\n              // Throw away from both published set and buffer\n              self._safeAppendToBuffer = false;\n            }\n          }\n        } else if (bufferedBefore) {\n          oldDoc = self._unpublishedBuffer.get(id);\n          // remove the old version manually instead of using _removeBuffered so\n          // we don't trigger the querying immediately.  if we end this block\n          // with the buffer empty, we will need to trigger the query poll\n          // manually too.\n          self._unpublishedBuffer.remove(id);\n\n          var maxPublished = self._published.get(\n            self._published.maxElementId());\n          var maxBuffered = self._unpublishedBuffer.size() &&\n                self._unpublishedBuffer.get(\n                  self._unpublishedBuffer.maxElementId());\n\n          // the buffered doc was updated, it could move to published\n          var toPublish = comparator(newDoc, maxPublished) < 0;\n\n          // or stays in buffer even after the change\n          var staysInBuffer = (! toPublish && self._safeAppendToBuffer) ||\n                (!toPublish && maxBuffered &&\n                 comparator(newDoc, maxBuffered) <= 0);\n\n          if (toPublish) {\n            self._addPublished(id, newDoc);\n          } else if (staysInBuffer) {\n            // stays in buffer but changes\n            self._unpublishedBuffer.set(id, newDoc);\n          } else {\n            // Throw away from both published set and buffer\n            self._safeAppendToBuffer = false;\n            // Normally this check would have been done in _removeBuffered but\n            // we didn't use it, so we need to do it ourself now.\n            if (! self._unpublishedBuffer.size()) {\n              self._needToPollQuery();\n            }\n          }\n        } else {\n          throw new Error(\"cachedBefore implies either of publishedBefore or bufferedBefore is true.\");\n        }\n      }\n    });\n  },\n  _fetchModifiedDocuments: function () {\n    var self = this;\n    Meteor._noYieldsAllowed(function () {\n      self._registerPhaseChange(PHASE.FETCHING);\n      // Defer, because nothing called from the oplog entry handler may yield,\n      // but fetch() yields.\n      Meteor.defer(finishIfNeedToPollQuery(function () {\n        while (!self._stopped && !self._needToFetch.empty()) {\n          if (self._phase === PHASE.QUERYING) {\n            // While fetching, we decided to go into QUERYING mode, and then we\n            // saw another oplog entry, so _needToFetch is not empty. But we\n            // shouldn't fetch these documents until AFTER the query is done.\n            break;\n          }\n\n          // Being in steady phase here would be surprising.\n          if (self._phase !== PHASE.FETCHING)\n            throw new Error(\"phase in fetchModifiedDocuments: \" + self._phase);\n\n          self._currentlyFetching = self._needToFetch;\n          var thisGeneration = ++self._fetchGeneration;\n          self._needToFetch = new LocalCollection._IdMap;\n          var waiting = 0;\n          var fut = new Future;\n          // This loop is safe, because _currentlyFetching will not be updated\n          // during this loop (in fact, it is never mutated).\n          self._currentlyFetching.forEach(function (cacheKey, id) {\n            waiting++;\n            self._mongoHandle._docFetcher.fetch(\n              self._cursorDescription.collectionName, id, cacheKey,\n              finishIfNeedToPollQuery(function (err, doc) {\n                try {\n                  if (err) {\n                    Meteor._debug(\"Got exception while fetching documents: \" +\n                                  err);\n                    // If we get an error from the fetcher (eg, trouble\n                    // connecting to Mongo), let's just abandon the fetch phase\n                    // altogether and fall back to polling. It's not like we're\n                    // getting live updates anyway.\n                    if (self._phase !== PHASE.QUERYING) {\n                      self._needToPollQuery();\n                    }\n                  } else if (!self._stopped && self._phase === PHASE.FETCHING\n                             && self._fetchGeneration === thisGeneration) {\n                    // We re-check the generation in case we've had an explicit\n                    // _pollQuery call (eg, in another fiber) which should\n                    // effectively cancel this round of fetches.  (_pollQuery\n                    // increments the generation.)\n                    self._handleDoc(id, doc);\n                  }\n                } finally {\n                  waiting--;\n                  // Because fetch() never calls its callback synchronously,\n                  // this is safe (ie, we won't call fut.return() before the\n                  // forEach is done).\n                  if (waiting === 0)\n                    fut.return();\n                }\n              }));\n          });\n          fut.wait();\n          // Exit now if we've had a _pollQuery call (here or in another fiber).\n          if (self._phase === PHASE.QUERYING)\n            return;\n          self._currentlyFetching = null;\n        }\n        // We're done fetching, so we can be steady, unless we've had a\n        // _pollQuery call (here or in another fiber).\n        if (self._phase !== PHASE.QUERYING)\n          self._beSteady();\n      }));\n    });\n  },\n  _beSteady: function () {\n    var self = this;\n    Meteor._noYieldsAllowed(function () {\n      self._registerPhaseChange(PHASE.STEADY);\n      var writes = self._writesToCommitWhenWeReachSteady;\n      self._writesToCommitWhenWeReachSteady = [];\n      self._multiplexer.onFlush(function () {\n        _.each(writes, function (w) {\n          w.committed();\n        });\n      });\n    });\n  },\n  _handleOplogEntryQuerying: function (op) {\n    var self = this;\n    Meteor._noYieldsAllowed(function () {\n      self._needToFetch.set(idForOp(op), op.ts.toString());\n    });\n  },\n  _handleOplogEntrySteadyOrFetching: function (op) {\n    var self = this;\n    Meteor._noYieldsAllowed(function () {\n      var id = idForOp(op);\n      // If we're already fetching this one, or about to, we can't optimize;\n      // make sure that we fetch it again if necessary.\n      if (self._phase === PHASE.FETCHING &&\n          ((self._currentlyFetching && self._currentlyFetching.has(id)) ||\n           self._needToFetch.has(id))) {\n        self._needToFetch.set(id, op.ts.toString());\n        return;\n      }\n\n      if (op.op === 'd') {\n        if (self._published.has(id) ||\n            (self._limit && self._unpublishedBuffer.has(id)))\n          self._removeMatching(id);\n      } else if (op.op === 'i') {\n        if (self._published.has(id))\n          throw new Error(\"insert found for already-existing ID in published\");\n        if (self._unpublishedBuffer && self._unpublishedBuffer.has(id))\n          throw new Error(\"insert found for already-existing ID in buffer\");\n\n        // XXX what if selector yields?  for now it can't but later it could\n        // have $where\n        if (self._matcher.documentMatches(op.o).result)\n          self._addMatching(op.o);\n      } else if (op.op === 'u') {\n        // Is this a modifier ($set/$unset, which may require us to poll the\n        // database to figure out if the whole document matches the selector) or\n        // a replacement (in which case we can just directly re-evaluate the\n        // selector)?\n        var isReplace = !_.has(op.o, '$set') && !_.has(op.o, '$unset');\n        // If this modifier modifies something inside an EJSON custom type (ie,\n        // anything with EJSON$), then we can't try to use\n        // LocalCollection._modify, since that just mutates the EJSON encoding,\n        // not the actual object.\n        var canDirectlyModifyDoc =\n          !isReplace && modifierCanBeDirectlyApplied(op.o);\n\n        var publishedBefore = self._published.has(id);\n        var bufferedBefore = self._limit && self._unpublishedBuffer.has(id);\n\n        if (isReplace) {\n          self._handleDoc(id, _.extend({_id: id}, op.o));\n        } else if ((publishedBefore || bufferedBefore) &&\n                   canDirectlyModifyDoc) {\n          // Oh great, we actually know what the document is, so we can apply\n          // this directly.\n          var newDoc = self._published.has(id)\n            ? self._published.get(id) : self._unpublishedBuffer.get(id);\n          newDoc = EJSON.clone(newDoc);\n\n          newDoc._id = id;\n          try {\n            LocalCollection._modify(newDoc, op.o);\n          } catch (e) {\n            if (e.name !== \"MinimongoError\")\n              throw e;\n            // We didn't understand the modifier.  Re-fetch.\n            self._needToFetch.set(id, op.ts.toString());\n            if (self._phase === PHASE.STEADY) {\n              self._fetchModifiedDocuments();\n            }\n            return;\n          }\n          self._handleDoc(id, self._sharedProjectionFn(newDoc));\n        } else if (!canDirectlyModifyDoc ||\n                   self._matcher.canBecomeTrueByModifier(op.o) ||\n                   (self._sorter && self._sorter.affectedByModifier(op.o))) {\n          self._needToFetch.set(id, op.ts.toString());\n          if (self._phase === PHASE.STEADY)\n            self._fetchModifiedDocuments();\n        }\n      } else {\n        throw Error(\"XXX SURPRISING OPERATION: \" + op);\n      }\n    });\n  },\n  // Yields!\n  _runInitialQuery: function () {\n    var self = this;\n    if (self._stopped)\n      throw new Error(\"oplog stopped surprisingly early\");\n\n    self._runQuery({initial: true});  // yields\n\n    if (self._stopped)\n      return;  // can happen on queryError\n\n    // Allow observeChanges calls to return. (After this, it's possible for\n    // stop() to be called.)\n    self._multiplexer.ready();\n\n    self._doneQuerying();  // yields\n  },\n\n  // In various circumstances, we may just want to stop processing the oplog and\n  // re-run the initial query, just as if we were a PollingObserveDriver.\n  //\n  // This function may not block, because it is called from an oplog entry\n  // handler.\n  //\n  // XXX We should call this when we detect that we've been in FETCHING for \"too\n  // long\".\n  //\n  // XXX We should call this when we detect Mongo failover (since that might\n  // mean that some of the oplog entries we have processed have been rolled\n  // back). The Node Mongo driver is in the middle of a bunch of huge\n  // refactorings, including the way that it notifies you when primary\n  // changes. Will put off implementing this until driver 1.4 is out.\n  _pollQuery: function () {\n    var self = this;\n    Meteor._noYieldsAllowed(function () {\n      if (self._stopped)\n        return;\n\n      // Yay, we get to forget about all the things we thought we had to fetch.\n      self._needToFetch = new LocalCollection._IdMap;\n      self._currentlyFetching = null;\n      ++self._fetchGeneration;  // ignore any in-flight fetches\n      self._registerPhaseChange(PHASE.QUERYING);\n\n      // Defer so that we don't yield.  We don't need finishIfNeedToPollQuery\n      // here because SwitchedToQuery is not thrown in QUERYING mode.\n      Meteor.defer(function () {\n        self._runQuery();\n        self._doneQuerying();\n      });\n    });\n  },\n\n  // Yields!\n  _runQuery: function (options) {\n    var self = this;\n    options = options || {};\n    var newResults, newBuffer;\n\n    // This while loop is just to retry failures.\n    while (true) {\n      // If we've been stopped, we don't have to run anything any more.\n      if (self._stopped)\n        return;\n\n      newResults = new LocalCollection._IdMap;\n      newBuffer = new LocalCollection._IdMap;\n\n      // Query 2x documents as the half excluded from the original query will go\n      // into unpublished buffer to reduce additional Mongo lookups in cases\n      // when documents are removed from the published set and need a\n      // replacement.\n      // XXX needs more thought on non-zero skip\n      // XXX 2 is a \"magic number\" meaning there is an extra chunk of docs for\n      // buffer if such is needed.\n      var cursor = self._cursorForQuery({ limit: self._limit * 2 });\n      try {\n        cursor.forEach(function (doc, i) {  // yields\n          if (!self._limit || i < self._limit)\n            newResults.set(doc._id, doc);\n          else\n            newBuffer.set(doc._id, doc);\n        });\n        break;\n      } catch (e) {\n        if (options.initial && typeof(e.code) === 'number') {\n          // This is an error document sent to us by mongod, not a connection\n          // error generated by the client. And we've never seen this query work\n          // successfully. Probably it's a bad selector or something, so we\n          // should NOT retry. Instead, we should halt the observe (which ends\n          // up calling `stop` on us).\n          self._multiplexer.queryError(e);\n          return;\n        }\n\n        // During failover (eg) if we get an exception we should log and retry\n        // instead of crashing.\n        Meteor._debug(\"Got exception while polling query: \" + e);\n        Meteor._sleepForMs(100);\n      }\n    }\n\n    if (self._stopped)\n      return;\n\n    self._publishNewResults(newResults, newBuffer);\n  },\n\n  // Transitions to QUERYING and runs another query, or (if already in QUERYING)\n  // ensures that we will query again later.\n  //\n  // This function may not block, because it is called from an oplog entry\n  // handler. However, if we were not already in the QUERYING phase, it throws\n  // an exception that is caught by the closest surrounding\n  // finishIfNeedToPollQuery call; this ensures that we don't continue running\n  // close that was designed for another phase inside PHASE.QUERYING.\n  //\n  // (It's also necessary whenever logic in this file yields to check that other\n  // phases haven't put us into QUERYING mode, though; eg,\n  // _fetchModifiedDocuments does this.)\n  _needToPollQuery: function () {\n    var self = this;\n    Meteor._noYieldsAllowed(function () {\n      if (self._stopped)\n        return;\n\n      // If we're not already in the middle of a query, we can query now\n      // (possibly pausing FETCHING).\n      if (self._phase !== PHASE.QUERYING) {\n        self._pollQuery();\n        throw new SwitchedToQuery;\n      }\n\n      // We're currently in QUERYING. Set a flag to ensure that we run another\n      // query when we're done.\n      self._requeryWhenDoneThisQuery = true;\n    });\n  },\n\n  // Yields!\n  _doneQuerying: function () {\n    var self = this;\n\n    if (self._stopped)\n      return;\n    self._mongoHandle._oplogHandle.waitUntilCaughtUp();  // yields\n    if (self._stopped)\n      return;\n    if (self._phase !== PHASE.QUERYING)\n      throw Error(\"Phase unexpectedly \" + self._phase);\n\n    Meteor._noYieldsAllowed(function () {\n      if (self._requeryWhenDoneThisQuery) {\n        self._requeryWhenDoneThisQuery = false;\n        self._pollQuery();\n      } else if (self._needToFetch.empty()) {\n        self._beSteady();\n      } else {\n        self._fetchModifiedDocuments();\n      }\n    });\n  },\n\n  _cursorForQuery: function (optionsOverwrite) {\n    var self = this;\n    return Meteor._noYieldsAllowed(function () {\n      // The query we run is almost the same as the cursor we are observing,\n      // with a few changes. We need to read all the fields that are relevant to\n      // the selector, not just the fields we are going to publish (that's the\n      // \"shared\" projection). And we don't want to apply any transform in the\n      // cursor, because observeChanges shouldn't use the transform.\n      var options = _.clone(self._cursorDescription.options);\n\n      // Allow the caller to modify the options. Useful to specify different\n      // skip and limit values.\n      _.extend(options, optionsOverwrite);\n\n      options.fields = self._sharedProjection;\n      delete options.transform;\n      // We are NOT deep cloning fields or selector here, which should be OK.\n      var description = new CursorDescription(\n        self._cursorDescription.collectionName,\n        self._cursorDescription.selector,\n        options);\n      return new Cursor(self._mongoHandle, description);\n    });\n  },\n\n\n  // Replace self._published with newResults (both are IdMaps), invoking observe\n  // callbacks on the multiplexer.\n  // Replace self._unpublishedBuffer with newBuffer.\n  //\n  // XXX This is very similar to LocalCollection._diffQueryUnorderedChanges. We\n  // should really: (a) Unify IdMap and OrderedDict into Unordered/OrderedDict\n  // (b) Rewrite diff.js to use these classes instead of arrays and objects.\n  _publishNewResults: function (newResults, newBuffer) {\n    var self = this;\n    Meteor._noYieldsAllowed(function () {\n\n      // If the query is limited and there is a buffer, shut down so it doesn't\n      // stay in a way.\n      if (self._limit) {\n        self._unpublishedBuffer.clear();\n      }\n\n      // First remove anything that's gone. Be careful not to modify\n      // self._published while iterating over it.\n      var idsToRemove = [];\n      self._published.forEach(function (doc, id) {\n        if (!newResults.has(id))\n          idsToRemove.push(id);\n      });\n      _.each(idsToRemove, function (id) {\n        self._removePublished(id);\n      });\n\n      // Now do adds and changes.\n      // If self has a buffer and limit, the new fetched result will be\n      // limited correctly as the query has sort specifier.\n      newResults.forEach(function (doc, id) {\n        self._handleDoc(id, doc);\n      });\n\n      // Sanity-check that everything we tried to put into _published ended up\n      // there.\n      // XXX if this is slow, remove it later\n      if (self._published.size() !== newResults.size()) {\n        throw Error(\n          \"The Mongo server and the Meteor query disagree on how \" +\n            \"many documents match your query. Maybe it is hitting a Mongo \" +\n            \"edge case? The query is: \" +\n            EJSON.stringify(self._cursorDescription.selector));\n      }\n      self._published.forEach(function (doc, id) {\n        if (!newResults.has(id))\n          throw Error(\"_published has a doc that newResults doesn't; \" + id);\n      });\n\n      // Finally, replace the buffer\n      newBuffer.forEach(function (doc, id) {\n        self._addBuffered(id, doc);\n      });\n\n      self._safeAppendToBuffer = newBuffer.size() < self._limit;\n    });\n  },\n\n  // This stop function is invoked from the onStop of the ObserveMultiplexer, so\n  // it shouldn't actually be possible to call it until the multiplexer is\n  // ready.\n  //\n  // It's important to check self._stopped after every call in this file that\n  // can yield!\n  stop: function () {\n    var self = this;\n    if (self._stopped)\n      return;\n    self._stopped = true;\n    _.each(self._stopHandles, function (handle) {\n      handle.stop();\n    });\n\n    // Note: we *don't* use multiplexer.onFlush here because this stop\n    // callback is actually invoked by the multiplexer itself when it has\n    // determined that there are no handles left. So nothing is actually going\n    // to get flushed (and it's probably not valid to call methods on the\n    // dying multiplexer).\n    _.each(self._writesToCommitWhenWeReachSteady, function (w) {\n      w.committed();  // maybe yields?\n    });\n    self._writesToCommitWhenWeReachSteady = null;\n\n    // Proactively drop references to potentially big things.\n    self._published = null;\n    self._unpublishedBuffer = null;\n    self._needToFetch = null;\n    self._currentlyFetching = null;\n    self._oplogEntryHandle = null;\n    self._listenersHandle = null;\n\n    Package.facts && Package.facts.Facts.incrementServerFact(\n      \"mongo-livedata\", \"observe-drivers-oplog\", -1);\n  },\n\n  _registerPhaseChange: function (phase) {\n    var self = this;\n    Meteor._noYieldsAllowed(function () {\n      var now = new Date;\n\n      if (self._phase) {\n        var timeDiff = now - self._phaseStartTime;\n        Package.facts && Package.facts.Facts.incrementServerFact(\n          \"mongo-livedata\", \"time-spent-in-\" + self._phase + \"-phase\", timeDiff);\n      }\n\n      self._phase = phase;\n      self._phaseStartTime = now;\n    });\n  }\n});\n\n// Does our oplog tailing code support this cursor? For now, we are being very\n// conservative and allowing only simple queries with simple options.\n// (This is a \"static method\".)\nOplogObserveDriver.cursorSupported = function (cursorDescription, matcher) {\n  // First, check the options.\n  var options = cursorDescription.options;\n\n  // Did the user say no explicitly?\n  // underscored version of the option is COMPAT with 1.2\n  if (options.disableOplog || options._disableOplog)\n    return false;\n\n  // skip is not supported: to support it we would need to keep track of all\n  // \"skipped\" documents or at least their ids.\n  // limit w/o a sort specifier is not supported: current implementation needs a\n  // deterministic way to order documents.\n  if (options.skip || (options.limit && !options.sort)) return false;\n\n  // If a fields projection option is given check if it is supported by\n  // minimongo (some operators are not supported).\n  if (options.fields) {\n    try {\n      LocalCollection._checkSupportedProjection(options.fields);\n    } catch (e) {\n      if (e.name === \"MinimongoError\")\n        return false;\n      else\n        throw e;\n    }\n  }\n\n  // We don't allow the following selectors:\n  //   - $where (not confident that we provide the same JS environment\n  //             as Mongo, and can yield!)\n  //   - $near (has \"interesting\" properties in MongoDB, like the possibility\n  //            of returning an ID multiple times, though even polling maybe\n  //            have a bug there)\n  //           XXX: once we support it, we would need to think more on how we\n  //           initialize the comparators when we create the driver.\n  return !matcher.hasWhere() && !matcher.hasGeoQuery();\n};\n\nvar modifierCanBeDirectlyApplied = function (modifier) {\n  return _.all(modifier, function (fields, operation) {\n    return _.all(fields, function (value, field) {\n      return !/EJSON\\$/.test(field);\n    });\n  });\n};\n\nMongoInternals.OplogObserveDriver = OplogObserveDriver;\n"]},"hash":"a0a6bbd7a99095c4deface4931f345f3a7ab28d9"}
