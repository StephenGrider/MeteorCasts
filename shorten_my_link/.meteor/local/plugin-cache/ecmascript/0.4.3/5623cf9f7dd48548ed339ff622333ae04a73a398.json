{"metadata":{"usedHelpers":[],"marked":[],"modules":{"imports":[],"exports":{"exported":[],"specifiers":[]}}},"options":{"filename":"/packages/ddp-server/writefence.js","filenameRelative":"/packages/ddp-server/writefence.js","env":{},"retainLines":false,"highlightCode":true,"suppressDeprecationMessages":false,"presets":[],"plugins":[[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],{"polyfill":false}],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],{"loose":true}],[[],{"loose":true}],[[],null],[[],{"loose":true}],[[],null],[[],null],[[],{"allowTopLevelThis":true,"strict":false,"loose":true}],[[],null],[[],null],[[],null],[[],null],[[],null],[[],{"loose":true}],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null]],"ignore":[],"code":true,"metadata":true,"ast":false,"comments":true,"compact":false,"minified":false,"sourceMap":true,"sourceMaps":true,"sourceMapTarget":"/packages/ddp-server/writefence.js.map","sourceFileName":"/packages/ddp-server/writefence.js","babelrc":false,"sourceType":"module","moduleIds":false,"passPerPreset":false,"basename":"writefence"},"ignored":false,"code":"var path = Npm.require('path');\nvar Future = Npm.require(path.join('fibers', 'future'));\n\n// A write fence collects a group of writes, and provides a callback\n// when all of the writes are fully committed and propagated (all\n// observers have been notified of the write and acknowledged it.)\n//\nDDPServer._WriteFence = function () {\n  var self = this;\n\n  self.armed = false;\n  self.fired = false;\n  self.retired = false;\n  self.outstanding_writes = 0;\n  self.before_fire_callbacks = [];\n  self.completion_callbacks = [];\n};\n\n// The current write fence. When there is a current write fence, code\n// that writes to databases should register their writes with it using\n// beginWrite().\n//\nDDPServer._CurrentWriteFence = new Meteor.EnvironmentVariable();\n\n_.extend(DDPServer._WriteFence.prototype, {\n  // Start tracking a write, and return an object to represent it. The\n  // object has a single method, committed(). This method should be\n  // called when the write is fully committed and propagated. You can\n  // continue to add writes to the WriteFence up until it is triggered\n  // (calls its callbacks because all writes have committed.)\n  beginWrite: function () {\n    function beginWrite() {\n      var self = this;\n\n      if (self.retired) return { committed: function () {\n          function committed() {}\n\n          return committed;\n        }() };\n\n      if (self.fired) throw new Error(\"fence has already activated -- too late to add writes\");\n\n      self.outstanding_writes++;\n      var _committed = false;\n      return {\n        committed: function () {\n          function committed() {\n            if (_committed) throw new Error(\"committed called twice on the same write\");\n            _committed = true;\n            self.outstanding_writes--;\n            self._maybeFire();\n          }\n\n          return committed;\n        }()\n      };\n    }\n\n    return beginWrite;\n  }(),\n\n  // Arm the fence. Once the fence is armed, and there are no more\n  // uncommitted writes, it will activate.\n  arm: function () {\n    function arm() {\n      var self = this;\n      if (self === DDPServer._CurrentWriteFence.get()) throw Error(\"Can't arm the current fence\");\n      self.armed = true;\n      self._maybeFire();\n    }\n\n    return arm;\n  }(),\n\n  // Register a function to be called once before firing the fence.\n  // Callback function can add new writes to the fence, in which case\n  // it won't fire until those writes are done as well.\n  onBeforeFire: function () {\n    function onBeforeFire(func) {\n      var self = this;\n      if (self.fired) throw new Error(\"fence has already activated -- too late to \" + \"add a callback\");\n      self.before_fire_callbacks.push(func);\n    }\n\n    return onBeforeFire;\n  }(),\n\n  // Register a function to be called when the fence fires.\n  onAllCommitted: function () {\n    function onAllCommitted(func) {\n      var self = this;\n      if (self.fired) throw new Error(\"fence has already activated -- too late to \" + \"add a callback\");\n      self.completion_callbacks.push(func);\n    }\n\n    return onAllCommitted;\n  }(),\n\n  // Convenience function. Arms the fence, then blocks until it fires.\n  armAndWait: function () {\n    function armAndWait() {\n      var self = this;\n      var future = new Future();\n      self.onAllCommitted(function () {\n        future['return']();\n      });\n      self.arm();\n      future.wait();\n    }\n\n    return armAndWait;\n  }(),\n\n  _maybeFire: function () {\n    function _maybeFire() {\n      var self = this;\n      if (self.fired) throw new Error(\"write fence already activated?\");\n      if (self.armed && !self.outstanding_writes) {\n        var invokeCallback = function () {\n          function invokeCallback(func) {\n            try {\n              func(self);\n            } catch (err) {\n              Meteor._debug(\"exception in write fence callback:\", err);\n            }\n          }\n\n          return invokeCallback;\n        }();\n\n        self.outstanding_writes++;\n        while (self.before_fire_callbacks.length > 0) {\n          var callbacks = self.before_fire_callbacks;\n          self.before_fire_callbacks = [];\n          _.each(callbacks, invokeCallback);\n        }\n        self.outstanding_writes--;\n\n        if (!self.outstanding_writes) {\n          self.fired = true;\n          var callbacks = self.completion_callbacks;\n          self.completion_callbacks = [];\n          _.each(callbacks, invokeCallback);\n        }\n      }\n    }\n\n    return _maybeFire;\n  }(),\n\n  // Deactivate this fence so that adding more writes has no effect.\n  // The fence must have already fired.\n  retire: function () {\n    function retire() {\n      var self = this;\n      if (!self.fired) throw new Error(\"Can't retire a fence that hasn't fired.\");\n      self.retired = true;\n    }\n\n    return retire;\n  }()\n});","ast":null,"map":{"version":3,"sources":["/packages/ddp-server/writefence.js"],"names":[],"mappings":"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","file":"/packages/ddp-server/writefence.js.map","sourcesContent":["var path = Npm.require('path');\nvar Future = Npm.require(path.join('fibers', 'future'));\n\n// A write fence collects a group of writes, and provides a callback\n// when all of the writes are fully committed and propagated (all\n// observers have been notified of the write and acknowledged it.)\n//\nDDPServer._WriteFence = function () {\n  var self = this;\n\n  self.armed = false;\n  self.fired = false;\n  self.retired = false;\n  self.outstanding_writes = 0;\n  self.before_fire_callbacks = [];\n  self.completion_callbacks = [];\n};\n\n// The current write fence. When there is a current write fence, code\n// that writes to databases should register their writes with it using\n// beginWrite().\n//\nDDPServer._CurrentWriteFence = new Meteor.EnvironmentVariable;\n\n_.extend(DDPServer._WriteFence.prototype, {\n  // Start tracking a write, and return an object to represent it. The\n  // object has a single method, committed(). This method should be\n  // called when the write is fully committed and propagated. You can\n  // continue to add writes to the WriteFence up until it is triggered\n  // (calls its callbacks because all writes have committed.)\n  beginWrite: function () {\n    var self = this;\n\n    if (self.retired)\n      return { committed: function () {} };\n\n    if (self.fired)\n      throw new Error(\"fence has already activated -- too late to add writes\");\n\n    self.outstanding_writes++;\n    var committed = false;\n    return {\n      committed: function () {\n        if (committed)\n          throw new Error(\"committed called twice on the same write\");\n        committed = true;\n        self.outstanding_writes--;\n        self._maybeFire();\n      }\n    };\n  },\n\n  // Arm the fence. Once the fence is armed, and there are no more\n  // uncommitted writes, it will activate.\n  arm: function () {\n    var self = this;\n    if (self === DDPServer._CurrentWriteFence.get())\n      throw Error(\"Can't arm the current fence\");\n    self.armed = true;\n    self._maybeFire();\n  },\n\n  // Register a function to be called once before firing the fence.\n  // Callback function can add new writes to the fence, in which case\n  // it won't fire until those writes are done as well.\n  onBeforeFire: function (func) {\n    var self = this;\n    if (self.fired)\n      throw new Error(\"fence has already activated -- too late to \" +\n                      \"add a callback\");\n    self.before_fire_callbacks.push(func);\n  },\n\n  // Register a function to be called when the fence fires.\n  onAllCommitted: function (func) {\n    var self = this;\n    if (self.fired)\n      throw new Error(\"fence has already activated -- too late to \" +\n                      \"add a callback\");\n    self.completion_callbacks.push(func);\n  },\n\n  // Convenience function. Arms the fence, then blocks until it fires.\n  armAndWait: function () {\n    var self = this;\n    var future = new Future;\n    self.onAllCommitted(function () {\n      future['return']();\n    });\n    self.arm();\n    future.wait();\n  },\n\n  _maybeFire: function () {\n    var self = this;\n    if (self.fired)\n      throw new Error(\"write fence already activated?\");\n    if (self.armed && !self.outstanding_writes) {\n      function invokeCallback (func) {\n        try {\n          func(self);\n        } catch (err) {\n          Meteor._debug(\"exception in write fence callback:\", err);\n        }\n      }\n\n      self.outstanding_writes++;\n      while (self.before_fire_callbacks.length > 0) {\n        var callbacks = self.before_fire_callbacks;\n        self.before_fire_callbacks = [];\n        _.each(callbacks, invokeCallback);\n      }\n      self.outstanding_writes--;\n\n      if (!self.outstanding_writes) {\n        self.fired = true;\n        var callbacks = self.completion_callbacks;\n        self.completion_callbacks = [];\n        _.each(callbacks, invokeCallback);\n      }\n    }\n  },\n\n  // Deactivate this fence so that adding more writes has no effect.\n  // The fence must have already fired.\n  retire: function () {\n    var self = this;\n    if (! self.fired)\n      throw new Error(\"Can't retire a fence that hasn't fired.\");\n    self.retired = true;\n  }\n});\n"]},"hash":"5623cf9f7dd48548ed339ff622333ae04a73a398"}
