{"metadata":{"usedHelpers":[],"marked":[],"modules":{"imports":[],"exports":{"exported":[],"specifiers":[]}}},"options":{"filename":"/packages/mongo/doc_fetcher.js","filenameRelative":"/packages/mongo/doc_fetcher.js","env":{},"retainLines":false,"highlightCode":true,"suppressDeprecationMessages":false,"presets":[],"plugins":[[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],{"polyfill":false}],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],{"loose":true}],[[],{"loose":true}],[[],null],[[],{"loose":true}],[[],null],[[],null],[[],{"allowTopLevelThis":true,"strict":false,"loose":true}],[[],null],[[],null],[[],null],[[],null],[[],null],[[],{"loose":true}],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null]],"ignore":[],"code":true,"metadata":true,"ast":false,"comments":true,"compact":false,"minified":false,"sourceMap":true,"sourceMaps":true,"sourceMapTarget":"/packages/mongo/doc_fetcher.js.map","sourceFileName":"/packages/mongo/doc_fetcher.js","babelrc":false,"sourceType":"module","moduleIds":false,"passPerPreset":false,"basename":"doc_fetcher"},"ignored":false,"code":"var Fiber = Npm.require('fibers');\nvar Future = Npm.require('fibers/future');\n\nDocFetcher = function DocFetcher(mongoConnection) {\n  var self = this;\n  self._mongoConnection = mongoConnection;\n  // Map from cache key -> [callback]\n  self._callbacksForCacheKey = {};\n};\n\n_.extend(DocFetcher.prototype, {\n  // Fetches document \"id\" from collectionName, returning it or null if not\n  // found.\n  //\n  // If you make multiple calls to fetch() with the same cacheKey (a string),\n  // DocFetcher may assume that they all return the same document. (It does\n  // not check to see if collectionName/id match.)\n  //\n  // You may assume that callback is never called synchronously (and in fact\n  // OplogObserveDriver does so).\n  fetch: function () {\n    function fetch(collectionName, id, cacheKey, callback) {\n      var self = this;\n\n      check(collectionName, String);\n      // id is some sort of scalar\n      check(cacheKey, String);\n\n      // If there's already an in-progress fetch for this cache key, yield until\n      // it's done and return whatever it returns.\n      if (_.has(self._callbacksForCacheKey, cacheKey)) {\n        self._callbacksForCacheKey[cacheKey].push(callback);\n        return;\n      }\n\n      var callbacks = self._callbacksForCacheKey[cacheKey] = [callback];\n\n      Fiber(function () {\n        try {\n          var doc = self._mongoConnection.findOne(collectionName, { _id: id }) || null;\n          // Return doc to all relevant callbacks. Note that this array can\n          // continue to grow during callback excecution.\n          while (!_.isEmpty(callbacks)) {\n            // Clone the document so that the various calls to fetch don't return\n            // objects that are intertwingled with each other. Clone before\n            // popping the future, so that if clone throws, the error gets passed\n            // to the next callback.\n            var clonedDoc = EJSON.clone(doc);\n            callbacks.pop()(null, clonedDoc);\n          }\n        } catch (e) {\n          while (!_.isEmpty(callbacks)) {\n            callbacks.pop()(e);\n          }\n        } finally {\n          // XXX consider keeping the doc around for a period of time before\n          // removing from the cache\n          delete self._callbacksForCacheKey[cacheKey];\n        }\n      }).run();\n    }\n\n    return fetch;\n  }()\n});\n\nMongoTest.DocFetcher = DocFetcher;","ast":null,"map":{"version":3,"sources":["/packages/mongo/doc_fetcher.js"],"names":[],"mappings":"AAAA,IAAI,QAAQ,IAAI,OAAJ,CAAY,QAAZ,CAAR;AACJ,IAAI,SAAS,IAAI,OAAJ,CAAY,eAAZ,CAAT;;AAEJ,aAAa,oBAAU,eAAV,EAA2B;AACtC,MAAI,OAAO,IAAP,CADkC;AAEtC,OAAK,gBAAL,GAAwB,eAAxB;;AAFsC,MAItC,CAAK,qBAAL,GAA6B,EAA7B,CAJsC;CAA3B;;AAOb,EAAE,MAAF,CAAS,WAAW,SAAX,EAAsB;;;;;;;;;;AAU7B;AAAO,mBAAU,cAAV,EAA0B,EAA1B,EAA8B,QAA9B,EAAwC,QAAxC,EAAkD;AACvD,UAAI,OAAO,IAAP,CADmD;;AAGvD,YAAM,cAAN,EAAsB,MAAtB;;AAHuD,WAKvD,CAAM,QAAN,EAAgB,MAAhB;;;;AALuD,UASnD,EAAE,GAAF,CAAM,KAAK,qBAAL,EAA4B,QAAlC,CAAJ,EAAiD;AAC/C,aAAK,qBAAL,CAA2B,QAA3B,EAAqC,IAArC,CAA0C,QAA1C,EAD+C;AAE/C,eAF+C;OAAjD;;AAKA,UAAI,YAAY,KAAK,qBAAL,CAA2B,QAA3B,IAAuC,CAAC,QAAD,CAAvC,CAduC;;AAgBvD,YAAM,YAAY;AAChB,YAAI;AACF,cAAI,MAAM,KAAK,gBAAL,CAAsB,OAAtB,CACR,cADQ,EACQ,EAAC,KAAK,EAAL,EADT,KACsB,IADtB;;;AADR,iBAKK,CAAC,EAAE,OAAF,CAAU,SAAV,CAAD,EAAuB;;;;;AAK5B,gBAAI,YAAY,MAAM,KAAN,CAAY,GAAZ,CAAZ,CALwB;AAM5B,sBAAU,GAAV,GAAgB,IAAhB,EAAsB,SAAtB,EAN4B;WAA9B;SALF,CAaE,OAAO,CAAP,EAAU;AACV,iBAAO,CAAC,EAAE,OAAF,CAAU,SAAV,CAAD,EAAuB;AAC5B,sBAAU,GAAV,GAAgB,CAAhB,EAD4B;WAA9B;SADA,SAIQ;;;AAGR,iBAAO,KAAK,qBAAL,CAA2B,QAA3B,CAAP,CAHQ;SAjBV;OADI,CAAN,CAuBG,GAvBH,GAhBuD;KAAlD;;;KAAP;CAVF;;AAqDA,UAAU,UAAV,GAAuB,UAAvB","file":"/packages/mongo/doc_fetcher.js.map","sourcesContent":["var Fiber = Npm.require('fibers');\nvar Future = Npm.require('fibers/future');\n\nDocFetcher = function (mongoConnection) {\n  var self = this;\n  self._mongoConnection = mongoConnection;\n  // Map from cache key -> [callback]\n  self._callbacksForCacheKey = {};\n};\n\n_.extend(DocFetcher.prototype, {\n  // Fetches document \"id\" from collectionName, returning it or null if not\n  // found.\n  //\n  // If you make multiple calls to fetch() with the same cacheKey (a string),\n  // DocFetcher may assume that they all return the same document. (It does\n  // not check to see if collectionName/id match.)\n  //\n  // You may assume that callback is never called synchronously (and in fact\n  // OplogObserveDriver does so).\n  fetch: function (collectionName, id, cacheKey, callback) {\n    var self = this;\n\n    check(collectionName, String);\n    // id is some sort of scalar\n    check(cacheKey, String);\n\n    // If there's already an in-progress fetch for this cache key, yield until\n    // it's done and return whatever it returns.\n    if (_.has(self._callbacksForCacheKey, cacheKey)) {\n      self._callbacksForCacheKey[cacheKey].push(callback);\n      return;\n    }\n\n    var callbacks = self._callbacksForCacheKey[cacheKey] = [callback];\n\n    Fiber(function () {\n      try {\n        var doc = self._mongoConnection.findOne(\n          collectionName, {_id: id}) || null;\n        // Return doc to all relevant callbacks. Note that this array can\n        // continue to grow during callback excecution.\n        while (!_.isEmpty(callbacks)) {\n          // Clone the document so that the various calls to fetch don't return\n          // objects that are intertwingled with each other. Clone before\n          // popping the future, so that if clone throws, the error gets passed\n          // to the next callback.\n          var clonedDoc = EJSON.clone(doc);\n          callbacks.pop()(null, clonedDoc);\n        }\n      } catch (e) {\n        while (!_.isEmpty(callbacks)) {\n          callbacks.pop()(e);\n        }\n      } finally {\n        // XXX consider keeping the doc around for a period of time before\n        // removing from the cache\n        delete self._callbacksForCacheKey[cacheKey];\n      }\n    }).run();\n  }\n});\n\nMongoTest.DocFetcher = DocFetcher;\n"]},"hash":"e47ea287ac6b6831b4083a860382c1113b9a0a72"}
