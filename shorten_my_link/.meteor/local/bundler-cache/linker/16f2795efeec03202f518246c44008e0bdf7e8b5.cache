[{"type":"js","data":"//////////////////////////////////////////////////////////////////////////\n//                                                                      //\n// This is a generated file. You can view the original                  //\n// source in your browser if your browser supports source maps.         //\n// Source maps are supported by all recent versions of Chrome, Safari,  //\n// and Firefox, and by Internet Explorer 11.                            //\n//                                                                      //\n//////////////////////////////////////////////////////////////////////////\n\n\n(function () {\n\n/* Imports */\nvar Meteor = Package.meteor.Meteor;\nvar global = Package.meteor.global;\nvar meteorEnv = Package.meteor.meteorEnv;\nvar HTML = Package.htmljs.HTML;\nvar Tracker = Package.tracker.Tracker;\nvar Deps = Package.tracker.Deps;\nvar Blaze = Package.blaze.Blaze;\nvar UI = Package.blaze.UI;\nvar Handlebars = Package.blaze.Handlebars;\nvar ObserveSequence = Package['observe-sequence'].ObserveSequence;\nvar _ = Package.underscore._;\n\n/* Package-scope variables */\nvar Spacebars;\n\n(function(){\n\n///////////////////////////////////////////////////////////////////////////////////\n//                                                                               //\n// packages/spacebars/spacebars-runtime.js                                       //\n//                                                                               //\n///////////////////////////////////////////////////////////////////////////////////\n                                                                                 //\nSpacebars = {};                                                                  // 1\n                                                                                 // 2\nvar tripleEquals = function (a, b) { return a === b; };                          // 3\n                                                                                 // 4\nSpacebars.include = function (templateOrFunction, contentFunc, elseFunc) {       // 5\n  if (! templateOrFunction)                                                      // 6\n    return null;                                                                 // 7\n                                                                                 // 8\n  if (typeof templateOrFunction !== 'function') {                                // 9\n    var template = templateOrFunction;                                           // 10\n    if (! Blaze.isTemplate(template))                                            // 11\n      throw new Error(\"Expected template or null, found: \" + template);          // 12\n    var view = templateOrFunction.constructView(contentFunc, elseFunc);          // 13\n    view.__startsNewLexicalScope = true;                                         // 14\n    return view;                                                                 // 15\n  }                                                                              // 16\n                                                                                 // 17\n  var templateVar = Blaze.ReactiveVar(null, tripleEquals);                       // 18\n  var view = Blaze.View('Spacebars.include', function () {                       // 19\n    var template = templateVar.get();                                            // 20\n    if (template === null)                                                       // 21\n      return null;                                                               // 22\n                                                                                 // 23\n    if (! Blaze.isTemplate(template))                                            // 24\n      throw new Error(\"Expected template or null, found: \" + template);          // 25\n                                                                                 // 26\n    return template.constructView(contentFunc, elseFunc);                        // 27\n  });                                                                            // 28\n  view.__templateVar = templateVar;                                              // 29\n  view.onViewCreated(function () {                                               // 30\n    this.autorun(function () {                                                   // 31\n      templateVar.set(templateOrFunction());                                     // 32\n    });                                                                          // 33\n  });                                                                            // 34\n  view.__startsNewLexicalScope = true;                                           // 35\n                                                                                 // 36\n  return view;                                                                   // 37\n};                                                                               // 38\n                                                                                 // 39\n// Executes `{{foo bar baz}}` when called on `(foo, bar, baz)`.                  // 40\n// If `bar` and `baz` are functions, they are called before                      // 41\n// `foo` is called on them.                                                      // 42\n//                                                                               // 43\n// This is the shared part of Spacebars.mustache and                             // 44\n// Spacebars.attrMustache, which differ in how they post-process the             // 45\n// result.                                                                       // 46\nSpacebars.mustacheImpl = function (value/*, args*/) {                            // 47\n  var args = arguments;                                                          // 48\n  // if we have any arguments (pos or kw), add an options argument               // 49\n  // if there isn't one.                                                         // 50\n  if (args.length > 1) {                                                         // 51\n    var kw = args[args.length - 1];                                              // 52\n    if (! (kw instanceof Spacebars.kw)) {                                        // 53\n      kw = Spacebars.kw();                                                       // 54\n      // clone arguments into an actual array, then push                         // 55\n      // the empty kw object.                                                    // 56\n      args = Array.prototype.slice.call(arguments);                              // 57\n      args.push(kw);                                                             // 58\n    } else {                                                                     // 59\n      // For each keyword arg, call it if it's a function                        // 60\n      var newHash = {};                                                          // 61\n      for (var k in kw.hash) {                                                   // 62\n        var v = kw.hash[k];                                                      // 63\n        newHash[k] = (typeof v === 'function' ? v() : v);                        // 64\n      }                                                                          // 65\n      args[args.length - 1] = Spacebars.kw(newHash);                             // 66\n    }                                                                            // 67\n  }                                                                              // 68\n                                                                                 // 69\n  return Spacebars.call.apply(null, args);                                       // 70\n};                                                                               // 71\n                                                                                 // 72\nSpacebars.mustache = function (value/*, args*/) {                                // 73\n  var result = Spacebars.mustacheImpl.apply(null, arguments);                    // 74\n                                                                                 // 75\n  if (result instanceof Spacebars.SafeString)                                    // 76\n    return HTML.Raw(result.toString());                                          // 77\n  else                                                                           // 78\n    // map `null`, `undefined`, and `false` to null, which is important          // 79\n    // so that attributes with nully values are considered absent.               // 80\n    // stringify anything else (e.g. strings, booleans, numbers including 0).    // 81\n    return (result == null || result === false) ? null : String(result);         // 82\n};                                                                               // 83\n                                                                                 // 84\nSpacebars.attrMustache = function (value/*, args*/) {                            // 85\n  var result = Spacebars.mustacheImpl.apply(null, arguments);                    // 86\n                                                                                 // 87\n  if (result == null || result === '') {                                         // 88\n    return null;                                                                 // 89\n  } else if (typeof result === 'object') {                                       // 90\n    return result;                                                               // 91\n  } else if (typeof result === 'string' && HTML.isValidAttributeName(result)) {  // 92\n    var obj = {};                                                                // 93\n    obj[result] = '';                                                            // 94\n    return obj;                                                                  // 95\n  } else {                                                                       // 96\n    throw new Error(\"Expected valid attribute name, '', null, or object\");       // 97\n  }                                                                              // 98\n};                                                                               // 99\n                                                                                 // 100\nSpacebars.dataMustache = function (value/*, args*/) {                            // 101\n  var result = Spacebars.mustacheImpl.apply(null, arguments);                    // 102\n                                                                                 // 103\n  return result;                                                                 // 104\n};                                                                               // 105\n                                                                                 // 106\n// Idempotently wrap in `HTML.Raw`.                                              // 107\n//                                                                               // 108\n// Called on the return value from `Spacebars.mustache` in case the              // 109\n// template uses triple-stache (`{{{foo bar baz}}}`).                            // 110\nSpacebars.makeRaw = function (value) {                                           // 111\n  if (value == null) // null or undefined                                        // 112\n    return null;                                                                 // 113\n  else if (value instanceof HTML.Raw)                                            // 114\n    return value;                                                                // 115\n  else                                                                           // 116\n    return HTML.Raw(value);                                                      // 117\n};                                                                               // 118\n                                                                                 // 119\n// If `value` is a function, evaluate its `args` (by calling them, if they       // 120\n// are functions), and then call it on them. Otherwise, return `value`.          // 121\n//                                                                               // 122\n// If `value` is not a function and is not null, then this method will assert    // 123\n// that there are no args. We check for null before asserting because a user     // 124\n// may write a template like {{user.fullNameWithPrefix 'Mr.'}}, where the        // 125\n// function will be null until data is ready.                                    // 126\nSpacebars.call = function (value/*, args*/) {                                    // 127\n  if (typeof value === 'function') {                                             // 128\n    // Evaluate arguments by calling them if they are functions.                 // 129\n    var newArgs = [];                                                            // 130\n    for (var i = 1; i < arguments.length; i++) {                                 // 131\n      var arg = arguments[i];                                                    // 132\n      newArgs[i-1] = (typeof arg === 'function' ? arg() : arg);                  // 133\n    }                                                                            // 134\n                                                                                 // 135\n    return value.apply(null, newArgs);                                           // 136\n  } else {                                                                       // 137\n    if (value != null && arguments.length > 1) {                                 // 138\n      throw new Error(\"Can't call non-function: \" + value);                      // 139\n    }                                                                            // 140\n    return value;                                                                // 141\n  }                                                                              // 142\n};                                                                               // 143\n                                                                                 // 144\n// Call this as `Spacebars.kw({ ... })`.  The return value                       // 145\n// is `instanceof Spacebars.kw`.                                                 // 146\nSpacebars.kw = function (hash) {                                                 // 147\n  if (! (this instanceof Spacebars.kw))                                          // 148\n    // called without new; call with new                                         // 149\n    return new Spacebars.kw(hash);                                               // 150\n                                                                                 // 151\n  this.hash = hash || {};                                                        // 152\n};                                                                               // 153\n                                                                                 // 154\n// Call this as `Spacebars.SafeString(\"some HTML\")`.  The return value           // 155\n// is `instanceof Spacebars.SafeString` (and `instanceof Handlebars.SafeString).\nSpacebars.SafeString = function (html) {                                         // 157\n  if (! (this instanceof Spacebars.SafeString))                                  // 158\n    // called without new; call with new                                         // 159\n    return new Spacebars.SafeString(html);                                       // 160\n                                                                                 // 161\n  return new Handlebars.SafeString(html);                                        // 162\n};                                                                               // 163\nSpacebars.SafeString.prototype = Handlebars.SafeString.prototype;                // 164\n                                                                                 // 165\n// `Spacebars.dot(foo, \"bar\", \"baz\")` performs a special kind                    // 166\n// of `foo.bar.baz` that allows safe indexing of `null` and                      // 167\n// indexing of functions (which calls the function).  If the                     // 168\n// result is a function, it is always a bound function (e.g.                     // 169\n// a wrapped version of `baz` that always uses `foo.bar` as                      // 170\n// `this`).                                                                      // 171\n//                                                                               // 172\n// In `Spacebars.dot(foo, \"bar\")`, `foo` is assumed to be either                 // 173\n// a non-function value or a \"fully-bound\" function wrapping a value,            // 174\n// where fully-bound means it takes no arguments and ignores `this`.             // 175\n//                                                                               // 176\n// `Spacebars.dot(foo, \"bar\")` performs the following steps:                     // 177\n//                                                                               // 178\n// * If `foo` is falsy, return `foo`.                                            // 179\n//                                                                               // 180\n// * If `foo` is a function, call it (set `foo` to `foo()`).                     // 181\n//                                                                               // 182\n// * If `foo` is falsy now, return `foo`.                                        // 183\n//                                                                               // 184\n// * Return `foo.bar`, binding it to `foo` if it's a function.                   // 185\nSpacebars.dot = function (value, id1/*, id2, ...*/) {                            // 186\n  if (arguments.length > 2) {                                                    // 187\n    // Note: doing this recursively is probably less efficient than              // 188\n    // doing it in an iterative loop.                                            // 189\n    var argsForRecurse = [];                                                     // 190\n    argsForRecurse.push(Spacebars.dot(value, id1));                              // 191\n    argsForRecurse.push.apply(argsForRecurse,                                    // 192\n                              Array.prototype.slice.call(arguments, 2));         // 193\n    return Spacebars.dot.apply(null, argsForRecurse);                            // 194\n  }                                                                              // 195\n                                                                                 // 196\n  if (typeof value === 'function')                                               // 197\n    value = value();                                                             // 198\n                                                                                 // 199\n  if (! value)                                                                   // 200\n    return value; // falsy, don't index, pass through                            // 201\n                                                                                 // 202\n  var result = value[id1];                                                       // 203\n  if (typeof result !== 'function')                                              // 204\n    return result;                                                               // 205\n  // `value[id1]` (or `value()[id1]`) is a function.                             // 206\n  // Bind it so that when called, `value` will be placed in `this`.              // 207\n  return function (/*arguments*/) {                                              // 208\n    return result.apply(value, arguments);                                       // 209\n  };                                                                             // 210\n};                                                                               // 211\n                                                                                 // 212\n// Spacebars.With implements the conditional logic of rendering                  // 213\n// the `{{else}}` block if the argument is falsy.  It combines                   // 214\n// a Blaze.If with a Blaze.With (the latter only in the truthy                   // 215\n// case, since the else block is evaluated without entering                      // 216\n// a new data context).                                                          // 217\nSpacebars.With = function (argFunc, contentFunc, elseFunc) {                     // 218\n  var argVar = new Blaze.ReactiveVar;                                            // 219\n  var view = Blaze.View('Spacebars_with', function () {                          // 220\n    return Blaze.If(function () { return argVar.get(); },                        // 221\n                    function () { return Blaze.With(function () {                // 222\n                      return argVar.get(); }, contentFunc); },                   // 223\n                    elseFunc);                                                   // 224\n  });                                                                            // 225\n  view.onViewCreated(function () {                                               // 226\n    this.autorun(function () {                                                   // 227\n      argVar.set(argFunc());                                                     // 228\n                                                                                 // 229\n      // This is a hack so that autoruns inside the body                         // 230\n      // of the #with get stopped sooner.  It reaches inside                     // 231\n      // our ReactiveVar to access its dep.                                      // 232\n                                                                                 // 233\n      Tracker.onInvalidate(function () {                                         // 234\n        argVar.dep.changed();                                                    // 235\n      });                                                                        // 236\n                                                                                 // 237\n      // Take the case of `{{#with A}}{{B}}{{/with}}`.  The goal                 // 238\n      // is to not re-render `B` if `A` changes to become falsy                  // 239\n      // and `B` is simultaneously invalidated.                                  // 240\n      //                                                                         // 241\n      // A series of autoruns are involved:                                      // 242\n      //                                                                         // 243\n      // 1. This autorun (argument to Spacebars.With)                            // 244\n      // 2. Argument to Blaze.If                                                 // 245\n      // 3. Blaze.If view re-render                                              // 246\n      // 4. Argument to Blaze.With                                               // 247\n      // 5. The template tag `{{B}}`                                             // 248\n      //                                                                         // 249\n      // When (3) is invalidated, it immediately stops (4) and (5)               // 250\n      // because of a Tracker.onInvalidate built into materializeView.           // 251\n      // (When a View's render method is invalidated, it immediately             // 252\n      // tears down all the subviews, via a Tracker.onInvalidate much            // 253\n      // like this one.                                                          // 254\n      //                                                                         // 255\n      // Suppose `A` changes to become falsy, and `B` changes at the             // 256\n      // same time (i.e. without an intervening flush).                          // 257\n      // Without the code above, this happens:                                   // 258\n      //                                                                         // 259\n      // - (1) and (5) are invalidated.                                          // 260\n      // - (1) runs, invalidating (2) and (4).                                   // 261\n      // - (5) runs.                                                             // 262\n      // - (2) runs, invalidating (3), stopping (4) and (5).                     // 263\n      //                                                                         // 264\n      // With the code above:                                                    // 265\n      //                                                                         // 266\n      // - (1) and (5) are invalidated, invalidating (2) and (4).                // 267\n      // - (1) runs.                                                             // 268\n      // - (2) runs, invalidating (3), stopping (4) and (5).                     // 269\n      //                                                                         // 270\n      // If the re-run of (5) is originally enqueued before (1), all             // 271\n      // bets are off, but typically that doesn't seem to be the                 // 272\n      // case.  Anyway, doing this is always better than not doing it,           // 273\n      // because it might save a bunch of DOM from being updated                 // 274\n      // needlessly.                                                             // 275\n    });                                                                          // 276\n  });                                                                            // 277\n                                                                                 // 278\n  return view;                                                                   // 279\n};                                                                               // 280\n                                                                                 // 281\n// XXX COMPAT WITH 0.9.0                                                         // 282\nSpacebars.TemplateWith = Blaze._TemplateWith;                                    // 283\n                                                                                 // 284\n///////////////////////////////////////////////////////////////////////////////////\n\n}).call(this);\n\n\n/* Exports */\nif (typeof Package === 'undefined') Package = {};\n(function (pkg, symbols) {\n  for (var s in symbols)\n    (s in pkg) || (pkg[s] = symbols[s]);\n})(Package.spacebars = {}, {\n  Spacebars: Spacebars\n});\n\n})();\n","servePath":"/packages/spacebars.js","sourceMap":{"version":3,"sources":["/packages/spacebars/spacebars-runtime.js"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uF","file":"/packages/spacebars.js","sourcesContent":["Spacebars = {};\n\nvar tripleEquals = function (a, b) { return a === b; };\n\nSpacebars.include = function (templateOrFunction, contentFunc, elseFunc) {\n  if (! templateOrFunction)\n    return null;\n\n  if (typeof templateOrFunction !== 'function') {\n    var template = templateOrFunction;\n    if (! Blaze.isTemplate(template))\n      throw new Error(\"Expected template or null, found: \" + template);\n    var view = templateOrFunction.constructView(contentFunc, elseFunc);\n    view.__startsNewLexicalScope = true;\n    return view;\n  }\n\n  var templateVar = Blaze.ReactiveVar(null, tripleEquals);\n  var view = Blaze.View('Spacebars.include', function () {\n    var template = templateVar.get();\n    if (template === null)\n      return null;\n\n    if (! Blaze.isTemplate(template))\n      throw new Error(\"Expected template or null, found: \" + template);\n\n    return template.constructView(contentFunc, elseFunc);\n  });\n  view.__templateVar = templateVar;\n  view.onViewCreated(function () {\n    this.autorun(function () {\n      templateVar.set(templateOrFunction());\n    });\n  });\n  view.__startsNewLexicalScope = true;\n\n  return view;\n};\n\n// Executes `{{foo bar baz}}` when called on `(foo, bar, baz)`.\n// If `bar` and `baz` are functions, they are called before\n// `foo` is called on them.\n//\n// This is the shared part of Spacebars.mustache and\n// Spacebars.attrMustache, which differ in how they post-process the\n// result.\nSpacebars.mustacheImpl = function (value/*, args*/) {\n  var args = arguments;\n  // if we have any arguments (pos or kw), add an options argument\n  // if there isn't one.\n  if (args.length > 1) {\n    var kw = args[args.length - 1];\n    if (! (kw instanceof Spacebars.kw)) {\n      kw = Spacebars.kw();\n      // clone arguments into an actual array, then push\n      // the empty kw object.\n      args = Array.prototype.slice.call(arguments);\n      args.push(kw);\n    } else {\n      // For each keyword arg, call it if it's a function\n      var newHash = {};\n      for (var k in kw.hash) {\n        var v = kw.hash[k];\n        newHash[k] = (typeof v === 'function' ? v() : v);\n      }\n      args[args.length - 1] = Spacebars.kw(newHash);\n    }\n  }\n\n  return Spacebars.call.apply(null, args);\n};\n\nSpacebars.mustache = function (value/*, args*/) {\n  var result = Spacebars.mustacheImpl.apply(null, arguments);\n\n  if (result instanceof Spacebars.SafeString)\n    return HTML.Raw(result.toString());\n  else\n    // map `null`, `undefined`, and `false` to null, which is important\n    // so that attributes with nully values are considered absent.\n    // stringify anything else (e.g. strings, booleans, numbers including 0).\n    return (result == null || result === false) ? null : String(result);\n};\n\nSpacebars.attrMustache = function (value/*, args*/) {\n  var result = Spacebars.mustacheImpl.apply(null, arguments);\n\n  if (result == null || result === '') {\n    return null;\n  } else if (typeof result === 'object') {\n    return result;\n  } else if (typeof result === 'string' && HTML.isValidAttributeName(result)) {\n    var obj = {};\n    obj[result] = '';\n    return obj;\n  } else {\n    throw new Error(\"Expected valid attribute name, '', null, or object\");\n  }\n};\n\nSpacebars.dataMustache = function (value/*, args*/) {\n  var result = Spacebars.mustacheImpl.apply(null, arguments);\n\n  return result;\n};\n\n// Idempotently wrap in `HTML.Raw`.\n//\n// Called on the return value from `Spacebars.mustache` in case the\n// template uses triple-stache (`{{{foo bar baz}}}`).\nSpacebars.makeRaw = function (value) {\n  if (value == null) // null or undefined\n    return null;\n  else if (value instanceof HTML.Raw)\n    return value;\n  else\n    return HTML.Raw(value);\n};\n\n// If `value` is a function, evaluate its `args` (by calling them, if they\n// are functions), and then call it on them. Otherwise, return `value`.\n//\n// If `value` is not a function and is not null, then this method will assert\n// that there are no args. We check for null before asserting because a user\n// may write a template like {{user.fullNameWithPrefix 'Mr.'}}, where the\n// function will be null until data is ready.\nSpacebars.call = function (value/*, args*/) {\n  if (typeof value === 'function') {\n    // Evaluate arguments by calling them if they are functions.\n    var newArgs = [];\n    for (var i = 1; i < arguments.length; i++) {\n      var arg = arguments[i];\n      newArgs[i-1] = (typeof arg === 'function' ? arg() : arg);\n    }\n\n    return value.apply(null, newArgs);\n  } else {\n    if (value != null && arguments.length > 1) {\n      throw new Error(\"Can't call non-function: \" + value);\n    }\n    return value;\n  }\n};\n\n// Call this as `Spacebars.kw({ ... })`.  The return value\n// is `instanceof Spacebars.kw`.\nSpacebars.kw = function (hash) {\n  if (! (this instanceof Spacebars.kw))\n    // called without new; call with new\n    return new Spacebars.kw(hash);\n\n  this.hash = hash || {};\n};\n\n// Call this as `Spacebars.SafeString(\"some HTML\")`.  The return value\n// is `instanceof Spacebars.SafeString` (and `instanceof Handlebars.SafeString).\nSpacebars.SafeString = function (html) {\n  if (! (this instanceof Spacebars.SafeString))\n    // called without new; call with new\n    return new Spacebars.SafeString(html);\n\n  return new Handlebars.SafeString(html);\n};\nSpacebars.SafeString.prototype = Handlebars.SafeString.prototype;\n\n// `Spacebars.dot(foo, \"bar\", \"baz\")` performs a special kind\n// of `foo.bar.baz` that allows safe indexing of `null` and\n// indexing of functions (which calls the function).  If the\n// result is a function, it is always a bound function (e.g.\n// a wrapped version of `baz` that always uses `foo.bar` as\n// `this`).\n//\n// In `Spacebars.dot(foo, \"bar\")`, `foo` is assumed to be either\n// a non-function value or a \"fully-bound\" function wrapping a value,\n// where fully-bound means it takes no arguments and ignores `this`.\n//\n// `Spacebars.dot(foo, \"bar\")` performs the following steps:\n//\n// * If `foo` is falsy, return `foo`.\n//\n// * If `foo` is a function, call it (set `foo` to `foo()`).\n//\n// * If `foo` is falsy now, return `foo`.\n//\n// * Return `foo.bar`, binding it to `foo` if it's a function.\nSpacebars.dot = function (value, id1/*, id2, ...*/) {\n  if (arguments.length > 2) {\n    // Note: doing this recursively is probably less efficient than\n    // doing it in an iterative loop.\n    var argsForRecurse = [];\n    argsForRecurse.push(Spacebars.dot(value, id1));\n    argsForRecurse.push.apply(argsForRecurse,\n                              Array.prototype.slice.call(arguments, 2));\n    return Spacebars.dot.apply(null, argsForRecurse);\n  }\n\n  if (typeof value === 'function')\n    value = value();\n\n  if (! value)\n    return value; // falsy, don't index, pass through\n\n  var result = value[id1];\n  if (typeof result !== 'function')\n    return result;\n  // `value[id1]` (or `value()[id1]`) is a function.\n  // Bind it so that when called, `value` will be placed in `this`.\n  return function (/*arguments*/) {\n    return result.apply(value, arguments);\n  };\n};\n\n// Spacebars.With implements the conditional logic of rendering\n// the `{{else}}` block if the argument is falsy.  It combines\n// a Blaze.If with a Blaze.With (the latter only in the truthy\n// case, since the else block is evaluated without entering\n// a new data context).\nSpacebars.With = function (argFunc, contentFunc, elseFunc) {\n  var argVar = new Blaze.ReactiveVar;\n  var view = Blaze.View('Spacebars_with', function () {\n    return Blaze.If(function () { return argVar.get(); },\n                    function () { return Blaze.With(function () {\n                      return argVar.get(); }, contentFunc); },\n                    elseFunc);\n  });\n  view.onViewCreated(function () {\n    this.autorun(function () {\n      argVar.set(argFunc());\n\n      // This is a hack so that autoruns inside the body\n      // of the #with get stopped sooner.  It reaches inside\n      // our ReactiveVar to access its dep.\n\n      Tracker.onInvalidate(function () {\n        argVar.dep.changed();\n      });\n\n      // Take the case of `{{#with A}}{{B}}{{/with}}`.  The goal\n      // is to not re-render `B` if `A` changes to become falsy\n      // and `B` is simultaneously invalidated.\n      //\n      // A series of autoruns are involved:\n      //\n      // 1. This autorun (argument to Spacebars.With)\n      // 2. Argument to Blaze.If\n      // 3. Blaze.If view re-render\n      // 4. Argument to Blaze.With\n      // 5. The template tag `{{B}}`\n      //\n      // When (3) is invalidated, it immediately stops (4) and (5)\n      // because of a Tracker.onInvalidate built into materializeView.\n      // (When a View's render method is invalidated, it immediately\n      // tears down all the subviews, via a Tracker.onInvalidate much\n      // like this one.\n      //\n      // Suppose `A` changes to become falsy, and `B` changes at the\n      // same time (i.e. without an intervening flush).\n      // Without the code above, this happens:\n      //\n      // - (1) and (5) are invalidated.\n      // - (1) runs, invalidating (2) and (4).\n      // - (5) runs.\n      // - (2) runs, invalidating (3), stopping (4) and (5).\n      //\n      // With the code above:\n      //\n      // - (1) and (5) are invalidated, invalidating (2) and (4).\n      // - (1) runs.\n      // - (2) runs, invalidating (3), stopping (4) and (5).\n      //\n      // If the re-run of (5) is originally enqueued before (1), all\n      // bets are off, but typically that doesn't seem to be the\n      // case.  Anyway, doing this is always better than not doing it,\n      // because it might save a bunch of DOM from being updated\n      // needlessly.\n    });\n  });\n\n  return view;\n};\n\n// XXX COMPAT WITH 0.9.0\nSpacebars.TemplateWith = Blaze._TemplateWith;\n"]}}]