[{"type":"js","data":"(function () {\n\n/* Imports */\nvar Meteor = Package.meteor.Meteor;\nvar global = Package.meteor.global;\nvar meteorEnv = Package.meteor.meteorEnv;\nvar meteorInstall = Package.modules.meteorInstall;\nvar Buffer = Package.modules.Buffer;\nvar process = Package.modules.process;\n\n/* Package-scope variables */\nvar exports, Promise;\n\nvar require = meteorInstall({\"node_modules\":{\"meteor\":{\"promise\":{\"server.js\":[\"meteor-promise\",\"fibers\",function(require,exports){\n\n//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n//                                                                                                                  //\n// packages/promise/server.js                                                                                       //\n//                                                                                                                  //\n//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n                                                                                                                    //\nexports.Promise = require(\"meteor-promise\");\n\n// Define MeteorPromise.Fiber so that every Promise callback can run in a\n// Fiber drawn from a pool of reusable Fibers.\nexports.Promise.Fiber = require(\"fibers\");\n\n//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n}],\"node_modules\":{\"meteor-promise\":{\"package.json\":function(require,exports){\n\n//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n//                                                                                                                  //\n// ../npm/node_modules/meteor-promise/package.json                                                                  //\n//                                                                                                                  //\n//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n                                                                                                                    //\nexports.name = \"meteor-promise\";\nexports.version = \"0.6.3\";\nexports.main = \"promise_server.js\";\n\n//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n},\"promise_server.js\":[\"assert\",\"./fiber_pool.js\",\"./promise.js\",function(require,exports,module){\n\n//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n//                                                                                                                  //\n// node_modules/meteor/promise/node_modules/meteor-promise/promise_server.js                                        //\n//                                                                                                                  //\n//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n                                                                                                                    //\nvar assert = require(\"assert\");\nvar fiberPool = require(\"./fiber_pool.js\").makePool();\nvar MeteorPromise = require(\"./promise.js\");\n\n// Replace MeteorPromise.prototype.then with a wrapper that ensures the\n// onResolved and onRejected callbacks always run in a Fiber.\nvar es6PromiseThen = MeteorPromise.prototype.then;\nMeteorPromise.prototype.then = function (onResolved, onRejected) {\n  var Promise = this.constructor;\n\n  if (typeof Promise.Fiber === \"function\") {\n    var fiber = Promise.Fiber.current;\n    var dynamics = cloneFiberOwnProperties(fiber);\n\n    return es6PromiseThen.call(\n      this,\n      wrapCallback(onResolved, Promise, dynamics),\n      wrapCallback(onRejected, Promise, dynamics)\n    );\n  }\n\n  return es6PromiseThen.call(this, onResolved, onRejected);\n};\n\nfunction wrapCallback(callback, Promise, dynamics) {\n  if (! callback) {\n    return callback;\n  }\n\n  return function (arg) {\n    return fiberPool.run({\n      callback: callback,\n      args: [arg], // Avoid dealing with arguments objects.\n      dynamics: dynamics\n    }, Promise);\n  };\n}\n\nfunction cloneFiberOwnProperties(fiber) {\n  if (fiber) {\n    var dynamics = {};\n\n    Object.keys(fiber).forEach(function (key) {\n      dynamics[key] = shallowClone(fiber[key]);\n    });\n\n    return dynamics;\n  }\n}\n\nfunction shallowClone(value) {\n  if (Array.isArray(value)) {\n    return value.slice(0);\n  }\n\n  if (value && typeof value === \"object\") {\n    var copy = Object.create(Object.getPrototypeOf(value));\n    var keys = Object.keys(value);\n    var keyCount = keys.length;\n\n    for (var i = 0; i < keyCount; ++i) {\n      var key = keys[i];\n      copy[key] = value[key];\n    }\n\n    return copy;\n  }\n\n  return value;\n}\n\n// Yield the current Fiber until the given Promise has been fulfilled.\nfunction awaitPromise(promise) {\n  var Promise = promise.constructor;\n  var Fiber = Promise.Fiber;\n\n  assert.strictEqual(\n    typeof Fiber, \"function\",\n    \"Cannot await unless Promise.Fiber is defined\"\n  );\n\n  var fiber = Fiber.current;\n\n  assert.ok(\n    fiber instanceof Fiber,\n    \"Cannot await without a Fiber\"\n  );\n\n  var run = fiber.run;\n  var throwInto = fiber.throwInto;\n\n  if (process.domain) {\n    run = process.domain.bind(run);\n    throwInto = process.domain.bind(throwInto);\n  }\n\n  // The overridden es6PromiseThen function is adequate here because these\n  // two callbacks do not need to run in a Fiber.\n  es6PromiseThen.call(promise, function (result) {\n    tryCatchNextTick(fiber, run, [result]);\n  }, function (error) {\n    tryCatchNextTick(fiber, throwInto, [error]);\n  });\n\n  return Fiber.yield();\n}\n\n// Invoke method with args against object in a try-catch block,\n// re-throwing any exceptions in the next tick of the event loop, so that\n// they won't get captured/swallowed by the caller.\nfunction tryCatchNextTick(object, method, args) {\n  try {\n    return method.apply(object, args);\n  } catch (error) {\n    process.nextTick(function () {\n      throw error;\n    });\n  }\n}\n\nMeteorPromise.awaitAll = function (args) {\n  return awaitPromise(this.all(args));\n};\n\nMeteorPromise.await = function (arg) {\n  return awaitPromise(this.resolve(arg));\n};\n\nMeteorPromise.prototype.await = function () {\n  return awaitPromise(this);\n};\n\n// Return a wrapper function that returns a Promise for the eventual\n// result of the original function.\nMeteorPromise.async = function (fn, allowReuseOfCurrentFiber) {\n  var Promise = this;\n  return function () {\n    return Promise.asyncApply(\n      fn, this, arguments,\n      allowReuseOfCurrentFiber\n    );\n  };\n};\n\nMeteorPromise.asyncApply = function (\n  fn, context, args, allowReuseOfCurrentFiber\n) {\n  var Promise = this;\n  var Fiber = Promise.Fiber;\n  var fiber = Fiber && Fiber.current;\n\n  if (fiber && allowReuseOfCurrentFiber) {\n    return this.resolve(fn.apply(context, args));\n  }\n\n  return fiberPool.run({\n    callback: fn,\n    context: context,\n    args: args,\n    dynamics: cloneFiberOwnProperties(fiber)\n  }, Promise);\n};\n\nFunction.prototype.async = function (allowReuseOfCurrentFiber) {\n  return MeteorPromise.async(this, allowReuseOfCurrentFiber);\n};\n\nFunction.prototype.asyncApply = function (\n  context, args, allowReuseOfCurrentFiber\n) {\n  return MeteorPromise.asyncApply(\n    this, context, args, allowReuseOfCurrentFiber\n  );\n};\n\nmodule.exports = exports = MeteorPromise;\n\n//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n}],\"fiber_pool.js\":[\"assert\",function(require,exports){\n\n//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n//                                                                                                                  //\n// node_modules/meteor/promise/node_modules/meteor-promise/fiber_pool.js                                            //\n//                                                                                                                  //\n//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n                                                                                                                    //\nvar assert = require(\"assert\");\nvar undefined;\n\nfunction FiberPool(targetFiberCount) {\n  assert.ok(this instanceof FiberPool);\n  assert.strictEqual(typeof targetFiberCount, \"number\");\n\n  var fiberStack = [];\n\n  function makeNewFiber(Fiber) {\n    // Just in case someone tampers with Fiber.yield, don't let that interfere\n    // with our processing of the callback queue.\n    var originalYield = Fiber.yield;\n\n    var fiber = new Fiber(function () {\n      while (true) {\n        // Call Fiber.yield() to await further instructions.\n        var entry = originalYield.call(Fiber);\n\n        // Ensure this Fiber is no longer in the pool once it begins to\n        // execute an entry.\n        assert.strictEqual(fiberStack.indexOf(fiber), -1);\n\n        if (entry.dynamics) {\n          // Restore the dynamic environment of this fiber as if\n          // entry.callback had been wrapped by Meteor.bindEnvironment.\n          Object.keys(entry.dynamics).forEach(function (key) {\n            fiber[key] = entry.dynamics[key];\n          });\n        }\n\n        try {\n          entry.resolve(entry.callback.apply(\n            entry.context || null,\n            entry.args || []\n          ));\n        } catch (error) {\n          entry.reject(error);\n        }\n\n        // Remove all own properties of the fiber before returning it to\n        // the pool.\n        Object.keys(fiber).forEach(function (key) {\n          delete fiber[key];\n        });\n\n        if (fiberStack.length < targetFiberCount) {\n          fiberStack.push(fiber);\n        } else {\n          // If the pool has already reached the target maximum number of\n          // Fibers, don't bother recycling this Fiber.\n          break;\n        }\n      }\n    });\n\n    // Run the new Fiber up to the first yield point, so that it will be\n    // ready to receive entries.\n    fiber.run();\n\n    return fiber;\n  }\n\n  // Run the entry.callback function in a Fiber either taken from the pool\n  // or created anew if the pool is empty. This method returns a Promise\n  // for the eventual result of the entry.callback function.\n  this.run = function (entry, Promise) {\n    assert.strictEqual(typeof entry, \"object\");\n    assert.strictEqual(typeof entry.callback, \"function\");\n\n    if (typeof Promise.Fiber !== \"function\") {\n      return new Promise(function (resolve) {\n        resolve(entry.callback.apply(\n          entry.context || null,\n          entry.args\n        ));\n      });\n    }\n\n    var fiber = fiberStack.pop() || makeNewFiber(Promise.Fiber);\n\n    var promise = new Promise(function (resolve, reject) {\n      entry.resolve = resolve;\n      entry.reject = reject;\n    });\n\n    fiber.run(entry);\n\n    return promise;\n  };\n\n  // Limit the maximum number of idle Fibers that may be kept in the\n  // pool. Note that the run method will never refuse to create a new\n  // Fiber if the pool is empty; it's just that excess Fibers might be\n  // thrown away upon completion, if the pool is full.\n  this.setTargetFiberCount = function (limit) {\n    assert.strictEqual(typeof limit, \"number\");\n\n    targetFiberCount = Math.max(limit, 0);\n\n    if (targetFiberCount < fiberStack.length) {\n      // If the requested target count is less than the current length of\n      // the stack, truncate the stack and terminate any surplus Fibers.\n      fiberStack.splice(targetFiberCount).forEach(function (fiber) {\n        fiber.reset();\n      });\n    }\n\n    return this;\n  };\n}\n\n// Call pool.drain() to terminate all Fibers waiting in the pool and\n// signal to any outstanding Fibers that they should exit upon completion,\n// instead of reinserting themselves into the pool.\nFiberPool.prototype.drain = function () {\n  return this.setTargetFiberCount(0);\n};\n\nexports.makePool = function (targetFiberCount) {\n  return new FiberPool(targetFiberCount || 20);\n};\n\n//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n}],\"promise.js\":[\"promise\",function(require,exports,module){\n\n//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n//                                                                                                                  //\n// node_modules/meteor/promise/node_modules/meteor-promise/promise.js                                               //\n//                                                                                                                  //\n//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n                                                                                                                    //\nvar hasOwn = Object.prototype.hasOwnProperty;\n\nvar g =\n  typeof global === \"object\" ? global :\n  typeof window === \"object\" ? window :\n  typeof self === \"object\" ? self : this;\n\nvar GlobalPromise = g.Promise;\nvar NpmPromise = require(\"promise\");\n\nfunction copyMethods(target, source) {\n  Object.keys(source).forEach(function (key) {\n    var value = source[key];\n    if (typeof value === \"function\" &&\n        ! hasOwn.call(target, key)) {\n      target[key] = value;\n    }\n  });\n}\n\nif (typeof GlobalPromise === \"function\") {\n  copyMethods(GlobalPromise, NpmPromise);\n  copyMethods(GlobalPromise.prototype, NpmPromise.prototype);\n  module.exports = GlobalPromise;\n} else {\n  module.exports = NpmPromise;\n}\n\n//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n}],\"node_modules\":{\"promise\":{\"package.json\":function(require,exports){\n\n//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n//                                                                                                                  //\n// ../npm/node_modules/meteor-promise/node_modules/promise/package.json                                             //\n//                                                                                                                  //\n//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n                                                                                                                    //\nexports.name = \"promise\";\nexports.version = \"7.1.1\";\nexports.main = \"index.js\";\n\n//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n},\"index.js\":[\"./lib\",function(require,exports,module){\n\n//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n//                                                                                                                  //\n// node_modules/meteor/promise/node_modules/meteor-promise/node_modules/promise/index.js                            //\n//                                                                                                                  //\n//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n                                                                                                                    //\n'use strict';\n\nmodule.exports = require('./lib')\n\n//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n}],\"lib\":{\"index.js\":[\"./core.js\",\"./done.js\",\"./finally.js\",\"./es6-extensions.js\",\"./node-extensions.js\",\"./synchronous.js\",function(require,exports,module){\n\n//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n//                                                                                                                  //\n// node_modules/meteor/promise/node_modules/meteor-promise/node_modules/promise/lib/index.js                        //\n//                                                                                                                  //\n//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n                                                                                                                    //\n'use strict';\n\nmodule.exports = require('./core.js');\nrequire('./done.js');\nrequire('./finally.js');\nrequire('./es6-extensions.js');\nrequire('./node-extensions.js');\nrequire('./synchronous.js');\n\n//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n}],\"core.js\":[\"asap/raw\",function(require,exports,module){\n\n//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n//                                                                                                                  //\n// node_modules/meteor/promise/node_modules/meteor-promise/node_modules/promise/lib/core.js                         //\n//                                                                                                                  //\n//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n                                                                                                                    //\n'use strict';\n\nvar asap = require('asap/raw');\n\nfunction noop() {}\n\n// States:\n//\n// 0 - pending\n// 1 - fulfilled with _value\n// 2 - rejected with _value\n// 3 - adopted the state of another promise, _value\n//\n// once the state is no longer pending (0) it is immutable\n\n// All `_` prefixed properties will be reduced to `_{random number}`\n// at build time to obfuscate them and discourage their use.\n// We don't use symbols or Object.defineProperty to fully hide them\n// because the performance isn't good enough.\n\n\n// to avoid using try/catch inside critical functions, we\n// extract them to here.\nvar LAST_ERROR = null;\nvar IS_ERROR = {};\nfunction getThen(obj) {\n  try {\n    return obj.then;\n  } catch (ex) {\n    LAST_ERROR = ex;\n    return IS_ERROR;\n  }\n}\n\nfunction tryCallOne(fn, a) {\n  try {\n    return fn(a);\n  } catch (ex) {\n    LAST_ERROR = ex;\n    return IS_ERROR;\n  }\n}\nfunction tryCallTwo(fn, a, b) {\n  try {\n    fn(a, b);\n  } catch (ex) {\n    LAST_ERROR = ex;\n    return IS_ERROR;\n  }\n}\n\nmodule.exports = Promise;\n\nfunction Promise(fn) {\n  if (typeof this !== 'object') {\n    throw new TypeError('Promises must be constructed via new');\n  }\n  if (typeof fn !== 'function') {\n    throw new TypeError('not a function');\n  }\n  this._45 = 0;\n  this._81 = 0;\n  this._65 = null;\n  this._54 = null;\n  if (fn === noop) return;\n  doResolve(fn, this);\n}\nPromise._10 = null;\nPromise._97 = null;\nPromise._61 = noop;\n\nPromise.prototype.then = function(onFulfilled, onRejected) {\n  if (this.constructor !== Promise) {\n    return safeThen(this, onFulfilled, onRejected);\n  }\n  var res = new Promise(noop);\n  handle(this, new Handler(onFulfilled, onRejected, res));\n  return res;\n};\n\nfunction safeThen(self, onFulfilled, onRejected) {\n  return new self.constructor(function (resolve, reject) {\n    var res = new Promise(noop);\n    res.then(resolve, reject);\n    handle(self, new Handler(onFulfilled, onRejected, res));\n  });\n};\nfunction handle(self, deferred) {\n  while (self._81 === 3) {\n    self = self._65;\n  }\n  if (Promise._10) {\n    Promise._10(self);\n  }\n  if (self._81 === 0) {\n    if (self._45 === 0) {\n      self._45 = 1;\n      self._54 = deferred;\n      return;\n    }\n    if (self._45 === 1) {\n      self._45 = 2;\n      self._54 = [self._54, deferred];\n      return;\n    }\n    self._54.push(deferred);\n    return;\n  }\n  handleResolved(self, deferred);\n}\n\nfunction handleResolved(self, deferred) {\n  asap(function() {\n    var cb = self._81 === 1 ? deferred.onFulfilled : deferred.onRejected;\n    if (cb === null) {\n      if (self._81 === 1) {\n        resolve(deferred.promise, self._65);\n      } else {\n        reject(deferred.promise, self._65);\n      }\n      return;\n    }\n    var ret = tryCallOne(cb, self._65);\n    if (ret === IS_ERROR) {\n      reject(deferred.promise, LAST_ERROR);\n    } else {\n      resolve(deferred.promise, ret);\n    }\n  });\n}\nfunction resolve(self, newValue) {\n  // Promise Resolution Procedure: https://github.com/promises-aplus/promises-spec#the-promise-resolution-procedure\n  if (newValue === self) {\n    return reject(\n      self,\n      new TypeError('A promise cannot be resolved with itself.')\n    );\n  }\n  if (\n    newValue &&\n    (typeof newValue === 'object' || typeof newValue === 'function')\n  ) {\n    var then = getThen(newValue);\n    if (then === IS_ERROR) {\n      return reject(self, LAST_ERROR);\n    }\n    if (\n      then === self.then &&\n      newValue instanceof Promise\n    ) {\n      self._81 = 3;\n      self._65 = newValue;\n      finale(self);\n      return;\n    } else if (typeof then === 'function') {\n      doResolve(then.bind(newValue), self);\n      return;\n    }\n  }\n  self._81 = 1;\n  self._65 = newValue;\n  finale(self);\n}\n\nfunction reject(self, newValue) {\n  self._81 = 2;\n  self._65 = newValue;\n  if (Promise._97) {\n    Promise._97(self, newValue);\n  }\n  finale(self);\n}\nfunction finale(self) {\n  if (self._45 === 1) {\n    handle(self, self._54);\n    self._54 = null;\n  }\n  if (self._45 === 2) {\n    for (var i = 0; i < self._54.length; i++) {\n      handle(self, self._54[i]);\n    }\n    self._54 = null;\n  }\n}\n\nfunction Handler(onFulfilled, onRejected, promise){\n  this.onFulfilled = typeof onFulfilled === 'function' ? onFulfilled : null;\n  this.onRejected = typeof onRejected === 'function' ? onRejected : null;\n  this.promise = promise;\n}\n\n/**\n * Take a potentially misbehaving resolver function and make sure\n * onFulfilled and onRejected are only called once.\n *\n * Makes no guarantees about asynchrony.\n */\nfunction doResolve(fn, promise) {\n  var done = false;\n  var res = tryCallTwo(fn, function (value) {\n    if (done) return;\n    done = true;\n    resolve(promise, value);\n  }, function (reason) {\n    if (done) return;\n    done = true;\n    reject(promise, reason);\n  })\n  if (!done && res === IS_ERROR) {\n    done = true;\n    reject(promise, LAST_ERROR);\n  }\n}\n\n//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n}],\"done.js\":[\"./core.js\",function(require,exports,module){\n\n//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n//                                                                                                                  //\n// node_modules/meteor/promise/node_modules/meteor-promise/node_modules/promise/lib/done.js                         //\n//                                                                                                                  //\n//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n                                                                                                                    //\n'use strict';\n\nvar Promise = require('./core.js');\n\nmodule.exports = Promise;\nPromise.prototype.done = function (onFulfilled, onRejected) {\n  var self = arguments.length ? this.then.apply(this, arguments) : this;\n  self.then(null, function (err) {\n    setTimeout(function () {\n      throw err;\n    }, 0);\n  });\n};\n\n//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n}],\"finally.js\":[\"./core.js\",function(require,exports,module){\n\n//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n//                                                                                                                  //\n// node_modules/meteor/promise/node_modules/meteor-promise/node_modules/promise/lib/finally.js                      //\n//                                                                                                                  //\n//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n                                                                                                                    //\n'use strict';\n\nvar Promise = require('./core.js');\n\nmodule.exports = Promise;\nPromise.prototype['finally'] = function (f) {\n  return this.then(function (value) {\n    return Promise.resolve(f()).then(function () {\n      return value;\n    });\n  }, function (err) {\n    return Promise.resolve(f()).then(function () {\n      throw err;\n    });\n  });\n};\n\n//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n}],\"es6-extensions.js\":[\"./core.js\",function(require,exports,module){\n\n//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n//                                                                                                                  //\n// node_modules/meteor/promise/node_modules/meteor-promise/node_modules/promise/lib/es6-extensions.js               //\n//                                                                                                                  //\n//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n                                                                                                                    //\n'use strict';\n\n//This file contains the ES6 extensions to the core Promises/A+ API\n\nvar Promise = require('./core.js');\n\nmodule.exports = Promise;\n\n/* Static Functions */\n\nvar TRUE = valuePromise(true);\nvar FALSE = valuePromise(false);\nvar NULL = valuePromise(null);\nvar UNDEFINED = valuePromise(undefined);\nvar ZERO = valuePromise(0);\nvar EMPTYSTRING = valuePromise('');\n\nfunction valuePromise(value) {\n  var p = new Promise(Promise._61);\n  p._81 = 1;\n  p._65 = value;\n  return p;\n}\nPromise.resolve = function (value) {\n  if (value instanceof Promise) return value;\n\n  if (value === null) return NULL;\n  if (value === undefined) return UNDEFINED;\n  if (value === true) return TRUE;\n  if (value === false) return FALSE;\n  if (value === 0) return ZERO;\n  if (value === '') return EMPTYSTRING;\n\n  if (typeof value === 'object' || typeof value === 'function') {\n    try {\n      var then = value.then;\n      if (typeof then === 'function') {\n        return new Promise(then.bind(value));\n      }\n    } catch (ex) {\n      return new Promise(function (resolve, reject) {\n        reject(ex);\n      });\n    }\n  }\n  return valuePromise(value);\n};\n\nPromise.all = function (arr) {\n  var args = Array.prototype.slice.call(arr);\n\n  return new Promise(function (resolve, reject) {\n    if (args.length === 0) return resolve([]);\n    var remaining = args.length;\n    function res(i, val) {\n      if (val && (typeof val === 'object' || typeof val === 'function')) {\n        if (val instanceof Promise && val.then === Promise.prototype.then) {\n          while (val._81 === 3) {\n            val = val._65;\n          }\n          if (val._81 === 1) return res(i, val._65);\n          if (val._81 === 2) reject(val._65);\n          val.then(function (val) {\n            res(i, val);\n          }, reject);\n          return;\n        } else {\n          var then = val.then;\n          if (typeof then === 'function') {\n            var p = new Promise(then.bind(val));\n            p.then(function (val) {\n              res(i, val);\n            }, reject);\n            return;\n          }\n        }\n      }\n      args[i] = val;\n      if (--remaining === 0) {\n        resolve(args);\n      }\n    }\n    for (var i = 0; i < args.length; i++) {\n      res(i, args[i]);\n    }\n  });\n};\n\nPromise.reject = function (value) {\n  return new Promise(function (resolve, reject) {\n    reject(value);\n  });\n};\n\nPromise.race = function (values) {\n  return new Promise(function (resolve, reject) {\n    values.forEach(function(value){\n      Promise.resolve(value).then(resolve, reject);\n    });\n  });\n};\n\n/* Prototype Methods */\n\nPromise.prototype['catch'] = function (onRejected) {\n  return this.then(null, onRejected);\n};\n\n//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n}],\"node-extensions.js\":[\"./core.js\",\"asap\",function(require,exports,module){\n\n//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n//                                                                                                                  //\n// node_modules/meteor/promise/node_modules/meteor-promise/node_modules/promise/lib/node-extensions.js              //\n//                                                                                                                  //\n//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n                                                                                                                    //\n'use strict';\n\n// This file contains then/promise specific extensions that are only useful\n// for node.js interop\n\nvar Promise = require('./core.js');\nvar asap = require('asap');\n\nmodule.exports = Promise;\n\n/* Static Functions */\n\nPromise.denodeify = function (fn, argumentCount) {\n  if (\n    typeof argumentCount === 'number' && argumentCount !== Infinity\n  ) {\n    return denodeifyWithCount(fn, argumentCount);\n  } else {\n    return denodeifyWithoutCount(fn);\n  }\n}\n\nvar callbackFn = (\n  'function (err, res) {' +\n  'if (err) { rj(err); } else { rs(res); }' +\n  '}'\n);\nfunction denodeifyWithCount(fn, argumentCount) {\n  var args = [];\n  for (var i = 0; i < argumentCount; i++) {\n    args.push('a' + i);\n  }\n  var body = [\n    'return function (' + args.join(',') + ') {',\n    'var self = this;',\n    'return new Promise(function (rs, rj) {',\n    'var res = fn.call(',\n    ['self'].concat(args).concat([callbackFn]).join(','),\n    ');',\n    'if (res &&',\n    '(typeof res === \"object\" || typeof res === \"function\") &&',\n    'typeof res.then === \"function\"',\n    ') {rs(res);}',\n    '});',\n    '};'\n  ].join('');\n  return Function(['Promise', 'fn'], body)(Promise, fn);\n}\nfunction denodeifyWithoutCount(fn) {\n  var fnLength = Math.max(fn.length - 1, 3);\n  var args = [];\n  for (var i = 0; i < fnLength; i++) {\n    args.push('a' + i);\n  }\n  var body = [\n    'return function (' + args.join(',') + ') {',\n    'var self = this;',\n    'var args;',\n    'var argLength = arguments.length;',\n    'if (arguments.length > ' + fnLength + ') {',\n    'args = new Array(arguments.length + 1);',\n    'for (var i = 0; i < arguments.length; i++) {',\n    'args[i] = arguments[i];',\n    '}',\n    '}',\n    'return new Promise(function (rs, rj) {',\n    'var cb = ' + callbackFn + ';',\n    'var res;',\n    'switch (argLength) {',\n    args.concat(['extra']).map(function (_, index) {\n      return (\n        'case ' + (index) + ':' +\n        'res = fn.call(' + ['self'].concat(args.slice(0, index)).concat('cb').join(',') + ');' +\n        'break;'\n      );\n    }).join(''),\n    'default:',\n    'args[argLength] = cb;',\n    'res = fn.apply(self, args);',\n    '}',\n    \n    'if (res &&',\n    '(typeof res === \"object\" || typeof res === \"function\") &&',\n    'typeof res.then === \"function\"',\n    ') {rs(res);}',\n    '});',\n    '};'\n  ].join('');\n\n  return Function(\n    ['Promise', 'fn'],\n    body\n  )(Promise, fn);\n}\n\nPromise.nodeify = function (fn) {\n  return function () {\n    var args = Array.prototype.slice.call(arguments);\n    var callback =\n      typeof args[args.length - 1] === 'function' ? args.pop() : null;\n    var ctx = this;\n    try {\n      return fn.apply(this, arguments).nodeify(callback, ctx);\n    } catch (ex) {\n      if (callback === null || typeof callback == 'undefined') {\n        return new Promise(function (resolve, reject) {\n          reject(ex);\n        });\n      } else {\n        asap(function () {\n          callback.call(ctx, ex);\n        })\n      }\n    }\n  }\n}\n\nPromise.prototype.nodeify = function (callback, ctx) {\n  if (typeof callback != 'function') return this;\n\n  this.then(function (value) {\n    asap(function () {\n      callback.call(ctx, null, value);\n    });\n  }, function (err) {\n    asap(function () {\n      callback.call(ctx, err);\n    });\n  });\n}\n\n//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n}],\"synchronous.js\":[\"./core.js\",function(require,exports,module){\n\n//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n//                                                                                                                  //\n// node_modules/meteor/promise/node_modules/meteor-promise/node_modules/promise/lib/synchronous.js                  //\n//                                                                                                                  //\n//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n                                                                                                                    //\n'use strict';\n\nvar Promise = require('./core.js');\n\nmodule.exports = Promise;\nPromise.enableSynchronous = function () {\n  Promise.prototype.isPending = function() {\n    return this.getState() == 0;\n  };\n\n  Promise.prototype.isFulfilled = function() {\n    return this.getState() == 1;\n  };\n\n  Promise.prototype.isRejected = function() {\n    return this.getState() == 2;\n  };\n\n  Promise.prototype.getValue = function () {\n    if (this._81 === 3) {\n      return this._65.getValue();\n    }\n\n    if (!this.isFulfilled()) {\n      throw new Error('Cannot get a value of an unfulfilled promise.');\n    }\n\n    return this._65;\n  };\n\n  Promise.prototype.getReason = function () {\n    if (this._81 === 3) {\n      return this._65.getReason();\n    }\n\n    if (!this.isRejected()) {\n      throw new Error('Cannot get a rejection reason of a non-rejected promise.');\n    }\n\n    return this._65;\n  };\n\n  Promise.prototype.getState = function () {\n    if (this._81 === 3) {\n      return this._65.getState();\n    }\n    if (this._81 === -1 || this._81 === -2) {\n      return 0;\n    }\n\n    return this._81;\n  };\n};\n\nPromise.disableSynchronous = function() {\n  Promise.prototype.isPending = undefined;\n  Promise.prototype.isFulfilled = undefined;\n  Promise.prototype.isRejected = undefined;\n  Promise.prototype.getValue = undefined;\n  Promise.prototype.getReason = undefined;\n  Promise.prototype.getState = undefined;\n};\n\n//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n}]},\"node_modules\":{\"asap\":{\"raw.js\":[\"domain\",function(require,exports,module){\n\n//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n//                                                                                                                  //\n// node_modules/meteor/promise/node_modules/meteor-promise/node_modules/promise/node_modules/asap/raw.js            //\n//                                                                                                                  //\n//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n                                                                                                                    //\n\"use strict\";\n\nvar domain; // The domain module is executed on demand\nvar hasSetImmediate = typeof setImmediate === \"function\";\n\n// Use the fastest means possible to execute a task in its own turn, with\n// priority over other events including network IO events in Node.js.\n//\n// An exception thrown by a task will permanently interrupt the processing of\n// subsequent tasks. The higher level `asap` function ensures that if an\n// exception is thrown by a task, that the task queue will continue flushing as\n// soon as possible, but if you use `rawAsap` directly, you are responsible to\n// either ensure that no exceptions are thrown from your task, or to manually\n// call `rawAsap.requestFlush` if an exception is thrown.\nmodule.exports = rawAsap;\nfunction rawAsap(task) {\n    if (!queue.length) {\n        requestFlush();\n        flushing = true;\n    }\n    // Avoids a function call\n    queue[queue.length] = task;\n}\n\nvar queue = [];\n// Once a flush has been requested, no further calls to `requestFlush` are\n// necessary until the next `flush` completes.\nvar flushing = false;\n// The position of the next task to execute in the task queue. This is\n// preserved between calls to `flush` so that it can be resumed if\n// a task throws an exception.\nvar index = 0;\n// If a task schedules additional tasks recursively, the task queue can grow\n// unbounded. To prevent memory excaustion, the task queue will periodically\n// truncate already-completed tasks.\nvar capacity = 1024;\n\n// The flush function processes all tasks that have been scheduled with\n// `rawAsap` unless and until one of those tasks throws an exception.\n// If a task throws an exception, `flush` ensures that its state will remain\n// consistent and will resume where it left off when called again.\n// However, `flush` does not make any arrangements to be called again if an\n// exception is thrown.\nfunction flush() {\n    while (index < queue.length) {\n        var currentIndex = index;\n        // Advance the index before calling the task. This ensures that we will\n        // begin flushing on the next task the task throws an error.\n        index = index + 1;\n        queue[currentIndex].call();\n        // Prevent leaking memory for long chains of recursive calls to `asap`.\n        // If we call `asap` within tasks scheduled by `asap`, the queue will\n        // grow, but to avoid an O(n) walk for every task we execute, we don't\n        // shift tasks off the queue after they have been executed.\n        // Instead, we periodically shift 1024 tasks off the queue.\n        if (index > capacity) {\n            // Manually shift all values starting at the index back to the\n            // beginning of the queue.\n            for (var scan = 0, newLength = queue.length - index; scan < newLength; scan++) {\n                queue[scan] = queue[scan + index];\n            }\n            queue.length -= index;\n            index = 0;\n        }\n    }\n    queue.length = 0;\n    index = 0;\n    flushing = false;\n}\n\nrawAsap.requestFlush = requestFlush;\nfunction requestFlush() {\n    // Ensure flushing is not bound to any domain.\n    // It is not sufficient to exit the domain, because domains exist on a stack.\n    // To execute code outside of any domain, the following dance is necessary.\n    var parentDomain = process.domain;\n    if (parentDomain) {\n        if (!domain) {\n            // Lazy execute the domain module.\n            // Only employed if the user elects to use domains.\n            domain = require(\"domain\");\n        }\n        domain.active = process.domain = null;\n    }\n\n    // `setImmediate` is slower that `process.nextTick`, but `process.nextTick`\n    // cannot handle recursion.\n    // `requestFlush` will only be called recursively from `asap.js`, to resume\n    // flushing after an error is thrown into a domain.\n    // Conveniently, `setImmediate` was introduced in the same version\n    // `process.nextTick` started throwing recursion errors.\n    if (flushing && hasSetImmediate) {\n        setImmediate(flush);\n    } else {\n        process.nextTick(flush);\n    }\n\n    if (parentDomain) {\n        domain.active = process.domain = parentDomain;\n    }\n}\n\n//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n}],\"package.json\":function(require,exports){\n\n//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n//                                                                                                                  //\n// ../npm/node_modules/meteor-promise/node_modules/promise/node_modules/asap/package.json                           //\n//                                                                                                                  //\n//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n                                                                                                                    //\nexports.name = \"asap\";\nexports.version = \"2.0.3\";\nexports.main = \"./asap.js\";\n\n//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n},\"asap.js\":[\"./raw\",function(require,exports,module){\n\n//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n//                                                                                                                  //\n// node_modules/meteor/promise/node_modules/meteor-promise/node_modules/promise/node_modules/asap/asap.js           //\n//                                                                                                                  //\n//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n                                                                                                                    //\n\"use strict\";\n\nvar rawAsap = require(\"./raw\");\nvar freeTasks = [];\n\n/**\n * Calls a task as soon as possible after returning, in its own event, with\n * priority over IO events. An exception thrown in a task can be handled by\n * `process.on(\"uncaughtException\") or `domain.on(\"error\")`, but will otherwise\n * crash the process. If the error is handled, all subsequent tasks will\n * resume.\n *\n * @param {{call}} task A callable object, typically a function that takes no\n * arguments.\n */\nmodule.exports = asap;\nfunction asap(task) {\n    var rawTask;\n    if (freeTasks.length) {\n        rawTask = freeTasks.pop();\n    } else {\n        rawTask = new RawTask();\n    }\n    rawTask.task = task;\n    rawTask.domain = process.domain;\n    rawAsap(rawTask);\n}\n\nfunction RawTask() {\n    this.task = null;\n    this.domain = null;\n}\n\nRawTask.prototype.call = function () {\n    if (this.domain) {\n        this.domain.enter();\n    }\n    var threw = true;\n    try {\n        this.task.call();\n        threw = false;\n        // If the task throws an exception (presumably) Node.js restores the\n        // domain stack for the next event.\n        if (this.domain) {\n            this.domain.exit();\n        }\n    } finally {\n        // We use try/finally and a threw flag to avoid messing up stack traces\n        // when we catch and release errors.\n        if (threw) {\n            // In Node.js, uncaught exceptions are considered fatal errors.\n            // Re-throw them to interrupt flushing!\n            // Ensure that flushing continues if an uncaught exception is\n            // suppressed listening process.on(\"uncaughtException\") or\n            // domain.on(\"error\").\n            rawAsap.requestFlush();\n        }\n        // If the task threw an error, we do not want to exit the domain here.\n        // Exiting the domain would prevent the domain from catching the error.\n        this.task = null;\n        this.domain = null;\n        freeTasks.push(this);\n    }\n};\n\n\n//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n}]}}}}}}}}}},{\"extensions\":[\".js\",\".json\"]});\nvar exports = require(\"./node_modules/meteor/promise/server.js\");\n\n/* Exports */\nif (typeof Package === 'undefined') Package = {};\n(function (pkg, symbols) {\n  for (var s in symbols)\n    (s in pkg) || (pkg[s] = symbols[s]);\n})(Package.promise = exports, {\n  Promise: Promise\n});\n\n})();\n","servePath":"/packages/promise.js","sourceMap":{"version":3,"sources":["/packages/promise/server.js","../npm/node_modules/meteor-promise/package.json","node_modules/meteor/promise/node_modules/meteor-promise/promise_server.js","node_modules/meteor/promise/node_modules/meteor-promise/fiber_pool.js","node_modules/meteor/promise/node_modules/meteor-promise/promise.js","../npm/node_modules/meteor-promise/node_modules/promise/package.json","node_modules/meteor/promise/node_modules/meteor-promise/node_modules/promise/index.js","node_modules/meteor/promise/node_modules/meteor-promise/node_modules/promise/lib/index.js","node_modules/meteor/promise/node_modules/meteor-promise/node_modules/promise/lib/core.js","node_modules/meteor/promise/node_modules/meteor-promise/node_modules/promise/lib/done.js","node_modules/meteor/promise/node_modules/meteor-promise/node_modules/promise/lib/finally.js","node_modules/meteor/promise/node_modules/meteor-promise/node_modules/promise/lib/es6-extensions.js","node_modules/meteor/promise/node_modules/meteor-promise/node_modules/promise/lib/node-extensions.js","node_modules/meteor/promise/node_modules/meteor-promise/node_modules/promise/lib/synchronous.js","node_modules/meteor/promise/node_modules/meteor-promise/node_modules/promise/node_modules/asap/raw.js","../npm/node_modules/meteor-promise/node_modules/promise/node_modules/asap/package.json","node_modules/meteor/promise/node_modules/meteor-promise/node_modules/promise/node_modules/asap/asap.js"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;AAAA;AACA;AACA;AACA;AACA;;;;;;;;;;;;ACJA;AACA;AACA;;;;;;;;;;;;ACFA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;AC/KA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;ACzHA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;AC1BA;AACA;AACA;;;;;;;;;;;;ACFA;AACA;AACA;;;;;;;;;;;;ACFA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;ACPA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;ACpNA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;ACZA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;ACfA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;AC1GA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;ACjIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;AC7DA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;ACpGA;AACA;AACA;;;;;;;;;;;;ACFA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"/packages/promise.js","sourcesContent":["exports.Promise = require(\"meteor-promise\");\n\n// Define MeteorPromise.Fiber so that every Promise callback can run in a\n// Fiber drawn from a pool of reusable Fibers.\nexports.Promise.Fiber = require(\"fibers\");\n","exports.name = \"meteor-promise\";\nexports.version = \"0.6.3\";\nexports.main = \"promise_server.js\";\n","var assert = require(\"assert\");\nvar fiberPool = require(\"./fiber_pool.js\").makePool();\nvar MeteorPromise = require(\"./promise.js\");\n\n// Replace MeteorPromise.prototype.then with a wrapper that ensures the\n// onResolved and onRejected callbacks always run in a Fiber.\nvar es6PromiseThen = MeteorPromise.prototype.then;\nMeteorPromise.prototype.then = function (onResolved, onRejected) {\n  var Promise = this.constructor;\n\n  if (typeof Promise.Fiber === \"function\") {\n    var fiber = Promise.Fiber.current;\n    var dynamics = cloneFiberOwnProperties(fiber);\n\n    return es6PromiseThen.call(\n      this,\n      wrapCallback(onResolved, Promise, dynamics),\n      wrapCallback(onRejected, Promise, dynamics)\n    );\n  }\n\n  return es6PromiseThen.call(this, onResolved, onRejected);\n};\n\nfunction wrapCallback(callback, Promise, dynamics) {\n  if (! callback) {\n    return callback;\n  }\n\n  return function (arg) {\n    return fiberPool.run({\n      callback: callback,\n      args: [arg], // Avoid dealing with arguments objects.\n      dynamics: dynamics\n    }, Promise);\n  };\n}\n\nfunction cloneFiberOwnProperties(fiber) {\n  if (fiber) {\n    var dynamics = {};\n\n    Object.keys(fiber).forEach(function (key) {\n      dynamics[key] = shallowClone(fiber[key]);\n    });\n\n    return dynamics;\n  }\n}\n\nfunction shallowClone(value) {\n  if (Array.isArray(value)) {\n    return value.slice(0);\n  }\n\n  if (value && typeof value === \"object\") {\n    var copy = Object.create(Object.getPrototypeOf(value));\n    var keys = Object.keys(value);\n    var keyCount = keys.length;\n\n    for (var i = 0; i < keyCount; ++i) {\n      var key = keys[i];\n      copy[key] = value[key];\n    }\n\n    return copy;\n  }\n\n  return value;\n}\n\n// Yield the current Fiber until the given Promise has been fulfilled.\nfunction awaitPromise(promise) {\n  var Promise = promise.constructor;\n  var Fiber = Promise.Fiber;\n\n  assert.strictEqual(\n    typeof Fiber, \"function\",\n    \"Cannot await unless Promise.Fiber is defined\"\n  );\n\n  var fiber = Fiber.current;\n\n  assert.ok(\n    fiber instanceof Fiber,\n    \"Cannot await without a Fiber\"\n  );\n\n  var run = fiber.run;\n  var throwInto = fiber.throwInto;\n\n  if (process.domain) {\n    run = process.domain.bind(run);\n    throwInto = process.domain.bind(throwInto);\n  }\n\n  // The overridden es6PromiseThen function is adequate here because these\n  // two callbacks do not need to run in a Fiber.\n  es6PromiseThen.call(promise, function (result) {\n    tryCatchNextTick(fiber, run, [result]);\n  }, function (error) {\n    tryCatchNextTick(fiber, throwInto, [error]);\n  });\n\n  return Fiber.yield();\n}\n\n// Invoke method with args against object in a try-catch block,\n// re-throwing any exceptions in the next tick of the event loop, so that\n// they won't get captured/swallowed by the caller.\nfunction tryCatchNextTick(object, method, args) {\n  try {\n    return method.apply(object, args);\n  } catch (error) {\n    process.nextTick(function () {\n      throw error;\n    });\n  }\n}\n\nMeteorPromise.awaitAll = function (args) {\n  return awaitPromise(this.all(args));\n};\n\nMeteorPromise.await = function (arg) {\n  return awaitPromise(this.resolve(arg));\n};\n\nMeteorPromise.prototype.await = function () {\n  return awaitPromise(this);\n};\n\n// Return a wrapper function that returns a Promise for the eventual\n// result of the original function.\nMeteorPromise.async = function (fn, allowReuseOfCurrentFiber) {\n  var Promise = this;\n  return function () {\n    return Promise.asyncApply(\n      fn, this, arguments,\n      allowReuseOfCurrentFiber\n    );\n  };\n};\n\nMeteorPromise.asyncApply = function (\n  fn, context, args, allowReuseOfCurrentFiber\n) {\n  var Promise = this;\n  var Fiber = Promise.Fiber;\n  var fiber = Fiber && Fiber.current;\n\n  if (fiber && allowReuseOfCurrentFiber) {\n    return this.resolve(fn.apply(context, args));\n  }\n\n  return fiberPool.run({\n    callback: fn,\n    context: context,\n    args: args,\n    dynamics: cloneFiberOwnProperties(fiber)\n  }, Promise);\n};\n\nFunction.prototype.async = function (allowReuseOfCurrentFiber) {\n  return MeteorPromise.async(this, allowReuseOfCurrentFiber);\n};\n\nFunction.prototype.asyncApply = function (\n  context, args, allowReuseOfCurrentFiber\n) {\n  return MeteorPromise.asyncApply(\n    this, context, args, allowReuseOfCurrentFiber\n  );\n};\n\nmodule.exports = exports = MeteorPromise;\n","var assert = require(\"assert\");\nvar undefined;\n\nfunction FiberPool(targetFiberCount) {\n  assert.ok(this instanceof FiberPool);\n  assert.strictEqual(typeof targetFiberCount, \"number\");\n\n  var fiberStack = [];\n\n  function makeNewFiber(Fiber) {\n    // Just in case someone tampers with Fiber.yield, don't let that interfere\n    // with our processing of the callback queue.\n    var originalYield = Fiber.yield;\n\n    var fiber = new Fiber(function () {\n      while (true) {\n        // Call Fiber.yield() to await further instructions.\n        var entry = originalYield.call(Fiber);\n\n        // Ensure this Fiber is no longer in the pool once it begins to\n        // execute an entry.\n        assert.strictEqual(fiberStack.indexOf(fiber), -1);\n\n        if (entry.dynamics) {\n          // Restore the dynamic environment of this fiber as if\n          // entry.callback had been wrapped by Meteor.bindEnvironment.\n          Object.keys(entry.dynamics).forEach(function (key) {\n            fiber[key] = entry.dynamics[key];\n          });\n        }\n\n        try {\n          entry.resolve(entry.callback.apply(\n            entry.context || null,\n            entry.args || []\n          ));\n        } catch (error) {\n          entry.reject(error);\n        }\n\n        // Remove all own properties of the fiber before returning it to\n        // the pool.\n        Object.keys(fiber).forEach(function (key) {\n          delete fiber[key];\n        });\n\n        if (fiberStack.length < targetFiberCount) {\n          fiberStack.push(fiber);\n        } else {\n          // If the pool has already reached the target maximum number of\n          // Fibers, don't bother recycling this Fiber.\n          break;\n        }\n      }\n    });\n\n    // Run the new Fiber up to the first yield point, so that it will be\n    // ready to receive entries.\n    fiber.run();\n\n    return fiber;\n  }\n\n  // Run the entry.callback function in a Fiber either taken from the pool\n  // or created anew if the pool is empty. This method returns a Promise\n  // for the eventual result of the entry.callback function.\n  this.run = function (entry, Promise) {\n    assert.strictEqual(typeof entry, \"object\");\n    assert.strictEqual(typeof entry.callback, \"function\");\n\n    if (typeof Promise.Fiber !== \"function\") {\n      return new Promise(function (resolve) {\n        resolve(entry.callback.apply(\n          entry.context || null,\n          entry.args\n        ));\n      });\n    }\n\n    var fiber = fiberStack.pop() || makeNewFiber(Promise.Fiber);\n\n    var promise = new Promise(function (resolve, reject) {\n      entry.resolve = resolve;\n      entry.reject = reject;\n    });\n\n    fiber.run(entry);\n\n    return promise;\n  };\n\n  // Limit the maximum number of idle Fibers that may be kept in the\n  // pool. Note that the run method will never refuse to create a new\n  // Fiber if the pool is empty; it's just that excess Fibers might be\n  // thrown away upon completion, if the pool is full.\n  this.setTargetFiberCount = function (limit) {\n    assert.strictEqual(typeof limit, \"number\");\n\n    targetFiberCount = Math.max(limit, 0);\n\n    if (targetFiberCount < fiberStack.length) {\n      // If the requested target count is less than the current length of\n      // the stack, truncate the stack and terminate any surplus Fibers.\n      fiberStack.splice(targetFiberCount).forEach(function (fiber) {\n        fiber.reset();\n      });\n    }\n\n    return this;\n  };\n}\n\n// Call pool.drain() to terminate all Fibers waiting in the pool and\n// signal to any outstanding Fibers that they should exit upon completion,\n// instead of reinserting themselves into the pool.\nFiberPool.prototype.drain = function () {\n  return this.setTargetFiberCount(0);\n};\n\nexports.makePool = function (targetFiberCount) {\n  return new FiberPool(targetFiberCount || 20);\n};\n","var hasOwn = Object.prototype.hasOwnProperty;\n\nvar g =\n  typeof global === \"object\" ? global :\n  typeof window === \"object\" ? window :\n  typeof self === \"object\" ? self : this;\n\nvar GlobalPromise = g.Promise;\nvar NpmPromise = require(\"promise\");\n\nfunction copyMethods(target, source) {\n  Object.keys(source).forEach(function (key) {\n    var value = source[key];\n    if (typeof value === \"function\" &&\n        ! hasOwn.call(target, key)) {\n      target[key] = value;\n    }\n  });\n}\n\nif (typeof GlobalPromise === \"function\") {\n  copyMethods(GlobalPromise, NpmPromise);\n  copyMethods(GlobalPromise.prototype, NpmPromise.prototype);\n  module.exports = GlobalPromise;\n} else {\n  module.exports = NpmPromise;\n}\n","exports.name = \"promise\";\nexports.version = \"7.1.1\";\nexports.main = \"index.js\";\n","'use strict';\n\nmodule.exports = require('./lib')\n","'use strict';\n\nmodule.exports = require('./core.js');\nrequire('./done.js');\nrequire('./finally.js');\nrequire('./es6-extensions.js');\nrequire('./node-extensions.js');\nrequire('./synchronous.js');\n","'use strict';\n\nvar asap = require('asap/raw');\n\nfunction noop() {}\n\n// States:\n//\n// 0 - pending\n// 1 - fulfilled with _value\n// 2 - rejected with _value\n// 3 - adopted the state of another promise, _value\n//\n// once the state is no longer pending (0) it is immutable\n\n// All `_` prefixed properties will be reduced to `_{random number}`\n// at build time to obfuscate them and discourage their use.\n// We don't use symbols or Object.defineProperty to fully hide them\n// because the performance isn't good enough.\n\n\n// to avoid using try/catch inside critical functions, we\n// extract them to here.\nvar LAST_ERROR = null;\nvar IS_ERROR = {};\nfunction getThen(obj) {\n  try {\n    return obj.then;\n  } catch (ex) {\n    LAST_ERROR = ex;\n    return IS_ERROR;\n  }\n}\n\nfunction tryCallOne(fn, a) {\n  try {\n    return fn(a);\n  } catch (ex) {\n    LAST_ERROR = ex;\n    return IS_ERROR;\n  }\n}\nfunction tryCallTwo(fn, a, b) {\n  try {\n    fn(a, b);\n  } catch (ex) {\n    LAST_ERROR = ex;\n    return IS_ERROR;\n  }\n}\n\nmodule.exports = Promise;\n\nfunction Promise(fn) {\n  if (typeof this !== 'object') {\n    throw new TypeError('Promises must be constructed via new');\n  }\n  if (typeof fn !== 'function') {\n    throw new TypeError('not a function');\n  }\n  this._45 = 0;\n  this._81 = 0;\n  this._65 = null;\n  this._54 = null;\n  if (fn === noop) return;\n  doResolve(fn, this);\n}\nPromise._10 = null;\nPromise._97 = null;\nPromise._61 = noop;\n\nPromise.prototype.then = function(onFulfilled, onRejected) {\n  if (this.constructor !== Promise) {\n    return safeThen(this, onFulfilled, onRejected);\n  }\n  var res = new Promise(noop);\n  handle(this, new Handler(onFulfilled, onRejected, res));\n  return res;\n};\n\nfunction safeThen(self, onFulfilled, onRejected) {\n  return new self.constructor(function (resolve, reject) {\n    var res = new Promise(noop);\n    res.then(resolve, reject);\n    handle(self, new Handler(onFulfilled, onRejected, res));\n  });\n};\nfunction handle(self, deferred) {\n  while (self._81 === 3) {\n    self = self._65;\n  }\n  if (Promise._10) {\n    Promise._10(self);\n  }\n  if (self._81 === 0) {\n    if (self._45 === 0) {\n      self._45 = 1;\n      self._54 = deferred;\n      return;\n    }\n    if (self._45 === 1) {\n      self._45 = 2;\n      self._54 = [self._54, deferred];\n      return;\n    }\n    self._54.push(deferred);\n    return;\n  }\n  handleResolved(self, deferred);\n}\n\nfunction handleResolved(self, deferred) {\n  asap(function() {\n    var cb = self._81 === 1 ? deferred.onFulfilled : deferred.onRejected;\n    if (cb === null) {\n      if (self._81 === 1) {\n        resolve(deferred.promise, self._65);\n      } else {\n        reject(deferred.promise, self._65);\n      }\n      return;\n    }\n    var ret = tryCallOne(cb, self._65);\n    if (ret === IS_ERROR) {\n      reject(deferred.promise, LAST_ERROR);\n    } else {\n      resolve(deferred.promise, ret);\n    }\n  });\n}\nfunction resolve(self, newValue) {\n  // Promise Resolution Procedure: https://github.com/promises-aplus/promises-spec#the-promise-resolution-procedure\n  if (newValue === self) {\n    return reject(\n      self,\n      new TypeError('A promise cannot be resolved with itself.')\n    );\n  }\n  if (\n    newValue &&\n    (typeof newValue === 'object' || typeof newValue === 'function')\n  ) {\n    var then = getThen(newValue);\n    if (then === IS_ERROR) {\n      return reject(self, LAST_ERROR);\n    }\n    if (\n      then === self.then &&\n      newValue instanceof Promise\n    ) {\n      self._81 = 3;\n      self._65 = newValue;\n      finale(self);\n      return;\n    } else if (typeof then === 'function') {\n      doResolve(then.bind(newValue), self);\n      return;\n    }\n  }\n  self._81 = 1;\n  self._65 = newValue;\n  finale(self);\n}\n\nfunction reject(self, newValue) {\n  self._81 = 2;\n  self._65 = newValue;\n  if (Promise._97) {\n    Promise._97(self, newValue);\n  }\n  finale(self);\n}\nfunction finale(self) {\n  if (self._45 === 1) {\n    handle(self, self._54);\n    self._54 = null;\n  }\n  if (self._45 === 2) {\n    for (var i = 0; i < self._54.length; i++) {\n      handle(self, self._54[i]);\n    }\n    self._54 = null;\n  }\n}\n\nfunction Handler(onFulfilled, onRejected, promise){\n  this.onFulfilled = typeof onFulfilled === 'function' ? onFulfilled : null;\n  this.onRejected = typeof onRejected === 'function' ? onRejected : null;\n  this.promise = promise;\n}\n\n/**\n * Take a potentially misbehaving resolver function and make sure\n * onFulfilled and onRejected are only called once.\n *\n * Makes no guarantees about asynchrony.\n */\nfunction doResolve(fn, promise) {\n  var done = false;\n  var res = tryCallTwo(fn, function (value) {\n    if (done) return;\n    done = true;\n    resolve(promise, value);\n  }, function (reason) {\n    if (done) return;\n    done = true;\n    reject(promise, reason);\n  })\n  if (!done && res === IS_ERROR) {\n    done = true;\n    reject(promise, LAST_ERROR);\n  }\n}\n","'use strict';\n\nvar Promise = require('./core.js');\n\nmodule.exports = Promise;\nPromise.prototype.done = function (onFulfilled, onRejected) {\n  var self = arguments.length ? this.then.apply(this, arguments) : this;\n  self.then(null, function (err) {\n    setTimeout(function () {\n      throw err;\n    }, 0);\n  });\n};\n","'use strict';\n\nvar Promise = require('./core.js');\n\nmodule.exports = Promise;\nPromise.prototype['finally'] = function (f) {\n  return this.then(function (value) {\n    return Promise.resolve(f()).then(function () {\n      return value;\n    });\n  }, function (err) {\n    return Promise.resolve(f()).then(function () {\n      throw err;\n    });\n  });\n};\n","'use strict';\n\n//This file contains the ES6 extensions to the core Promises/A+ API\n\nvar Promise = require('./core.js');\n\nmodule.exports = Promise;\n\n/* Static Functions */\n\nvar TRUE = valuePromise(true);\nvar FALSE = valuePromise(false);\nvar NULL = valuePromise(null);\nvar UNDEFINED = valuePromise(undefined);\nvar ZERO = valuePromise(0);\nvar EMPTYSTRING = valuePromise('');\n\nfunction valuePromise(value) {\n  var p = new Promise(Promise._61);\n  p._81 = 1;\n  p._65 = value;\n  return p;\n}\nPromise.resolve = function (value) {\n  if (value instanceof Promise) return value;\n\n  if (value === null) return NULL;\n  if (value === undefined) return UNDEFINED;\n  if (value === true) return TRUE;\n  if (value === false) return FALSE;\n  if (value === 0) return ZERO;\n  if (value === '') return EMPTYSTRING;\n\n  if (typeof value === 'object' || typeof value === 'function') {\n    try {\n      var then = value.then;\n      if (typeof then === 'function') {\n        return new Promise(then.bind(value));\n      }\n    } catch (ex) {\n      return new Promise(function (resolve, reject) {\n        reject(ex);\n      });\n    }\n  }\n  return valuePromise(value);\n};\n\nPromise.all = function (arr) {\n  var args = Array.prototype.slice.call(arr);\n\n  return new Promise(function (resolve, reject) {\n    if (args.length === 0) return resolve([]);\n    var remaining = args.length;\n    function res(i, val) {\n      if (val && (typeof val === 'object' || typeof val === 'function')) {\n        if (val instanceof Promise && val.then === Promise.prototype.then) {\n          while (val._81 === 3) {\n            val = val._65;\n          }\n          if (val._81 === 1) return res(i, val._65);\n          if (val._81 === 2) reject(val._65);\n          val.then(function (val) {\n            res(i, val);\n          }, reject);\n          return;\n        } else {\n          var then = val.then;\n          if (typeof then === 'function') {\n            var p = new Promise(then.bind(val));\n            p.then(function (val) {\n              res(i, val);\n            }, reject);\n            return;\n          }\n        }\n      }\n      args[i] = val;\n      if (--remaining === 0) {\n        resolve(args);\n      }\n    }\n    for (var i = 0; i < args.length; i++) {\n      res(i, args[i]);\n    }\n  });\n};\n\nPromise.reject = function (value) {\n  return new Promise(function (resolve, reject) {\n    reject(value);\n  });\n};\n\nPromise.race = function (values) {\n  return new Promise(function (resolve, reject) {\n    values.forEach(function(value){\n      Promise.resolve(value).then(resolve, reject);\n    });\n  });\n};\n\n/* Prototype Methods */\n\nPromise.prototype['catch'] = function (onRejected) {\n  return this.then(null, onRejected);\n};\n","'use strict';\n\n// This file contains then/promise specific extensions that are only useful\n// for node.js interop\n\nvar Promise = require('./core.js');\nvar asap = require('asap');\n\nmodule.exports = Promise;\n\n/* Static Functions */\n\nPromise.denodeify = function (fn, argumentCount) {\n  if (\n    typeof argumentCount === 'number' && argumentCount !== Infinity\n  ) {\n    return denodeifyWithCount(fn, argumentCount);\n  } else {\n    return denodeifyWithoutCount(fn);\n  }\n}\n\nvar callbackFn = (\n  'function (err, res) {' +\n  'if (err) { rj(err); } else { rs(res); }' +\n  '}'\n);\nfunction denodeifyWithCount(fn, argumentCount) {\n  var args = [];\n  for (var i = 0; i < argumentCount; i++) {\n    args.push('a' + i);\n  }\n  var body = [\n    'return function (' + args.join(',') + ') {',\n    'var self = this;',\n    'return new Promise(function (rs, rj) {',\n    'var res = fn.call(',\n    ['self'].concat(args).concat([callbackFn]).join(','),\n    ');',\n    'if (res &&',\n    '(typeof res === \"object\" || typeof res === \"function\") &&',\n    'typeof res.then === \"function\"',\n    ') {rs(res);}',\n    '});',\n    '};'\n  ].join('');\n  return Function(['Promise', 'fn'], body)(Promise, fn);\n}\nfunction denodeifyWithoutCount(fn) {\n  var fnLength = Math.max(fn.length - 1, 3);\n  var args = [];\n  for (var i = 0; i < fnLength; i++) {\n    args.push('a' + i);\n  }\n  var body = [\n    'return function (' + args.join(',') + ') {',\n    'var self = this;',\n    'var args;',\n    'var argLength = arguments.length;',\n    'if (arguments.length > ' + fnLength + ') {',\n    'args = new Array(arguments.length + 1);',\n    'for (var i = 0; i < arguments.length; i++) {',\n    'args[i] = arguments[i];',\n    '}',\n    '}',\n    'return new Promise(function (rs, rj) {',\n    'var cb = ' + callbackFn + ';',\n    'var res;',\n    'switch (argLength) {',\n    args.concat(['extra']).map(function (_, index) {\n      return (\n        'case ' + (index) + ':' +\n        'res = fn.call(' + ['self'].concat(args.slice(0, index)).concat('cb').join(',') + ');' +\n        'break;'\n      );\n    }).join(''),\n    'default:',\n    'args[argLength] = cb;',\n    'res = fn.apply(self, args);',\n    '}',\n    \n    'if (res &&',\n    '(typeof res === \"object\" || typeof res === \"function\") &&',\n    'typeof res.then === \"function\"',\n    ') {rs(res);}',\n    '});',\n    '};'\n  ].join('');\n\n  return Function(\n    ['Promise', 'fn'],\n    body\n  )(Promise, fn);\n}\n\nPromise.nodeify = function (fn) {\n  return function () {\n    var args = Array.prototype.slice.call(arguments);\n    var callback =\n      typeof args[args.length - 1] === 'function' ? args.pop() : null;\n    var ctx = this;\n    try {\n      return fn.apply(this, arguments).nodeify(callback, ctx);\n    } catch (ex) {\n      if (callback === null || typeof callback == 'undefined') {\n        return new Promise(function (resolve, reject) {\n          reject(ex);\n        });\n      } else {\n        asap(function () {\n          callback.call(ctx, ex);\n        })\n      }\n    }\n  }\n}\n\nPromise.prototype.nodeify = function (callback, ctx) {\n  if (typeof callback != 'function') return this;\n\n  this.then(function (value) {\n    asap(function () {\n      callback.call(ctx, null, value);\n    });\n  }, function (err) {\n    asap(function () {\n      callback.call(ctx, err);\n    });\n  });\n}\n","'use strict';\n\nvar Promise = require('./core.js');\n\nmodule.exports = Promise;\nPromise.enableSynchronous = function () {\n  Promise.prototype.isPending = function() {\n    return this.getState() == 0;\n  };\n\n  Promise.prototype.isFulfilled = function() {\n    return this.getState() == 1;\n  };\n\n  Promise.prototype.isRejected = function() {\n    return this.getState() == 2;\n  };\n\n  Promise.prototype.getValue = function () {\n    if (this._81 === 3) {\n      return this._65.getValue();\n    }\n\n    if (!this.isFulfilled()) {\n      throw new Error('Cannot get a value of an unfulfilled promise.');\n    }\n\n    return this._65;\n  };\n\n  Promise.prototype.getReason = function () {\n    if (this._81 === 3) {\n      return this._65.getReason();\n    }\n\n    if (!this.isRejected()) {\n      throw new Error('Cannot get a rejection reason of a non-rejected promise.');\n    }\n\n    return this._65;\n  };\n\n  Promise.prototype.getState = function () {\n    if (this._81 === 3) {\n      return this._65.getState();\n    }\n    if (this._81 === -1 || this._81 === -2) {\n      return 0;\n    }\n\n    return this._81;\n  };\n};\n\nPromise.disableSynchronous = function() {\n  Promise.prototype.isPending = undefined;\n  Promise.prototype.isFulfilled = undefined;\n  Promise.prototype.isRejected = undefined;\n  Promise.prototype.getValue = undefined;\n  Promise.prototype.getReason = undefined;\n  Promise.prototype.getState = undefined;\n};\n","\"use strict\";\n\nvar domain; // The domain module is executed on demand\nvar hasSetImmediate = typeof setImmediate === \"function\";\n\n// Use the fastest means possible to execute a task in its own turn, with\n// priority over other events including network IO events in Node.js.\n//\n// An exception thrown by a task will permanently interrupt the processing of\n// subsequent tasks. The higher level `asap` function ensures that if an\n// exception is thrown by a task, that the task queue will continue flushing as\n// soon as possible, but if you use `rawAsap` directly, you are responsible to\n// either ensure that no exceptions are thrown from your task, or to manually\n// call `rawAsap.requestFlush` if an exception is thrown.\nmodule.exports = rawAsap;\nfunction rawAsap(task) {\n    if (!queue.length) {\n        requestFlush();\n        flushing = true;\n    }\n    // Avoids a function call\n    queue[queue.length] = task;\n}\n\nvar queue = [];\n// Once a flush has been requested, no further calls to `requestFlush` are\n// necessary until the next `flush` completes.\nvar flushing = false;\n// The position of the next task to execute in the task queue. This is\n// preserved between calls to `flush` so that it can be resumed if\n// a task throws an exception.\nvar index = 0;\n// If a task schedules additional tasks recursively, the task queue can grow\n// unbounded. To prevent memory excaustion, the task queue will periodically\n// truncate already-completed tasks.\nvar capacity = 1024;\n\n// The flush function processes all tasks that have been scheduled with\n// `rawAsap` unless and until one of those tasks throws an exception.\n// If a task throws an exception, `flush` ensures that its state will remain\n// consistent and will resume where it left off when called again.\n// However, `flush` does not make any arrangements to be called again if an\n// exception is thrown.\nfunction flush() {\n    while (index < queue.length) {\n        var currentIndex = index;\n        // Advance the index before calling the task. This ensures that we will\n        // begin flushing on the next task the task throws an error.\n        index = index + 1;\n        queue[currentIndex].call();\n        // Prevent leaking memory for long chains of recursive calls to `asap`.\n        // If we call `asap` within tasks scheduled by `asap`, the queue will\n        // grow, but to avoid an O(n) walk for every task we execute, we don't\n        // shift tasks off the queue after they have been executed.\n        // Instead, we periodically shift 1024 tasks off the queue.\n        if (index > capacity) {\n            // Manually shift all values starting at the index back to the\n            // beginning of the queue.\n            for (var scan = 0, newLength = queue.length - index; scan < newLength; scan++) {\n                queue[scan] = queue[scan + index];\n            }\n            queue.length -= index;\n            index = 0;\n        }\n    }\n    queue.length = 0;\n    index = 0;\n    flushing = false;\n}\n\nrawAsap.requestFlush = requestFlush;\nfunction requestFlush() {\n    // Ensure flushing is not bound to any domain.\n    // It is not sufficient to exit the domain, because domains exist on a stack.\n    // To execute code outside of any domain, the following dance is necessary.\n    var parentDomain = process.domain;\n    if (parentDomain) {\n        if (!domain) {\n            // Lazy execute the domain module.\n            // Only employed if the user elects to use domains.\n            domain = require(\"domain\");\n        }\n        domain.active = process.domain = null;\n    }\n\n    // `setImmediate` is slower that `process.nextTick`, but `process.nextTick`\n    // cannot handle recursion.\n    // `requestFlush` will only be called recursively from `asap.js`, to resume\n    // flushing after an error is thrown into a domain.\n    // Conveniently, `setImmediate` was introduced in the same version\n    // `process.nextTick` started throwing recursion errors.\n    if (flushing && hasSetImmediate) {\n        setImmediate(flush);\n    } else {\n        process.nextTick(flush);\n    }\n\n    if (parentDomain) {\n        domain.active = process.domain = parentDomain;\n    }\n}\n","exports.name = \"asap\";\nexports.version = \"2.0.3\";\nexports.main = \"./asap.js\";\n","\"use strict\";\n\nvar rawAsap = require(\"./raw\");\nvar freeTasks = [];\n\n/**\n * Calls a task as soon as possible after returning, in its own event, with\n * priority over IO events. An exception thrown in a task can be handled by\n * `process.on(\"uncaughtException\") or `domain.on(\"error\")`, but will otherwise\n * crash the process. If the error is handled, all subsequent tasks will\n * resume.\n *\n * @param {{call}} task A callable object, typically a function that takes no\n * arguments.\n */\nmodule.exports = asap;\nfunction asap(task) {\n    var rawTask;\n    if (freeTasks.length) {\n        rawTask = freeTasks.pop();\n    } else {\n        rawTask = new RawTask();\n    }\n    rawTask.task = task;\n    rawTask.domain = process.domain;\n    rawAsap(rawTask);\n}\n\nfunction RawTask() {\n    this.task = null;\n    this.domain = null;\n}\n\nRawTask.prototype.call = function () {\n    if (this.domain) {\n        this.domain.enter();\n    }\n    var threw = true;\n    try {\n        this.task.call();\n        threw = false;\n        // If the task throws an exception (presumably) Node.js restores the\n        // domain stack for the next event.\n        if (this.domain) {\n            this.domain.exit();\n        }\n    } finally {\n        // We use try/finally and a threw flag to avoid messing up stack traces\n        // when we catch and release errors.\n        if (threw) {\n            // In Node.js, uncaught exceptions are considered fatal errors.\n            // Re-throw them to interrupt flushing!\n            // Ensure that flushing continues if an uncaught exception is\n            // suppressed listening process.on(\"uncaughtException\") or\n            // domain.on(\"error\").\n            rawAsap.requestFlush();\n        }\n        // If the task threw an error, we do not want to exit the domain here.\n        // Exiting the domain would prevent the domain from catching the error.\n        this.task = null;\n        this.domain = null;\n        freeTasks.push(this);\n    }\n};\n\n"]}}]