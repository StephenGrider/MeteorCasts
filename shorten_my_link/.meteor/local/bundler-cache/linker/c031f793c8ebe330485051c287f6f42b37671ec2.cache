[{"type":"js","data":"//////////////////////////////////////////////////////////////////////////\n//                                                                      //\n// This is a generated file. You can view the original                  //\n// source in your browser if your browser supports source maps.         //\n// Source maps are supported by all recent versions of Chrome, Safari,  //\n// and Firefox, and by Internet Explorer 11.                            //\n//                                                                      //\n//////////////////////////////////////////////////////////////////////////\n\n\n(function () {\n\n/* Imports */\nvar Meteor = Package.meteor.Meteor;\nvar global = Package.meteor.global;\nvar meteorEnv = Package.meteor.meteorEnv;\nvar check = Package.check.check;\nvar Match = Package.check.Match;\nvar Random = Package.random.Random;\nvar EJSON = Package.ejson.EJSON;\nvar _ = Package.underscore._;\nvar Tracker = Package.tracker.Tracker;\nvar Deps = Package.tracker.Deps;\nvar Retry = Package.retry.Retry;\nvar IdMap = Package['id-map'].IdMap;\nvar DDPCommon = Package['ddp-common'].DDPCommon;\nvar DiffSequence = Package['diff-sequence'].DiffSequence;\nvar MongoID = Package['mongo-id'].MongoID;\n\n/* Package-scope variables */\nvar DDP, LivedataTest, MongoIDMap, SockJS, toSockjsUrl, toWebsocketUrl, allConnections;\n\n(function(){\n\n////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n//                                                                                                                //\n// packages/ddp-client/namespace.js                                                                               //\n//                                                                                                                //\n////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n                                                                                                                  //\n/**                                                                                                               // 1\n * @namespace DDP                                                                                                 // 2\n * @summary Namespace for DDP-related methods/classes.                                                            // 3\n */                                                                                                               // 4\nDDP          = {};                                                                                                // 5\nLivedataTest = {};                                                                                                // 6\n                                                                                                                  // 7\n////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n}).call(this);\n\n\n\n\n\n\n(function(){\n\n////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n//                                                                                                                //\n// packages/ddp-client/id_map.js                                                                                  //\n//                                                                                                                //\n////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n                                                                                                                  //\nMongoIDMap = function () {                                                                                        // 1\n  var self = this;                                                                                                // 2\n  IdMap.call(self, MongoID.idStringify, MongoID.idParse);                                                         // 3\n};                                                                                                                // 4\n                                                                                                                  // 5\nMeteor._inherits(MongoIDMap, IdMap);                                                                              // 6\n                                                                                                                  // 7\n////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n}).call(this);\n\n\n\n\n\n\n(function(){\n\n////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n//                                                                                                                //\n// packages/ddp-client/sockjs-0.3.4.js                                                                            //\n//                                                                                                                //\n////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n                                                                                                                  //\n// XXX METEOR changes in <METEOR>                                                                                 // 1\n                                                                                                                  // 2\n/* SockJS client, version 0.3.4, http://sockjs.org, MIT License                                                   // 3\n                                                                                                                  // 4\nCopyright (c) 2011-2012 VMware, Inc.                                                                              // 5\n                                                                                                                  // 6\nPermission is hereby granted, free of charge, to any person obtaining a copy                                      // 7\nof this software and associated documentation files (the \"Software\"), to deal                                     // 8\nin the Software without restriction, including without limitation the rights                                      // 9\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell                                         // 10\ncopies of the Software, and to permit persons to whom the Software is                                             // 11\nfurnished to do so, subject to the following conditions:                                                          // 12\n                                                                                                                  // 13\nThe above copyright notice and this permission notice shall be included in                                        // 14\nall copies or substantial portions of the Software.                                                               // 15\n                                                                                                                  // 16\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR                                        // 17\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,                                          // 18\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE                                       // 19\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER                                            // 20\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,                                     // 21\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN                                         // 22\nTHE SOFTWARE.                                                                                                     // 23\n*/                                                                                                                // 24\n                                                                                                                  // 25\n// <METEOR> Commented out JSO implementation (use json package instead).                                          // 26\n// JSON2 by Douglas Crockford (minified).                                                                         // 27\n// var JSON;JSON||(JSON={}),function(){function str(a,b){var c,d,e,f,g=gap,h,i=b[a];i&&typeof i==\"object\"&&typeof i.toJSON==\"function\"&&(i=i.toJSON(a)),typeof rep==\"function\"&&(i=rep.call(b,a,i));switch(typeof i){case\"string\":return quote(i);case\"number\":return isFinite(i)?String(i):\"null\";case\"boolean\":case\"null\":return String(i);case\"object\":if(!i)return\"null\";gap+=indent,h=[];if(Object.prototype.toString.apply(i)===\"[object Array]\"){f=i.length;for(c=0;c<f;c+=1)h[c]=str(c,i)||\"null\";e=h.length===0?\"[]\":gap?\"[\\n\"+gap+h.join(\",\\n\"+gap)+\"\\n\"+g+\"]\":\"[\"+h.join(\",\")+\"]\",gap=g;return e}if(rep&&typeof rep==\"object\"){f=rep.length;for(c=0;c<f;c+=1)typeof rep[c]==\"string\"&&(d=rep[c],e=str(d,i),e&&h.push(quote(d)+(gap?\": \":\":\")+e))}else for(d in i)Object.prototype.hasOwnProperty.call(i,d)&&(e=str(d,i),e&&h.push(quote(d)+(gap?\": \":\":\")+e));e=h.length===0?\"{}\":gap?\"{\\n\"+gap+h.join(\",\\n\"+gap)+\"\\n\"+g+\"}\":\"{\"+h.join(\",\")+\"}\",gap=g;return e}}function quote(a){escapable.lastIndex=0;return escapable.test(a)?'\"'+a.replace(escapable,function(a){var b=meta[a];return typeof b==\"string\"?b:\"\\\\u\"+(\"0000\"+a.charCodeAt(0).toString(16)).slice(-4)})+'\"':'\"'+a+'\"'}function f(a){return a<10?\"0\"+a:a}\"use strict\",typeof Date.prototype.toJSON!=\"function\"&&(Date.prototype.toJSON=function(a){return isFinite(this.valueOf())?this.getUTCFullYear()+\"-\"+f(this.getUTCMonth()+1)+\"-\"+f(this.getUTCDate())+\"T\"+f(this.getUTCHours())+\":\"+f(this.getUTCMinutes())+\":\"+f(this.getUTCSeconds())+\"Z\":null},String.prototype.toJSON=Number.prototype.toJSON=Boolean.prototype.toJSON=function(a){return this.valueOf()});var cx=/[\\u0000\\u00ad\\u0600-\\u0604\\u070f\\u17b4\\u17b5\\u200c-\\u200f\\u2028-\\u202f\\u2060-\\u206f\\ufeff\\ufff0-\\uffff]/g,escapable=/[\\\\\\\"\\x00-\\x1f\\x7f-\\x9f\\u00ad\\u0600-\\u0604\\u070f\\u17b4\\u17b5\\u200c-\\u200f\\u2028-\\u202f\\u2060-\\u206f\\ufeff\\ufff0-\\uffff]/g,gap,indent,meta={\"\\b\":\"\\\\b\",\"\\t\":\"\\\\t\",\"\\n\":\"\\\\n\",\"\\f\":\"\\\\f\",\"\\r\":\"\\\\r\",'\"':'\\\\\"',\"\\\\\":\"\\\\\\\\\"},rep;typeof JSON.stringify!=\"function\"&&(JSON.stringify=function(a,b,c){var d;gap=\"\",indent=\"\";if(typeof c==\"number\")for(d=0;d<c;d+=1)indent+=\" \";else typeof c==\"string\"&&(indent=c);rep=b;if(!b||typeof b==\"function\"||typeof b==\"object\"&&typeof b.length==\"number\")return str(\"\",{\"\":a});throw new Error(\"JSON.stringify\")}),typeof JSON.parse!=\"function\"&&(JSON.parse=function(text,reviver){function walk(a,b){var c,d,e=a[b];if(e&&typeof e==\"object\")for(c in e)Object.prototype.hasOwnProperty.call(e,c)&&(d=walk(e,c),d!==undefined?e[c]=d:delete e[c]);return reviver.call(a,b,e)}var j;text=String(text),cx.lastIndex=0,cx.test(text)&&(text=text.replace(cx,function(a){return\"\\\\u\"+(\"0000\"+a.charCodeAt(0).toString(16)).slice(-4)}));if(/^[\\],:{}\\s]*$/.test(text.replace(/\\\\(?:[\"\\\\\\/bfnrt]|u[0-9a-fA-F]{4})/g,\"@\").replace(/\"[^\"\\\\\\n\\r]*\"|true|false|null|-?\\d+(?:\\.\\d*)?(?:[eE][+\\-]?\\d+)?/g,\"]\").replace(/(?:^|:|,)(?:\\s*\\[)+/g,\"\"))){j=eval(\"(\"+text+\")\");return typeof reviver==\"function\"?walk({\"\":j},\"\"):j}throw new SyntaxError(\"JSON.parse\")})}()\n// </METEOR>                                                                                                      // 29\n                                                                                                                  // 30\n//     [*] Including lib/index.js                                                                                 // 31\n// Public object                                                                                                  // 32\nSockJS = (function(){                                                                                             // 33\n              var _document = document;                                                                           // 34\n              var _window = window;                                                                               // 35\n              var utils = {};                                                                                     // 36\n                                                                                                                  // 37\n                                                                                                                  // 38\n//         [*] Including lib/reventtarget.js                                                                      // 39\n/*                                                                                                                // 40\n * ***** BEGIN LICENSE BLOCK *****                                                                                // 41\n * Copyright (c) 2011-2012 VMware, Inc.                                                                           // 42\n *                                                                                                                // 43\n * For the license see COPYING.                                                                                   // 44\n * ***** END LICENSE BLOCK *****                                                                                  // 45\n */                                                                                                               // 46\n                                                                                                                  // 47\n/* Simplified implementation of DOM2 EventTarget.                                                                 // 48\n *   http://www.w3.org/TR/DOM-Level-2-Events/events.html#Events-EventTarget                                       // 49\n */                                                                                                               // 50\nvar REventTarget = function() {};                                                                                 // 51\nREventTarget.prototype.addEventListener = function (eventType, listener) {                                        // 52\n    if(!this._listeners) {                                                                                        // 53\n         this._listeners = {};                                                                                    // 54\n    }                                                                                                             // 55\n    if(!(eventType in this._listeners)) {                                                                         // 56\n        this._listeners[eventType] = [];                                                                          // 57\n    }                                                                                                             // 58\n    var arr = this._listeners[eventType];                                                                         // 59\n    if(utils.arrIndexOf(arr, listener) === -1) {                                                                  // 60\n        arr.push(listener);                                                                                       // 61\n    }                                                                                                             // 62\n    return;                                                                                                       // 63\n};                                                                                                                // 64\n                                                                                                                  // 65\nREventTarget.prototype.removeEventListener = function (eventType, listener) {                                     // 66\n    if(!(this._listeners && (eventType in this._listeners))) {                                                    // 67\n        return;                                                                                                   // 68\n    }                                                                                                             // 69\n    var arr = this._listeners[eventType];                                                                         // 70\n    var idx = utils.arrIndexOf(arr, listener);                                                                    // 71\n    if (idx !== -1) {                                                                                             // 72\n        if(arr.length > 1) {                                                                                      // 73\n            this._listeners[eventType] = arr.slice(0, idx).concat( arr.slice(idx+1) );                            // 74\n        } else {                                                                                                  // 75\n            delete this._listeners[eventType];                                                                    // 76\n        }                                                                                                         // 77\n        return;                                                                                                   // 78\n    }                                                                                                             // 79\n    return;                                                                                                       // 80\n};                                                                                                                // 81\n                                                                                                                  // 82\nREventTarget.prototype.dispatchEvent = function (event) {                                                         // 83\n    var t = event.type;                                                                                           // 84\n    var args = Array.prototype.slice.call(arguments, 0);                                                          // 85\n    if (this['on'+t]) {                                                                                           // 86\n        this['on'+t].apply(this, args);                                                                           // 87\n    }                                                                                                             // 88\n    if (this._listeners && t in this._listeners) {                                                                // 89\n        for(var i=0; i < this._listeners[t].length; i++) {                                                        // 90\n            this._listeners[t][i].apply(this, args);                                                              // 91\n        }                                                                                                         // 92\n    }                                                                                                             // 93\n};                                                                                                                // 94\n//         [*] End of lib/reventtarget.js                                                                         // 95\n                                                                                                                  // 96\n                                                                                                                  // 97\n//         [*] Including lib/simpleevent.js                                                                       // 98\n/*                                                                                                                // 99\n * ***** BEGIN LICENSE BLOCK *****                                                                                // 100\n * Copyright (c) 2011-2012 VMware, Inc.                                                                           // 101\n *                                                                                                                // 102\n * For the license see COPYING.                                                                                   // 103\n * ***** END LICENSE BLOCK *****                                                                                  // 104\n */                                                                                                               // 105\n                                                                                                                  // 106\nvar SimpleEvent = function(type, obj) {                                                                           // 107\n    this.type = type;                                                                                             // 108\n    if (typeof obj !== 'undefined') {                                                                             // 109\n        for(var k in obj) {                                                                                       // 110\n            if (!obj.hasOwnProperty(k)) continue;                                                                 // 111\n            this[k] = obj[k];                                                                                     // 112\n        }                                                                                                         // 113\n    }                                                                                                             // 114\n};                                                                                                                // 115\n                                                                                                                  // 116\nSimpleEvent.prototype.toString = function() {                                                                     // 117\n    var r = [];                                                                                                   // 118\n    for(var k in this) {                                                                                          // 119\n        if (!this.hasOwnProperty(k)) continue;                                                                    // 120\n        var v = this[k];                                                                                          // 121\n        if (typeof v === 'function') v = '[function]';                                                            // 122\n        r.push(k + '=' + v);                                                                                      // 123\n    }                                                                                                             // 124\n    return 'SimpleEvent(' + r.join(', ') + ')';                                                                   // 125\n};                                                                                                                // 126\n//         [*] End of lib/simpleevent.js                                                                          // 127\n                                                                                                                  // 128\n                                                                                                                  // 129\n//         [*] Including lib/eventemitter.js                                                                      // 130\n/*                                                                                                                // 131\n * ***** BEGIN LICENSE BLOCK *****                                                                                // 132\n * Copyright (c) 2011-2012 VMware, Inc.                                                                           // 133\n *                                                                                                                // 134\n * For the license see COPYING.                                                                                   // 135\n * ***** END LICENSE BLOCK *****                                                                                  // 136\n */                                                                                                               // 137\n                                                                                                                  // 138\nvar EventEmitter = function(events) {                                                                             // 139\n    var that = this;                                                                                              // 140\n    that._events = events || [];                                                                                  // 141\n    that._listeners = {};                                                                                         // 142\n};                                                                                                                // 143\nEventEmitter.prototype.emit = function(type) {                                                                    // 144\n    var that = this;                                                                                              // 145\n    that._verifyType(type);                                                                                       // 146\n    if (that._nuked) return;                                                                                      // 147\n                                                                                                                  // 148\n    var args = Array.prototype.slice.call(arguments, 1);                                                          // 149\n    if (that['on'+type]) {                                                                                        // 150\n        that['on'+type].apply(that, args);                                                                        // 151\n    }                                                                                                             // 152\n    if (type in that._listeners) {                                                                                // 153\n        for(var i = 0; i < that._listeners[type].length; i++) {                                                   // 154\n            that._listeners[type][i].apply(that, args);                                                           // 155\n        }                                                                                                         // 156\n    }                                                                                                             // 157\n};                                                                                                                // 158\n                                                                                                                  // 159\nEventEmitter.prototype.on = function(type, callback) {                                                            // 160\n    var that = this;                                                                                              // 161\n    that._verifyType(type);                                                                                       // 162\n    if (that._nuked) return;                                                                                      // 163\n                                                                                                                  // 164\n    if (!(type in that._listeners)) {                                                                             // 165\n        that._listeners[type] = [];                                                                               // 166\n    }                                                                                                             // 167\n    that._listeners[type].push(callback);                                                                         // 168\n};                                                                                                                // 169\n                                                                                                                  // 170\nEventEmitter.prototype._verifyType = function(type) {                                                             // 171\n    var that = this;                                                                                              // 172\n    if (utils.arrIndexOf(that._events, type) === -1) {                                                            // 173\n        utils.log('Event ' + JSON.stringify(type) +                                                               // 174\n                  ' not listed ' + JSON.stringify(that._events) +                                                 // 175\n                  ' in ' + that);                                                                                 // 176\n    }                                                                                                             // 177\n};                                                                                                                // 178\n                                                                                                                  // 179\nEventEmitter.prototype.nuke = function() {                                                                        // 180\n    var that = this;                                                                                              // 181\n    that._nuked = true;                                                                                           // 182\n    for(var i=0; i<that._events.length; i++) {                                                                    // 183\n        delete that[that._events[i]];                                                                             // 184\n    }                                                                                                             // 185\n    that._listeners = {};                                                                                         // 186\n};                                                                                                                // 187\n//         [*] End of lib/eventemitter.js                                                                         // 188\n                                                                                                                  // 189\n                                                                                                                  // 190\n//         [*] Including lib/utils.js                                                                             // 191\n/*                                                                                                                // 192\n * ***** BEGIN LICENSE BLOCK *****                                                                                // 193\n * Copyright (c) 2011-2012 VMware, Inc.                                                                           // 194\n *                                                                                                                // 195\n * For the license see COPYING.                                                                                   // 196\n * ***** END LICENSE BLOCK *****                                                                                  // 197\n */                                                                                                               // 198\n                                                                                                                  // 199\nvar random_string_chars = 'abcdefghijklmnopqrstuvwxyz0123456789_';                                                // 200\nutils.random_string = function(length, max) {                                                                     // 201\n    max = max || random_string_chars.length;                                                                      // 202\n    var i, ret = [];                                                                                              // 203\n    for(i=0; i < length; i++) {                                                                                   // 204\n        ret.push( random_string_chars.substr(Math.floor(Math.random() * max),1) );                                // 205\n    }                                                                                                             // 206\n    return ret.join('');                                                                                          // 207\n};                                                                                                                // 208\nutils.random_number = function(max) {                                                                             // 209\n    return Math.floor(Math.random() * max);                                                                       // 210\n};                                                                                                                // 211\nutils.random_number_string = function(max) {                                                                      // 212\n    var t = (''+(max - 1)).length;                                                                                // 213\n    var p = Array(t+1).join('0');                                                                                 // 214\n    return (p + utils.random_number(max)).slice(-t);                                                              // 215\n};                                                                                                                // 216\n                                                                                                                  // 217\n// Assuming that url looks like: http://asdasd:111/asd                                                            // 218\nutils.getOrigin = function(url) {                                                                                 // 219\n    url += '/';                                                                                                   // 220\n    var parts = url.split('/').slice(0, 3);                                                                       // 221\n    return parts.join('/');                                                                                       // 222\n};                                                                                                                // 223\n                                                                                                                  // 224\nutils.isSameOriginUrl = function(url_a, url_b) {                                                                  // 225\n    // location.origin would do, but it's not always available.                                                   // 226\n    if (!url_b) url_b = _window.location.href;                                                                    // 227\n                                                                                                                  // 228\n    return (url_a.split('/').slice(0,3).join('/')                                                                 // 229\n                ===                                                                                               // 230\n            url_b.split('/').slice(0,3).join('/'));                                                               // 231\n};                                                                                                                // 232\n                                                                                                                  // 233\n// <METEOR>                                                                                                       // 234\n// https://github.com/sockjs/sockjs-client/issues/79                                                              // 235\nutils.isSameOriginScheme = function(url_a, url_b) {                                                               // 236\n    if (!url_b) url_b = _window.location.href;                                                                    // 237\n                                                                                                                  // 238\n    return (url_a.split(':')[0]                                                                                   // 239\n                ===                                                                                               // 240\n            url_b.split(':')[0]);                                                                                 // 241\n};                                                                                                                // 242\n// </METEOR>                                                                                                      // 243\n                                                                                                                  // 244\n                                                                                                                  // 245\nutils.getParentDomain = function(url) {                                                                           // 246\n    // ipv4 ip address                                                                                            // 247\n    if (/^[0-9.]*$/.test(url)) return url;                                                                        // 248\n    // ipv6 ip address                                                                                            // 249\n    if (/^\\[/.test(url)) return url;                                                                              // 250\n    // no dots                                                                                                    // 251\n    if (!(/[.]/.test(url))) return url;                                                                           // 252\n                                                                                                                  // 253\n    var parts = url.split('.').slice(1);                                                                          // 254\n    return parts.join('.');                                                                                       // 255\n};                                                                                                                // 256\n                                                                                                                  // 257\nutils.objectExtend = function(dst, src) {                                                                         // 258\n    for(var k in src) {                                                                                           // 259\n        if (src.hasOwnProperty(k)) {                                                                              // 260\n            dst[k] = src[k];                                                                                      // 261\n        }                                                                                                         // 262\n    }                                                                                                             // 263\n    return dst;                                                                                                   // 264\n};                                                                                                                // 265\n                                                                                                                  // 266\nvar WPrefix = '_jp';                                                                                              // 267\n                                                                                                                  // 268\nutils.polluteGlobalNamespace = function() {                                                                       // 269\n    if (!(WPrefix in _window)) {                                                                                  // 270\n        _window[WPrefix] = {};                                                                                    // 271\n    }                                                                                                             // 272\n};                                                                                                                // 273\n                                                                                                                  // 274\nutils.closeFrame = function (code, reason) {                                                                      // 275\n    return 'c'+JSON.stringify([code, reason]);                                                                    // 276\n};                                                                                                                // 277\n                                                                                                                  // 278\nutils.userSetCode = function (code) {                                                                             // 279\n    return code === 1000 || (code >= 3000 && code <= 4999);                                                       // 280\n};                                                                                                                // 281\n                                                                                                                  // 282\n// See: http://www.erg.abdn.ac.uk/~gerrit/dccp/notes/ccid2/rto_estimator/                                         // 283\n// and RFC 2988.                                                                                                  // 284\nutils.countRTO = function (rtt) {                                                                                 // 285\n    var rto;                                                                                                      // 286\n    if (rtt > 100) {                                                                                              // 287\n        rto = 3 * rtt; // rto > 300msec                                                                           // 288\n    } else {                                                                                                      // 289\n        rto = rtt + 200; // 200msec < rto <= 300msec                                                              // 290\n    }                                                                                                             // 291\n    return rto;                                                                                                   // 292\n}                                                                                                                 // 293\n                                                                                                                  // 294\nutils.log = function() {                                                                                          // 295\n    if (_window.console && console.log && console.log.apply) {                                                    // 296\n        console.log.apply(console, arguments);                                                                    // 297\n    }                                                                                                             // 298\n};                                                                                                                // 299\n                                                                                                                  // 300\nutils.bind = function(fun, that) {                                                                                // 301\n    if (fun.bind) {                                                                                               // 302\n        return fun.bind(that);                                                                                    // 303\n    } else {                                                                                                      // 304\n        return function() {                                                                                       // 305\n            return fun.apply(that, arguments);                                                                    // 306\n        };                                                                                                        // 307\n    }                                                                                                             // 308\n};                                                                                                                // 309\n                                                                                                                  // 310\nutils.flatUrl = function(url) {                                                                                   // 311\n    return url.indexOf('?') === -1 && url.indexOf('#') === -1;                                                    // 312\n};                                                                                                                // 313\n                                                                                                                  // 314\n// `relativeTo` is an optional absolute URL. If provided, `url` will be                                           // 315\n// interpreted relative to `relativeTo`. Defaults to `document.location`.                                         // 316\n// <METEOR>                                                                                                       // 317\nutils.amendUrl = function(url, relativeTo) {                                                                      // 318\n    var baseUrl;                                                                                                  // 319\n    if (relativeTo === undefined) {                                                                               // 320\n      baseUrl = _document.location;                                                                               // 321\n    } else {                                                                                                      // 322\n      var protocolMatch = /^([a-z0-9.+-]+:)/i.exec(relativeTo);                                                   // 323\n      if (protocolMatch) {                                                                                        // 324\n        var protocol = protocolMatch[0].toLowerCase();                                                            // 325\n        var rest = relativeTo.substring(protocol.length);                                                         // 326\n        var hostMatch = /[a-z0-9\\.-]+(:[0-9]+)?/.exec(rest);                                                      // 327\n        if (hostMatch)                                                                                            // 328\n          var host = hostMatch[0];                                                                                // 329\n      }                                                                                                           // 330\n      if (! protocol || ! host)                                                                                   // 331\n        throw new Error(\"relativeTo must be an absolute url\");                                                    // 332\n      baseUrl = {                                                                                                 // 333\n        protocol: protocol,                                                                                       // 334\n        host: host                                                                                                // 335\n      };                                                                                                          // 336\n    }                                                                                                             // 337\n    if (!url) {                                                                                                   // 338\n        throw new Error('Wrong url for SockJS');                                                                  // 339\n    }                                                                                                             // 340\n    if (!utils.flatUrl(url)) {                                                                                    // 341\n        throw new Error('Only basic urls are supported in SockJS');                                               // 342\n    }                                                                                                             // 343\n                                                                                                                  // 344\n    //  '//abc' --> 'http://abc'                                                                                  // 345\n    if (url.indexOf('//') === 0) {                                                                                // 346\n        url = baseUrl.protocol + url;                                                                             // 347\n    }                                                                                                             // 348\n    // '/abc' --> 'http://localhost:1234/abc'                                                                     // 349\n    if (url.indexOf('/') === 0) {                                                                                 // 350\n        url = baseUrl.protocol + '//' + baseUrl.host + url;                                                       // 351\n    }                                                                                                             // 352\n    // </METEOR>                                                                                                  // 353\n    // strip trailing slashes                                                                                     // 354\n    url = url.replace(/[/]+$/,'');                                                                                // 355\n                                                                                                                  // 356\n    // We have a full url here, with proto and host. For some browsers                                            // 357\n    // http://localhost:80/ is not in the same origin as http://localhost/                                        // 358\n\t// Remove explicit :80 or :443 in such cases. See #74                                                            // 359\n    var parts = url.split(\"/\");                                                                                   // 360\n    if ((parts[0] === \"http:\" && /:80$/.test(parts[2])) ||                                                        // 361\n\t    (parts[0] === \"https:\" && /:443$/.test(parts[2]))) {                                                         // 362\n\t\tparts[2] = parts[2].replace(/:(80|443)$/, \"\");                                                                  // 363\n\t}                                                                                                                // 364\n    url = parts.join(\"/\");                                                                                        // 365\n    return url;                                                                                                   // 366\n};                                                                                                                // 367\n                                                                                                                  // 368\n// IE doesn't support [].indexOf.                                                                                 // 369\nutils.arrIndexOf = function(arr, obj){                                                                            // 370\n    for(var i=0; i < arr.length; i++){                                                                            // 371\n        if(arr[i] === obj){                                                                                       // 372\n            return i;                                                                                             // 373\n        }                                                                                                         // 374\n    }                                                                                                             // 375\n    return -1;                                                                                                    // 376\n};                                                                                                                // 377\n                                                                                                                  // 378\nutils.arrSkip = function(arr, obj) {                                                                              // 379\n    var idx = utils.arrIndexOf(arr, obj);                                                                         // 380\n    if (idx === -1) {                                                                                             // 381\n        return arr.slice();                                                                                       // 382\n    } else {                                                                                                      // 383\n        var dst = arr.slice(0, idx);                                                                              // 384\n        return dst.concat(arr.slice(idx+1));                                                                      // 385\n    }                                                                                                             // 386\n};                                                                                                                // 387\n                                                                                                                  // 388\n// Via: https://gist.github.com/1133122/2121c601c5549155483f50be3da5305e83b8c5df                                  // 389\nutils.isArray = Array.isArray || function(value) {                                                                // 390\n    return {}.toString.call(value).indexOf('Array') >= 0                                                          // 391\n};                                                                                                                // 392\n                                                                                                                  // 393\nutils.delay = function(t, fun) {                                                                                  // 394\n    if(typeof t === 'function') {                                                                                 // 395\n        fun = t;                                                                                                  // 396\n        t = 0;                                                                                                    // 397\n    }                                                                                                             // 398\n    return setTimeout(fun, t);                                                                                    // 399\n};                                                                                                                // 400\n                                                                                                                  // 401\n                                                                                                                  // 402\n// Chars worth escaping, as defined by Douglas Crockford:                                                         // 403\n//   https://github.com/douglascrockford/JSON-js/blob/47a9882cddeb1e8529e07af9736218075372b8ac/json2.js#L196      // 404\nvar json_escapable = /[\\\\\\\"\\x00-\\x1f\\x7f-\\x9f\\u00ad\\u0600-\\u0604\\u070f\\u17b4\\u17b5\\u200c-\\u200f\\u2028-\\u202f\\u2060-\\u206f\\ufeff\\ufff0-\\uffff]/g,\n    json_lookup = {                                                                                               // 406\n\"\\u0000\":\"\\\\u0000\",\"\\u0001\":\"\\\\u0001\",\"\\u0002\":\"\\\\u0002\",\"\\u0003\":\"\\\\u0003\",                                      // 407\n\"\\u0004\":\"\\\\u0004\",\"\\u0005\":\"\\\\u0005\",\"\\u0006\":\"\\\\u0006\",\"\\u0007\":\"\\\\u0007\",                                      // 408\n\"\\b\":\"\\\\b\",\"\\t\":\"\\\\t\",\"\\n\":\"\\\\n\",\"\\u000b\":\"\\\\u000b\",\"\\f\":\"\\\\f\",\"\\r\":\"\\\\r\",                                        // 409\n\"\\u000e\":\"\\\\u000e\",\"\\u000f\":\"\\\\u000f\",\"\\u0010\":\"\\\\u0010\",\"\\u0011\":\"\\\\u0011\",                                      // 410\n\"\\u0012\":\"\\\\u0012\",\"\\u0013\":\"\\\\u0013\",\"\\u0014\":\"\\\\u0014\",\"\\u0015\":\"\\\\u0015\",                                      // 411\n\"\\u0016\":\"\\\\u0016\",\"\\u0017\":\"\\\\u0017\",\"\\u0018\":\"\\\\u0018\",\"\\u0019\":\"\\\\u0019\",                                      // 412\n\"\\u001a\":\"\\\\u001a\",\"\\u001b\":\"\\\\u001b\",\"\\u001c\":\"\\\\u001c\",\"\\u001d\":\"\\\\u001d\",                                      // 413\n\"\\u001e\":\"\\\\u001e\",\"\\u001f\":\"\\\\u001f\",\"\\\"\":\"\\\\\\\"\",\"\\\\\":\"\\\\\\\\\",                                                    // 414\n\"\\u007f\":\"\\\\u007f\",\"\\u0080\":\"\\\\u0080\",\"\\u0081\":\"\\\\u0081\",\"\\u0082\":\"\\\\u0082\",                                      // 415\n\"\\u0083\":\"\\\\u0083\",\"\\u0084\":\"\\\\u0084\",\"\\u0085\":\"\\\\u0085\",\"\\u0086\":\"\\\\u0086\",                                      // 416\n\"\\u0087\":\"\\\\u0087\",\"\\u0088\":\"\\\\u0088\",\"\\u0089\":\"\\\\u0089\",\"\\u008a\":\"\\\\u008a\",                                      // 417\n\"\\u008b\":\"\\\\u008b\",\"\\u008c\":\"\\\\u008c\",\"\\u008d\":\"\\\\u008d\",\"\\u008e\":\"\\\\u008e\",                                      // 418\n\"\\u008f\":\"\\\\u008f\",\"\\u0090\":\"\\\\u0090\",\"\\u0091\":\"\\\\u0091\",\"\\u0092\":\"\\\\u0092\",                                      // 419\n\"\\u0093\":\"\\\\u0093\",\"\\u0094\":\"\\\\u0094\",\"\\u0095\":\"\\\\u0095\",\"\\u0096\":\"\\\\u0096\",                                      // 420\n\"\\u0097\":\"\\\\u0097\",\"\\u0098\":\"\\\\u0098\",\"\\u0099\":\"\\\\u0099\",\"\\u009a\":\"\\\\u009a\",                                      // 421\n\"\\u009b\":\"\\\\u009b\",\"\\u009c\":\"\\\\u009c\",\"\\u009d\":\"\\\\u009d\",\"\\u009e\":\"\\\\u009e\",                                      // 422\n\"\\u009f\":\"\\\\u009f\",\"\\u00ad\":\"\\\\u00ad\",\"\\u0600\":\"\\\\u0600\",\"\\u0601\":\"\\\\u0601\",                                      // 423\n\"\\u0602\":\"\\\\u0602\",\"\\u0603\":\"\\\\u0603\",\"\\u0604\":\"\\\\u0604\",\"\\u070f\":\"\\\\u070f\",                                      // 424\n\"\\u17b4\":\"\\\\u17b4\",\"\\u17b5\":\"\\\\u17b5\",\"\\u200c\":\"\\\\u200c\",\"\\u200d\":\"\\\\u200d\",                                      // 425\n\"\\u200e\":\"\\\\u200e\",\"\\u200f\":\"\\\\u200f\",\"\\u2028\":\"\\\\u2028\",\"\\u2029\":\"\\\\u2029\",                                      // 426\n\"\\u202a\":\"\\\\u202a\",\"\\u202b\":\"\\\\u202b\",\"\\u202c\":\"\\\\u202c\",\"\\u202d\":\"\\\\u202d\",                                      // 427\n\"\\u202e\":\"\\\\u202e\",\"\\u202f\":\"\\\\u202f\",\"\\u2060\":\"\\\\u2060\",\"\\u2061\":\"\\\\u2061\",                                      // 428\n\"\\u2062\":\"\\\\u2062\",\"\\u2063\":\"\\\\u2063\",\"\\u2064\":\"\\\\u2064\",\"\\u2065\":\"\\\\u2065\",                                      // 429\n\"\\u2066\":\"\\\\u2066\",\"\\u2067\":\"\\\\u2067\",\"\\u2068\":\"\\\\u2068\",\"\\u2069\":\"\\\\u2069\",                                      // 430\n\"\\u206a\":\"\\\\u206a\",\"\\u206b\":\"\\\\u206b\",\"\\u206c\":\"\\\\u206c\",\"\\u206d\":\"\\\\u206d\",                                      // 431\n\"\\u206e\":\"\\\\u206e\",\"\\u206f\":\"\\\\u206f\",\"\\ufeff\":\"\\\\ufeff\",\"\\ufff0\":\"\\\\ufff0\",                                      // 432\n\"\\ufff1\":\"\\\\ufff1\",\"\\ufff2\":\"\\\\ufff2\",\"\\ufff3\":\"\\\\ufff3\",\"\\ufff4\":\"\\\\ufff4\",                                      // 433\n\"\\ufff5\":\"\\\\ufff5\",\"\\ufff6\":\"\\\\ufff6\",\"\\ufff7\":\"\\\\ufff7\",\"\\ufff8\":\"\\\\ufff8\",                                      // 434\n\"\\ufff9\":\"\\\\ufff9\",\"\\ufffa\":\"\\\\ufffa\",\"\\ufffb\":\"\\\\ufffb\",\"\\ufffc\":\"\\\\ufffc\",                                      // 435\n\"\\ufffd\":\"\\\\ufffd\",\"\\ufffe\":\"\\\\ufffe\",\"\\uffff\":\"\\\\uffff\"};                                                        // 436\n                                                                                                                  // 437\n// Some extra characters that Chrome gets wrong, and substitutes with                                             // 438\n// something else on the wire.                                                                                    // 439\nvar extra_escapable = /[\\x00-\\x1f\\ud800-\\udfff\\ufffe\\uffff\\u0300-\\u0333\\u033d-\\u0346\\u034a-\\u034c\\u0350-\\u0352\\u0357-\\u0358\\u035c-\\u0362\\u0374\\u037e\\u0387\\u0591-\\u05af\\u05c4\\u0610-\\u0617\\u0653-\\u0654\\u0657-\\u065b\\u065d-\\u065e\\u06df-\\u06e2\\u06eb-\\u06ec\\u0730\\u0732-\\u0733\\u0735-\\u0736\\u073a\\u073d\\u073f-\\u0741\\u0743\\u0745\\u0747\\u07eb-\\u07f1\\u0951\\u0958-\\u095f\\u09dc-\\u09dd\\u09df\\u0a33\\u0a36\\u0a59-\\u0a5b\\u0a5e\\u0b5c-\\u0b5d\\u0e38-\\u0e39\\u0f43\\u0f4d\\u0f52\\u0f57\\u0f5c\\u0f69\\u0f72-\\u0f76\\u0f78\\u0f80-\\u0f83\\u0f93\\u0f9d\\u0fa2\\u0fa7\\u0fac\\u0fb9\\u1939-\\u193a\\u1a17\\u1b6b\\u1cda-\\u1cdb\\u1dc0-\\u1dcf\\u1dfc\\u1dfe\\u1f71\\u1f73\\u1f75\\u1f77\\u1f79\\u1f7b\\u1f7d\\u1fbb\\u1fbe\\u1fc9\\u1fcb\\u1fd3\\u1fdb\\u1fe3\\u1feb\\u1fee-\\u1fef\\u1ff9\\u1ffb\\u1ffd\\u2000-\\u2001\\u20d0-\\u20d1\\u20d4-\\u20d7\\u20e7-\\u20e9\\u2126\\u212a-\\u212b\\u2329-\\u232a\\u2adc\\u302b-\\u302c\\uaab2-\\uaab3\\uf900-\\ufa0d\\ufa10\\ufa12\\ufa15-\\ufa1e\\ufa20\\ufa22\\ufa25-\\ufa26\\ufa2a-\\ufa2d\\ufa30-\\ufa6d\\ufa70-\\ufad9\\ufb1d\\ufb1f\\ufb2a-\\ufb36\\ufb38-\\ufb3c\\ufb3e\\ufb40-\\ufb41\\ufb43-\\ufb44\\ufb46-\\ufb4e\\ufff0-\\uffff]/g,\n    extra_lookup;                                                                                                 // 441\n                                                                                                                  // 442\n// JSON Quote string. Use native implementation when possible.                                                    // 443\nvar JSONQuote = (JSON && JSON.stringify) || function(string) {                                                    // 444\n    json_escapable.lastIndex = 0;                                                                                 // 445\n    if (json_escapable.test(string)) {                                                                            // 446\n        string = string.replace(json_escapable, function(a) {                                                     // 447\n            return json_lookup[a];                                                                                // 448\n        });                                                                                                       // 449\n    }                                                                                                             // 450\n    return '\"' + string + '\"';                                                                                    // 451\n};                                                                                                                // 452\n                                                                                                                  // 453\n// This may be quite slow, so let's delay until user actually uses bad                                            // 454\n// characters.                                                                                                    // 455\nvar unroll_lookup = function(escapable) {                                                                         // 456\n    var i;                                                                                                        // 457\n    var unrolled = {}                                                                                             // 458\n    var c = []                                                                                                    // 459\n    for(i=0; i<65536; i++) {                                                                                      // 460\n        c.push( String.fromCharCode(i) );                                                                         // 461\n    }                                                                                                             // 462\n    escapable.lastIndex = 0;                                                                                      // 463\n    c.join('').replace(escapable, function (a) {                                                                  // 464\n        unrolled[ a ] = '\\\\u' + ('0000' + a.charCodeAt(0).toString(16)).slice(-4);                                // 465\n        return '';                                                                                                // 466\n    });                                                                                                           // 467\n    escapable.lastIndex = 0;                                                                                      // 468\n    return unrolled;                                                                                              // 469\n};                                                                                                                // 470\n                                                                                                                  // 471\n// Quote string, also taking care of unicode characters that browsers                                             // 472\n// often break. Especially, take care of unicode surrogates:                                                      // 473\n//    http://en.wikipedia.org/wiki/Mapping_of_Unicode_characters#Surrogates                                       // 474\nutils.quote = function(string) {                                                                                  // 475\n    var quoted = JSONQuote(string);                                                                               // 476\n                                                                                                                  // 477\n    // In most cases this should be very fast and good enough.                                                    // 478\n    extra_escapable.lastIndex = 0;                                                                                // 479\n    if(!extra_escapable.test(quoted)) {                                                                           // 480\n        return quoted;                                                                                            // 481\n    }                                                                                                             // 482\n                                                                                                                  // 483\n    if(!extra_lookup) extra_lookup = unroll_lookup(extra_escapable);                                              // 484\n                                                                                                                  // 485\n    return quoted.replace(extra_escapable, function(a) {                                                          // 486\n        return extra_lookup[a];                                                                                   // 487\n    });                                                                                                           // 488\n}                                                                                                                 // 489\n                                                                                                                  // 490\nvar _all_protocols = ['websocket',                                                                                // 491\n                      'xdr-streaming',                                                                            // 492\n                      'xhr-streaming',                                                                            // 493\n                      'iframe-eventsource',                                                                       // 494\n                      'iframe-htmlfile',                                                                          // 495\n                      'xdr-polling',                                                                              // 496\n                      'xhr-polling',                                                                              // 497\n                      'iframe-xhr-polling',                                                                       // 498\n                      'jsonp-polling'];                                                                           // 499\n                                                                                                                  // 500\nutils.probeProtocols = function() {                                                                               // 501\n    var probed = {};                                                                                              // 502\n    for(var i=0; i<_all_protocols.length; i++) {                                                                  // 503\n        var protocol = _all_protocols[i];                                                                         // 504\n        // User can have a typo in protocol name.                                                                 // 505\n        probed[protocol] = SockJS[protocol] &&                                                                    // 506\n                           SockJS[protocol].enabled();                                                            // 507\n    }                                                                                                             // 508\n    return probed;                                                                                                // 509\n};                                                                                                                // 510\n                                                                                                                  // 511\nutils.detectProtocols = function(probed, protocols_whitelist, info) {                                             // 512\n    var pe = {},                                                                                                  // 513\n        protocols = [];                                                                                           // 514\n    if (!protocols_whitelist) protocols_whitelist = _all_protocols;                                               // 515\n    for(var i=0; i<protocols_whitelist.length; i++) {                                                             // 516\n        var protocol = protocols_whitelist[i];                                                                    // 517\n        pe[protocol] = probed[protocol];                                                                          // 518\n    }                                                                                                             // 519\n    var maybe_push = function(protos) {                                                                           // 520\n        var proto = protos.shift();                                                                               // 521\n        if (pe[proto]) {                                                                                          // 522\n            protocols.push(proto);                                                                                // 523\n        } else {                                                                                                  // 524\n            if (protos.length > 0) {                                                                              // 525\n                maybe_push(protos);                                                                               // 526\n            }                                                                                                     // 527\n        }                                                                                                         // 528\n    }                                                                                                             // 529\n                                                                                                                  // 530\n    // 1. Websocket                                                                                               // 531\n    if (info.websocket !== false) {                                                                               // 532\n        maybe_push(['websocket']);                                                                                // 533\n    }                                                                                                             // 534\n                                                                                                                  // 535\n    // 2. Streaming                                                                                               // 536\n    if (pe['xhr-streaming'] && !info.null_origin) {                                                               // 537\n        protocols.push('xhr-streaming');                                                                          // 538\n    } else {                                                                                                      // 539\n        if (pe['xdr-streaming'] && !info.cookie_needed && !info.null_origin) {                                    // 540\n            protocols.push('xdr-streaming');                                                                      // 541\n        } else {                                                                                                  // 542\n            maybe_push(['iframe-eventsource',                                                                     // 543\n                        'iframe-htmlfile']);                                                                      // 544\n        }                                                                                                         // 545\n    }                                                                                                             // 546\n                                                                                                                  // 547\n    // 3. Polling                                                                                                 // 548\n    if (pe['xhr-polling'] && !info.null_origin) {                                                                 // 549\n        protocols.push('xhr-polling');                                                                            // 550\n    } else {                                                                                                      // 551\n        if (pe['xdr-polling'] && !info.cookie_needed && !info.null_origin) {                                      // 552\n            protocols.push('xdr-polling');                                                                        // 553\n        } else {                                                                                                  // 554\n            maybe_push(['iframe-xhr-polling',                                                                     // 555\n                        'jsonp-polling']);                                                                        // 556\n        }                                                                                                         // 557\n    }                                                                                                             // 558\n    return protocols;                                                                                             // 559\n}                                                                                                                 // 560\n//         [*] End of lib/utils.js                                                                                // 561\n                                                                                                                  // 562\n                                                                                                                  // 563\n//         [*] Including lib/dom.js                                                                               // 564\n/*                                                                                                                // 565\n * ***** BEGIN LICENSE BLOCK *****                                                                                // 566\n * Copyright (c) 2011-2012 VMware, Inc.                                                                           // 567\n *                                                                                                                // 568\n * For the license see COPYING.                                                                                   // 569\n * ***** END LICENSE BLOCK *****                                                                                  // 570\n */                                                                                                               // 571\n                                                                                                                  // 572\n// May be used by htmlfile jsonp and transports.                                                                  // 573\nvar MPrefix = '_sockjs_global';                                                                                   // 574\nutils.createHook = function() {                                                                                   // 575\n    var window_id = 'a' + utils.random_string(8);                                                                 // 576\n    if (!(MPrefix in _window)) {                                                                                  // 577\n        var map = {};                                                                                             // 578\n        _window[MPrefix] = function(window_id) {                                                                  // 579\n            if (!(window_id in map)) {                                                                            // 580\n                map[window_id] = {                                                                                // 581\n                    id: window_id,                                                                                // 582\n                    del: function() {delete map[window_id];}                                                      // 583\n                };                                                                                                // 584\n            }                                                                                                     // 585\n            return map[window_id];                                                                                // 586\n        }                                                                                                         // 587\n    }                                                                                                             // 588\n    return _window[MPrefix](window_id);                                                                           // 589\n};                                                                                                                // 590\n                                                                                                                  // 591\n                                                                                                                  // 592\n                                                                                                                  // 593\nutils.attachMessage = function(listener) {                                                                        // 594\n    utils.attachEvent('message', listener);                                                                       // 595\n};                                                                                                                // 596\nutils.attachEvent = function(event, listener) {                                                                   // 597\n    if (typeof _window.addEventListener !== 'undefined') {                                                        // 598\n        _window.addEventListener(event, listener, false);                                                         // 599\n    } else {                                                                                                      // 600\n        // IE quirks.                                                                                             // 601\n        // According to: http://stevesouders.com/misc/test-postmessage.php                                        // 602\n        // the message gets delivered only to 'document', not 'window'.                                           // 603\n        _document.attachEvent(\"on\" + event, listener);                                                            // 604\n        // I get 'window' for ie8.                                                                                // 605\n        _window.attachEvent(\"on\" + event, listener);                                                              // 606\n    }                                                                                                             // 607\n};                                                                                                                // 608\n                                                                                                                  // 609\nutils.detachMessage = function(listener) {                                                                        // 610\n    utils.detachEvent('message', listener);                                                                       // 611\n};                                                                                                                // 612\nutils.detachEvent = function(event, listener) {                                                                   // 613\n    if (typeof _window.addEventListener !== 'undefined') {                                                        // 614\n        _window.removeEventListener(event, listener, false);                                                      // 615\n    } else {                                                                                                      // 616\n        _document.detachEvent(\"on\" + event, listener);                                                            // 617\n        _window.detachEvent(\"on\" + event, listener);                                                              // 618\n    }                                                                                                             // 619\n};                                                                                                                // 620\n                                                                                                                  // 621\n                                                                                                                  // 622\nvar on_unload = {};                                                                                               // 623\n// Things registered after beforeunload are to be called immediately.                                             // 624\nvar after_unload = false;                                                                                         // 625\n                                                                                                                  // 626\nvar trigger_unload_callbacks = function() {                                                                       // 627\n    for(var ref in on_unload) {                                                                                   // 628\n        on_unload[ref]();                                                                                         // 629\n        delete on_unload[ref];                                                                                    // 630\n    };                                                                                                            // 631\n};                                                                                                                // 632\n                                                                                                                  // 633\nvar unload_triggered = function() {                                                                               // 634\n    if(after_unload) return;                                                                                      // 635\n    after_unload = true;                                                                                          // 636\n    trigger_unload_callbacks();                                                                                   // 637\n};                                                                                                                // 638\n                                                                                                                  // 639\n// 'unload' alone is not reliable in opera within an iframe, but we                                               // 640\n// can't use `beforeunload` as IE fires it on javascript: links.                                                  // 641\nutils.attachEvent('unload', unload_triggered);                                                                    // 642\n                                                                                                                  // 643\nutils.unload_add = function(listener) {                                                                           // 644\n    var ref = utils.random_string(8);                                                                             // 645\n    on_unload[ref] = listener;                                                                                    // 646\n    if (after_unload) {                                                                                           // 647\n        utils.delay(trigger_unload_callbacks);                                                                    // 648\n    }                                                                                                             // 649\n    return ref;                                                                                                   // 650\n};                                                                                                                // 651\nutils.unload_del = function(ref) {                                                                                // 652\n    if (ref in on_unload)                                                                                         // 653\n        delete on_unload[ref];                                                                                    // 654\n};                                                                                                                // 655\n                                                                                                                  // 656\n                                                                                                                  // 657\nutils.createIframe = function (iframe_url, error_callback) {                                                      // 658\n    var iframe = _document.createElement('iframe');                                                               // 659\n    var tref, unload_ref;                                                                                         // 660\n    var unattach = function() {                                                                                   // 661\n        clearTimeout(tref);                                                                                       // 662\n        // Explorer had problems with that.                                                                       // 663\n        try {iframe.onload = null;} catch (x) {}                                                                  // 664\n        iframe.onerror = null;                                                                                    // 665\n    };                                                                                                            // 666\n    var cleanup = function() {                                                                                    // 667\n        if (iframe) {                                                                                             // 668\n            unattach();                                                                                           // 669\n            // This timeout makes chrome fire onbeforeunload event                                                // 670\n            // within iframe. Without the timeout it goes straight to                                             // 671\n            // onunload.                                                                                          // 672\n            setTimeout(function() {                                                                               // 673\n                if(iframe) {                                                                                      // 674\n                    iframe.parentNode.removeChild(iframe);                                                        // 675\n                }                                                                                                 // 676\n                iframe = null;                                                                                    // 677\n            }, 0);                                                                                                // 678\n            utils.unload_del(unload_ref);                                                                         // 679\n        }                                                                                                         // 680\n    };                                                                                                            // 681\n    var onerror = function(r) {                                                                                   // 682\n        if (iframe) {                                                                                             // 683\n            cleanup();                                                                                            // 684\n            error_callback(r);                                                                                    // 685\n        }                                                                                                         // 686\n    };                                                                                                            // 687\n    var post = function(msg, origin) {                                                                            // 688\n        try {                                                                                                     // 689\n            // When the iframe is not loaded, IE raises an exception                                              // 690\n            // on 'contentWindow'.                                                                                // 691\n            if (iframe && iframe.contentWindow) {                                                                 // 692\n                iframe.contentWindow.postMessage(msg, origin);                                                    // 693\n            }                                                                                                     // 694\n        } catch (x) {};                                                                                           // 695\n    };                                                                                                            // 696\n                                                                                                                  // 697\n    iframe.src = iframe_url;                                                                                      // 698\n    iframe.style.display = 'none';                                                                                // 699\n    iframe.style.position = 'absolute';                                                                           // 700\n    iframe.onerror = function(){onerror('onerror');};                                                             // 701\n    iframe.onload = function() {                                                                                  // 702\n        // `onload` is triggered before scripts on the iframe are                                                 // 703\n        // executed. Give it few seconds to actually load stuff.                                                  // 704\n        clearTimeout(tref);                                                                                       // 705\n        tref = setTimeout(function(){onerror('onload timeout');}, 2000);                                          // 706\n    };                                                                                                            // 707\n    _document.body.appendChild(iframe);                                                                           // 708\n    tref = setTimeout(function(){onerror('timeout');}, 15000);                                                    // 709\n    unload_ref = utils.unload_add(cleanup);                                                                       // 710\n    return {                                                                                                      // 711\n        post: post,                                                                                               // 712\n        cleanup: cleanup,                                                                                         // 713\n        loaded: unattach                                                                                          // 714\n    };                                                                                                            // 715\n};                                                                                                                // 716\n                                                                                                                  // 717\nutils.createHtmlfile = function (iframe_url, error_callback) {                                                    // 718\n    var doc = new ActiveXObject('htmlfile');                                                                      // 719\n    var tref, unload_ref;                                                                                         // 720\n    var iframe;                                                                                                   // 721\n    var unattach = function() {                                                                                   // 722\n        clearTimeout(tref);                                                                                       // 723\n    };                                                                                                            // 724\n    var cleanup = function() {                                                                                    // 725\n        if (doc) {                                                                                                // 726\n            unattach();                                                                                           // 727\n            utils.unload_del(unload_ref);                                                                         // 728\n            iframe.parentNode.removeChild(iframe);                                                                // 729\n            iframe = doc = null;                                                                                  // 730\n            CollectGarbage();                                                                                     // 731\n        }                                                                                                         // 732\n    };                                                                                                            // 733\n    var onerror = function(r)  {                                                                                  // 734\n        if (doc) {                                                                                                // 735\n            cleanup();                                                                                            // 736\n            error_callback(r);                                                                                    // 737\n        }                                                                                                         // 738\n    };                                                                                                            // 739\n    var post = function(msg, origin) {                                                                            // 740\n        try {                                                                                                     // 741\n            // When the iframe is not loaded, IE raises an exception                                              // 742\n            // on 'contentWindow'.                                                                                // 743\n            if (iframe && iframe.contentWindow) {                                                                 // 744\n                iframe.contentWindow.postMessage(msg, origin);                                                    // 745\n            }                                                                                                     // 746\n        } catch (x) {};                                                                                           // 747\n    };                                                                                                            // 748\n                                                                                                                  // 749\n    doc.open();                                                                                                   // 750\n    doc.write('<html><s' + 'cript>' +                                                                             // 751\n              'document.domain=\"' + document.domain + '\";' +                                                      // 752\n              '</s' + 'cript></html>');                                                                           // 753\n    doc.close();                                                                                                  // 754\n    doc.parentWindow[WPrefix] = _window[WPrefix];                                                                 // 755\n    var c = doc.createElement('div');                                                                             // 756\n    doc.body.appendChild(c);                                                                                      // 757\n    iframe = doc.createElement('iframe');                                                                         // 758\n    c.appendChild(iframe);                                                                                        // 759\n    iframe.src = iframe_url;                                                                                      // 760\n    tref = setTimeout(function(){onerror('timeout');}, 15000);                                                    // 761\n    unload_ref = utils.unload_add(cleanup);                                                                       // 762\n    return {                                                                                                      // 763\n        post: post,                                                                                               // 764\n        cleanup: cleanup,                                                                                         // 765\n        loaded: unattach                                                                                          // 766\n    };                                                                                                            // 767\n};                                                                                                                // 768\n//         [*] End of lib/dom.js                                                                                  // 769\n                                                                                                                  // 770\n                                                                                                                  // 771\n//         [*] Including lib/dom2.js                                                                              // 772\n/*                                                                                                                // 773\n * ***** BEGIN LICENSE BLOCK *****                                                                                // 774\n * Copyright (c) 2011-2012 VMware, Inc.                                                                           // 775\n *                                                                                                                // 776\n * For the license see COPYING.                                                                                   // 777\n * ***** END LICENSE BLOCK *****                                                                                  // 778\n */                                                                                                               // 779\n                                                                                                                  // 780\nvar AbstractXHRObject = function(){};                                                                             // 781\nAbstractXHRObject.prototype = new EventEmitter(['chunk', 'finish']);                                              // 782\n                                                                                                                  // 783\nAbstractXHRObject.prototype._start = function(method, url, payload, opts) {                                       // 784\n    var that = this;                                                                                              // 785\n                                                                                                                  // 786\n    try {                                                                                                         // 787\n        that.xhr = new XMLHttpRequest();                                                                          // 788\n    } catch(x) {};                                                                                                // 789\n                                                                                                                  // 790\n    if (!that.xhr) {                                                                                              // 791\n        try {                                                                                                     // 792\n            that.xhr = new _window.ActiveXObject('Microsoft.XMLHTTP');                                            // 793\n        } catch(x) {};                                                                                            // 794\n    }                                                                                                             // 795\n    if (_window.ActiveXObject || _window.XDomainRequest) {                                                        // 796\n        // IE8 caches even POSTs                                                                                  // 797\n        url += ((url.indexOf('?') === -1) ? '?' : '&') + 't='+(+new Date);                                        // 798\n    }                                                                                                             // 799\n                                                                                                                  // 800\n    // Explorer tends to keep connection open, even after the                                                     // 801\n    // tab gets closed: http://bugs.jquery.com/ticket/5280                                                        // 802\n    that.unload_ref = utils.unload_add(function(){that._cleanup(true);});                                         // 803\n    try {                                                                                                         // 804\n        that.xhr.open(method, url, true);                                                                         // 805\n    } catch(e) {                                                                                                  // 806\n        // IE raises an exception on wrong port.                                                                  // 807\n        that.emit('finish', 0, '');                                                                               // 808\n        that._cleanup();                                                                                          // 809\n        return;                                                                                                   // 810\n    };                                                                                                            // 811\n                                                                                                                  // 812\n    if (!opts || !opts.no_credentials) {                                                                          // 813\n        // Mozilla docs says https://developer.mozilla.org/en/XMLHttpRequest :                                    // 814\n        // \"This never affects same-site requests.\"                                                               // 815\n        that.xhr.withCredentials = 'true';                                                                        // 816\n    }                                                                                                             // 817\n    if (opts && opts.headers) {                                                                                   // 818\n        for(var key in opts.headers) {                                                                            // 819\n            that.xhr.setRequestHeader(key, opts.headers[key]);                                                    // 820\n        }                                                                                                         // 821\n    }                                                                                                             // 822\n                                                                                                                  // 823\n    that.xhr.onreadystatechange = function() {                                                                    // 824\n        if (that.xhr) {                                                                                           // 825\n            var x = that.xhr;                                                                                     // 826\n            switch (x.readyState) {                                                                               // 827\n            case 3:                                                                                               // 828\n                // IE doesn't like peeking into responseText or status                                            // 829\n                // on Microsoft.XMLHTTP and readystate=3                                                          // 830\n                try {                                                                                             // 831\n                    var status = x.status;                                                                        // 832\n                    var text = x.responseText;                                                                    // 833\n                } catch (x) {};                                                                                   // 834\n                // IE returns 1223 for 204: http://bugs.jquery.com/ticket/1450                                    // 835\n                if (status === 1223) status = 204;                                                                // 836\n                                                                                                                  // 837\n                // IE does return readystate == 3 for 404 answers.                                                // 838\n                if (text && text.length > 0) {                                                                    // 839\n                    that.emit('chunk', status, text);                                                             // 840\n                }                                                                                                 // 841\n                break;                                                                                            // 842\n            case 4:                                                                                               // 843\n                var status = x.status;                                                                            // 844\n                // IE returns 1223 for 204: http://bugs.jquery.com/ticket/1450                                    // 845\n                if (status === 1223) status = 204;                                                                // 846\n                                                                                                                  // 847\n                that.emit('finish', status, x.responseText);                                                      // 848\n                that._cleanup(false);                                                                             // 849\n                break;                                                                                            // 850\n            }                                                                                                     // 851\n        }                                                                                                         // 852\n    };                                                                                                            // 853\n    that.xhr.send(payload);                                                                                       // 854\n};                                                                                                                // 855\n                                                                                                                  // 856\nAbstractXHRObject.prototype._cleanup = function(abort) {                                                          // 857\n    var that = this;                                                                                              // 858\n    if (!that.xhr) return;                                                                                        // 859\n    utils.unload_del(that.unload_ref);                                                                            // 860\n                                                                                                                  // 861\n    // IE needs this field to be a function                                                                       // 862\n    that.xhr.onreadystatechange = function(){};                                                                   // 863\n                                                                                                                  // 864\n    if (abort) {                                                                                                  // 865\n        try {                                                                                                     // 866\n            that.xhr.abort();                                                                                     // 867\n        } catch(x) {};                                                                                            // 868\n    }                                                                                                             // 869\n    that.unload_ref = that.xhr = null;                                                                            // 870\n};                                                                                                                // 871\n                                                                                                                  // 872\nAbstractXHRObject.prototype.close = function() {                                                                  // 873\n    var that = this;                                                                                              // 874\n    that.nuke();                                                                                                  // 875\n    that._cleanup(true);                                                                                          // 876\n};                                                                                                                // 877\n                                                                                                                  // 878\nvar XHRCorsObject = utils.XHRCorsObject = function() {                                                            // 879\n    var that = this, args = arguments;                                                                            // 880\n    utils.delay(function(){that._start.apply(that, args);});                                                      // 881\n};                                                                                                                // 882\nXHRCorsObject.prototype = new AbstractXHRObject();                                                                // 883\n                                                                                                                  // 884\nvar XHRLocalObject = utils.XHRLocalObject = function(method, url, payload) {                                      // 885\n    var that = this;                                                                                              // 886\n    utils.delay(function(){                                                                                       // 887\n        that._start(method, url, payload, {                                                                       // 888\n            no_credentials: true                                                                                  // 889\n        });                                                                                                       // 890\n    });                                                                                                           // 891\n};                                                                                                                // 892\nXHRLocalObject.prototype = new AbstractXHRObject();                                                               // 893\n                                                                                                                  // 894\n                                                                                                                  // 895\n                                                                                                                  // 896\n// References:                                                                                                    // 897\n//   http://ajaxian.com/archives/100-line-ajax-wrapper                                                            // 898\n//   http://msdn.microsoft.com/en-us/library/cc288060(v=VS.85).aspx                                               // 899\nvar XDRObject = utils.XDRObject = function(method, url, payload) {                                                // 900\n    var that = this;                                                                                              // 901\n    utils.delay(function(){that._start(method, url, payload);});                                                  // 902\n};                                                                                                                // 903\nXDRObject.prototype = new EventEmitter(['chunk', 'finish']);                                                      // 904\nXDRObject.prototype._start = function(method, url, payload) {                                                     // 905\n    var that = this;                                                                                              // 906\n    var xdr = new XDomainRequest();                                                                               // 907\n    // IE caches even POSTs                                                                                       // 908\n    url += ((url.indexOf('?') === -1) ? '?' : '&') + 't='+(+new Date);                                            // 909\n                                                                                                                  // 910\n    var onerror = xdr.ontimeout = xdr.onerror = function() {                                                      // 911\n        that.emit('finish', 0, '');                                                                               // 912\n        that._cleanup(false);                                                                                     // 913\n    };                                                                                                            // 914\n    xdr.onprogress = function() {                                                                                 // 915\n        that.emit('chunk', 200, xdr.responseText);                                                                // 916\n    };                                                                                                            // 917\n    xdr.onload = function() {                                                                                     // 918\n        that.emit('finish', 200, xdr.responseText);                                                               // 919\n        that._cleanup(false);                                                                                     // 920\n    };                                                                                                            // 921\n    that.xdr = xdr;                                                                                               // 922\n    that.unload_ref = utils.unload_add(function(){that._cleanup(true);});                                         // 923\n    try {                                                                                                         // 924\n        // Fails with AccessDenied if port number is bogus                                                        // 925\n        that.xdr.open(method, url);                                                                               // 926\n        that.xdr.send(payload);                                                                                   // 927\n    } catch(x) {                                                                                                  // 928\n        onerror();                                                                                                // 929\n    }                                                                                                             // 930\n};                                                                                                                // 931\n                                                                                                                  // 932\nXDRObject.prototype._cleanup = function(abort) {                                                                  // 933\n    var that = this;                                                                                              // 934\n    if (!that.xdr) return;                                                                                        // 935\n    utils.unload_del(that.unload_ref);                                                                            // 936\n                                                                                                                  // 937\n    that.xdr.ontimeout = that.xdr.onerror = that.xdr.onprogress =                                                 // 938\n        that.xdr.onload = null;                                                                                   // 939\n    if (abort) {                                                                                                  // 940\n        try {                                                                                                     // 941\n            that.xdr.abort();                                                                                     // 942\n        } catch(x) {};                                                                                            // 943\n    }                                                                                                             // 944\n    that.unload_ref = that.xdr = null;                                                                            // 945\n};                                                                                                                // 946\n                                                                                                                  // 947\nXDRObject.prototype.close = function() {                                                                          // 948\n    var that = this;                                                                                              // 949\n    that.nuke();                                                                                                  // 950\n    that._cleanup(true);                                                                                          // 951\n};                                                                                                                // 952\n                                                                                                                  // 953\n// 1. Is natively via XHR                                                                                         // 954\n// 2. Is natively via XDR                                                                                         // 955\n// 3. Nope, but postMessage is there so it should work via the Iframe.                                            // 956\n// 4. Nope, sorry.                                                                                                // 957\nutils.isXHRCorsCapable = function() {                                                                             // 958\n    if (_window.XMLHttpRequest && 'withCredentials' in new XMLHttpRequest()) {                                    // 959\n        return 1;                                                                                                 // 960\n    }                                                                                                             // 961\n    // XDomainRequest doesn't work if page is served from file://                                                 // 962\n    if (_window.XDomainRequest && _document.domain) {                                                             // 963\n        return 2;                                                                                                 // 964\n    }                                                                                                             // 965\n    if (IframeTransport.enabled()) {                                                                              // 966\n        return 3;                                                                                                 // 967\n    }                                                                                                             // 968\n    return 4;                                                                                                     // 969\n};                                                                                                                // 970\n//         [*] End of lib/dom2.js                                                                                 // 971\n                                                                                                                  // 972\n                                                                                                                  // 973\n//         [*] Including lib/sockjs.js                                                                            // 974\n/*                                                                                                                // 975\n * ***** BEGIN LICENSE BLOCK *****                                                                                // 976\n * Copyright (c) 2011-2012 VMware, Inc.                                                                           // 977\n *                                                                                                                // 978\n * For the license see COPYING.                                                                                   // 979\n * ***** END LICENSE BLOCK *****                                                                                  // 980\n */                                                                                                               // 981\n                                                                                                                  // 982\nvar SockJS = function(url, dep_protocols_whitelist, options) {                                                    // 983\n    if (!(this instanceof SockJS)) {                                                                              // 984\n        // makes `new` optional                                                                                   // 985\n        return new SockJS(url, dep_protocols_whitelist, options);                                                 // 986\n    }                                                                                                             // 987\n                                                                                                                  // 988\n    var that = this, protocols_whitelist;                                                                         // 989\n    that._options = {devel: false, debug: false, protocols_whitelist: [],                                         // 990\n                     info: undefined, rtt: undefined};                                                            // 991\n    if (options) {                                                                                                // 992\n        utils.objectExtend(that._options, options);                                                               // 993\n    }                                                                                                             // 994\n    that._base_url = utils.amendUrl(url);                                                                         // 995\n    that._server = that._options.server || utils.random_number_string(1000);                                      // 996\n    if (that._options.protocols_whitelist &&                                                                      // 997\n        that._options.protocols_whitelist.length) {                                                               // 998\n        protocols_whitelist = that._options.protocols_whitelist;                                                  // 999\n    } else {                                                                                                      // 1000\n        // Deprecated API                                                                                         // 1001\n        if (typeof dep_protocols_whitelist === 'string' &&                                                        // 1002\n            dep_protocols_whitelist.length > 0) {                                                                 // 1003\n            protocols_whitelist = [dep_protocols_whitelist];                                                      // 1004\n        } else if (utils.isArray(dep_protocols_whitelist)) {                                                      // 1005\n            protocols_whitelist = dep_protocols_whitelist                                                         // 1006\n        } else {                                                                                                  // 1007\n            protocols_whitelist = null;                                                                           // 1008\n        }                                                                                                         // 1009\n        if (protocols_whitelist) {                                                                                // 1010\n            that._debug('Deprecated API: Use \"protocols_whitelist\" option ' +                                     // 1011\n                        'instead of supplying protocol list as a second ' +                                       // 1012\n                        'parameter to SockJS constructor.');                                                      // 1013\n        }                                                                                                         // 1014\n    }                                                                                                             // 1015\n    that._protocols = [];                                                                                         // 1016\n    that.protocol = null;                                                                                         // 1017\n    that.readyState = SockJS.CONNECTING;                                                                          // 1018\n    that._ir = createInfoReceiver(that._base_url);                                                                // 1019\n    that._ir.onfinish = function(info, rtt) {                                                                     // 1020\n        that._ir = null;                                                                                          // 1021\n        if (info) {                                                                                               // 1022\n            if (that._options.info) {                                                                             // 1023\n                // Override if user supplies the option                                                           // 1024\n                info = utils.objectExtend(info, that._options.info);                                              // 1025\n            }                                                                                                     // 1026\n            if (that._options.rtt) {                                                                              // 1027\n                rtt = that._options.rtt;                                                                          // 1028\n            }                                                                                                     // 1029\n            that._applyInfo(info, rtt, protocols_whitelist);                                                      // 1030\n            that._didClose();                                                                                     // 1031\n        } else {                                                                                                  // 1032\n            that._didClose(1002, 'Can\\'t connect to server', true);                                               // 1033\n        }                                                                                                         // 1034\n    };                                                                                                            // 1035\n};                                                                                                                // 1036\n// Inheritance                                                                                                    // 1037\nSockJS.prototype = new REventTarget();                                                                            // 1038\n                                                                                                                  // 1039\nSockJS.version = \"0.3.4\";                                                                                         // 1040\n                                                                                                                  // 1041\nSockJS.CONNECTING = 0;                                                                                            // 1042\nSockJS.OPEN = 1;                                                                                                  // 1043\nSockJS.CLOSING = 2;                                                                                               // 1044\nSockJS.CLOSED = 3;                                                                                                // 1045\n                                                                                                                  // 1046\nSockJS.prototype._debug = function() {                                                                            // 1047\n    if (this._options.debug)                                                                                      // 1048\n        utils.log.apply(utils, arguments);                                                                        // 1049\n};                                                                                                                // 1050\n                                                                                                                  // 1051\nSockJS.prototype._dispatchOpen = function() {                                                                     // 1052\n    var that = this;                                                                                              // 1053\n    if (that.readyState === SockJS.CONNECTING) {                                                                  // 1054\n        if (that._transport_tref) {                                                                               // 1055\n            clearTimeout(that._transport_tref);                                                                   // 1056\n            that._transport_tref = null;                                                                          // 1057\n        }                                                                                                         // 1058\n        that.readyState = SockJS.OPEN;                                                                            // 1059\n        that.dispatchEvent(new SimpleEvent(\"open\"));                                                              // 1060\n    } else {                                                                                                      // 1061\n        // The server might have been restarted, and lost track of our                                            // 1062\n        // connection.                                                                                            // 1063\n        that._didClose(1006, \"Server lost session\");                                                              // 1064\n    }                                                                                                             // 1065\n};                                                                                                                // 1066\n                                                                                                                  // 1067\nSockJS.prototype._dispatchMessage = function(data) {                                                              // 1068\n    var that = this;                                                                                              // 1069\n    if (that.readyState !== SockJS.OPEN)                                                                          // 1070\n            return;                                                                                               // 1071\n    that.dispatchEvent(new SimpleEvent(\"message\", {data: data}));                                                 // 1072\n};                                                                                                                // 1073\n                                                                                                                  // 1074\nSockJS.prototype._dispatchHeartbeat = function(data) {                                                            // 1075\n    var that = this;                                                                                              // 1076\n    if (that.readyState !== SockJS.OPEN)                                                                          // 1077\n        return;                                                                                                   // 1078\n    that.dispatchEvent(new SimpleEvent('heartbeat', {}));                                                         // 1079\n};                                                                                                                // 1080\n                                                                                                                  // 1081\nSockJS.prototype._didClose = function(code, reason, force) {                                                      // 1082\n    var that = this;                                                                                              // 1083\n    if (that.readyState !== SockJS.CONNECTING &&                                                                  // 1084\n        that.readyState !== SockJS.OPEN &&                                                                        // 1085\n        that.readyState !== SockJS.CLOSING)                                                                       // 1086\n            throw new Error('INVALID_STATE_ERR');                                                                 // 1087\n    if (that._ir) {                                                                                               // 1088\n        that._ir.nuke();                                                                                          // 1089\n        that._ir = null;                                                                                          // 1090\n    }                                                                                                             // 1091\n                                                                                                                  // 1092\n    if (that._transport) {                                                                                        // 1093\n        that._transport.doCleanup();                                                                              // 1094\n        that._transport = null;                                                                                   // 1095\n    }                                                                                                             // 1096\n                                                                                                                  // 1097\n    var close_event = new SimpleEvent(\"close\", {                                                                  // 1098\n        code: code,                                                                                               // 1099\n        reason: reason,                                                                                           // 1100\n        wasClean: utils.userSetCode(code)});                                                                      // 1101\n                                                                                                                  // 1102\n    if (!utils.userSetCode(code) &&                                                                               // 1103\n        that.readyState === SockJS.CONNECTING && !force) {                                                        // 1104\n        if (that._try_next_protocol(close_event)) {                                                               // 1105\n            return;                                                                                               // 1106\n        }                                                                                                         // 1107\n        close_event = new SimpleEvent(\"close\", {code: 2000,                                                       // 1108\n                                                reason: \"All transports failed\",                                  // 1109\n                                                wasClean: false,                                                  // 1110\n                                                last_event: close_event});                                        // 1111\n    }                                                                                                             // 1112\n    that.readyState = SockJS.CLOSED;                                                                              // 1113\n                                                                                                                  // 1114\n    utils.delay(function() {                                                                                      // 1115\n                   that.dispatchEvent(close_event);                                                               // 1116\n                });                                                                                               // 1117\n};                                                                                                                // 1118\n                                                                                                                  // 1119\nSockJS.prototype._didMessage = function(data) {                                                                   // 1120\n    var that = this;                                                                                              // 1121\n    var type = data.slice(0, 1);                                                                                  // 1122\n    switch(type) {                                                                                                // 1123\n    case 'o':                                                                                                     // 1124\n        that._dispatchOpen();                                                                                     // 1125\n        break;                                                                                                    // 1126\n    case 'a':                                                                                                     // 1127\n        var payload = JSON.parse(data.slice(1) || '[]');                                                          // 1128\n        for(var i=0; i < payload.length; i++){                                                                    // 1129\n            that._dispatchMessage(payload[i]);                                                                    // 1130\n        }                                                                                                         // 1131\n        break;                                                                                                    // 1132\n    case 'm':                                                                                                     // 1133\n        var payload = JSON.parse(data.slice(1) || 'null');                                                        // 1134\n        that._dispatchMessage(payload);                                                                           // 1135\n        break;                                                                                                    // 1136\n    case 'c':                                                                                                     // 1137\n        var payload = JSON.parse(data.slice(1) || '[]');                                                          // 1138\n        that._didClose(payload[0], payload[1]);                                                                   // 1139\n        break;                                                                                                    // 1140\n    case 'h':                                                                                                     // 1141\n        that._dispatchHeartbeat();                                                                                // 1142\n        break;                                                                                                    // 1143\n    }                                                                                                             // 1144\n};                                                                                                                // 1145\n                                                                                                                  // 1146\nSockJS.prototype._try_next_protocol = function(close_event) {                                                     // 1147\n    var that = this;                                                                                              // 1148\n    if (that.protocol) {                                                                                          // 1149\n        that._debug('Closed transport:', that.protocol, ''+close_event);                                          // 1150\n        that.protocol = null;                                                                                     // 1151\n    }                                                                                                             // 1152\n    if (that._transport_tref) {                                                                                   // 1153\n        clearTimeout(that._transport_tref);                                                                       // 1154\n        that._transport_tref = null;                                                                              // 1155\n    }                                                                                                             // 1156\n                                                                                                                  // 1157\n    while(1) {                                                                                                    // 1158\n        var protocol = that.protocol = that._protocols.shift();                                                   // 1159\n        if (!protocol) {                                                                                          // 1160\n            return false;                                                                                         // 1161\n        }                                                                                                         // 1162\n        // Some protocols require access to `body`, what if were in                                               // 1163\n        // the `head`?                                                                                            // 1164\n        if (SockJS[protocol] &&                                                                                   // 1165\n            SockJS[protocol].need_body === true &&                                                                // 1166\n            (!_document.body ||                                                                                   // 1167\n             (typeof _document.readyState !== 'undefined'                                                         // 1168\n              && _document.readyState !== 'complete'))) {                                                         // 1169\n            that._protocols.unshift(protocol);                                                                    // 1170\n            that.protocol = 'waiting-for-load';                                                                   // 1171\n            utils.attachEvent('load', function(){                                                                 // 1172\n                that._try_next_protocol();                                                                        // 1173\n            });                                                                                                   // 1174\n            return true;                                                                                          // 1175\n        }                                                                                                         // 1176\n                                                                                                                  // 1177\n        if (!SockJS[protocol] ||                                                                                  // 1178\n              !SockJS[protocol].enabled(that._options)) {                                                         // 1179\n            that._debug('Skipping transport:', protocol);                                                         // 1180\n        } else {                                                                                                  // 1181\n            var roundTrips = SockJS[protocol].roundTrips || 1;                                                    // 1182\n            var to = ((that._options.rto || 0) * roundTrips) || 5000;                                             // 1183\n            that._transport_tref = utils.delay(to, function() {                                                   // 1184\n                if (that.readyState === SockJS.CONNECTING) {                                                      // 1185\n                    // I can't understand how it is possible to run                                               // 1186\n                    // this timer, when the state is CLOSED, but                                                  // 1187\n                    // apparently in IE everythin is possible.                                                    // 1188\n                    that._didClose(2007, \"Transport timeouted\");                                                  // 1189\n                }                                                                                                 // 1190\n            });                                                                                                   // 1191\n                                                                                                                  // 1192\n            var connid = utils.random_string(8);                                                                  // 1193\n            var trans_url = that._base_url + '/' + that._server + '/' + connid;                                   // 1194\n            that._debug('Opening transport:', protocol, ' url:'+trans_url,                                        // 1195\n                        ' RTO:'+that._options.rto);                                                               // 1196\n            that._transport = new SockJS[protocol](that, trans_url,                                               // 1197\n                                                   that._base_url);                                               // 1198\n            return true;                                                                                          // 1199\n        }                                                                                                         // 1200\n    }                                                                                                             // 1201\n};                                                                                                                // 1202\n                                                                                                                  // 1203\nSockJS.prototype.close = function(code, reason) {                                                                 // 1204\n    var that = this;                                                                                              // 1205\n    if (code && !utils.userSetCode(code))                                                                         // 1206\n        throw new Error(\"INVALID_ACCESS_ERR\");                                                                    // 1207\n    if(that.readyState !== SockJS.CONNECTING &&                                                                   // 1208\n       that.readyState !== SockJS.OPEN) {                                                                         // 1209\n        return false;                                                                                             // 1210\n    }                                                                                                             // 1211\n    that.readyState = SockJS.CLOSING;                                                                             // 1212\n    that._didClose(code || 1000, reason || \"Normal closure\");                                                     // 1213\n    return true;                                                                                                  // 1214\n};                                                                                                                // 1215\n                                                                                                                  // 1216\nSockJS.prototype.send = function(data) {                                                                          // 1217\n    var that = this;                                                                                              // 1218\n    if (that.readyState === SockJS.CONNECTING)                                                                    // 1219\n        throw new Error('INVALID_STATE_ERR');                                                                     // 1220\n    if (that.readyState === SockJS.OPEN) {                                                                        // 1221\n        that._transport.doSend(utils.quote('' + data));                                                           // 1222\n    }                                                                                                             // 1223\n    return true;                                                                                                  // 1224\n};                                                                                                                // 1225\n                                                                                                                  // 1226\nSockJS.prototype._applyInfo = function(info, rtt, protocols_whitelist) {                                          // 1227\n    var that = this;                                                                                              // 1228\n    that._options.info = info;                                                                                    // 1229\n    that._options.rtt = rtt;                                                                                      // 1230\n    that._options.rto = utils.countRTO(rtt);                                                                      // 1231\n    that._options.info.null_origin = !_document.domain;                                                           // 1232\n    // Servers can override base_url, eg to provide a randomized domain name and                                  // 1233\n    // avoid browser per-domain connection limits.                                                                // 1234\n    if (info.base_url)                                                                                            // 1235\n      // <METEOR>                                                                                                 // 1236\n      that._base_url = utils.amendUrl(info.base_url, that._base_url);                                             // 1237\n      // </METEOR>                                                                                                // 1238\n    var probed = utils.probeProtocols();                                                                          // 1239\n    that._protocols = utils.detectProtocols(probed, protocols_whitelist, info);                                   // 1240\n// <METEOR>                                                                                                       // 1241\n// https://github.com/sockjs/sockjs-client/issues/79                                                              // 1242\n    // Hack to avoid XDR when using different protocols                                                           // 1243\n    // We're on IE trying to do cross-protocol. jsonp only.                                                       // 1244\n    if (!utils.isSameOriginScheme(that._base_url) &&                                                              // 1245\n        2 === utils.isXHRCorsCapable()) {                                                                         // 1246\n        that._protocols = ['jsonp-polling'];                                                                      // 1247\n    }                                                                                                             // 1248\n// </METEOR>                                                                                                      // 1249\n};                                                                                                                // 1250\n//         [*] End of lib/sockjs.js                                                                               // 1251\n                                                                                                                  // 1252\n                                                                                                                  // 1253\n//         [*] Including lib/trans-websocket.js                                                                   // 1254\n/*                                                                                                                // 1255\n * ***** BEGIN LICENSE BLOCK *****                                                                                // 1256\n * Copyright (c) 2011-2012 VMware, Inc.                                                                           // 1257\n *                                                                                                                // 1258\n * For the license see COPYING.                                                                                   // 1259\n * ***** END LICENSE BLOCK *****                                                                                  // 1260\n */                                                                                                               // 1261\n                                                                                                                  // 1262\nvar WebSocketTransport = SockJS.websocket = function(ri, trans_url) {                                             // 1263\n    var that = this;                                                                                              // 1264\n    var url = trans_url + '/websocket';                                                                           // 1265\n    if (url.slice(0, 5) === 'https') {                                                                            // 1266\n        url = 'wss' + url.slice(5);                                                                               // 1267\n    } else {                                                                                                      // 1268\n        url = 'ws' + url.slice(4);                                                                                // 1269\n    }                                                                                                             // 1270\n    that.ri = ri;                                                                                                 // 1271\n    that.url = url;                                                                                               // 1272\n    var Constructor = _window.WebSocket || _window.MozWebSocket;                                                  // 1273\n                                                                                                                  // 1274\n    that.ws = new Constructor(that.url);                                                                          // 1275\n    that.ws.onmessage = function(e) {                                                                             // 1276\n        that.ri._didMessage(e.data);                                                                              // 1277\n    };                                                                                                            // 1278\n    // Firefox has an interesting bug. If a websocket connection is                                               // 1279\n    // created after onunload, it stays alive even when user                                                      // 1280\n    // navigates away from the page. In such situation let's lie -                                                // 1281\n    // let's not open the ws connection at all. See:                                                              // 1282\n    // https://github.com/sockjs/sockjs-client/issues/28                                                          // 1283\n    // https://bugzilla.mozilla.org/show_bug.cgi?id=696085                                                        // 1284\n    that.unload_ref = utils.unload_add(function(){that.ws.close()});                                              // 1285\n    that.ws.onclose = function() {                                                                                // 1286\n        that.ri._didMessage(utils.closeFrame(1006, \"WebSocket connection broken\"));                               // 1287\n    };                                                                                                            // 1288\n};                                                                                                                // 1289\n                                                                                                                  // 1290\nWebSocketTransport.prototype.doSend = function(data) {                                                            // 1291\n    this.ws.send('[' + data + ']');                                                                               // 1292\n};                                                                                                                // 1293\n                                                                                                                  // 1294\nWebSocketTransport.prototype.doCleanup = function() {                                                             // 1295\n    var that = this;                                                                                              // 1296\n    var ws = that.ws;                                                                                             // 1297\n    if (ws) {                                                                                                     // 1298\n        ws.onmessage = ws.onclose = null;                                                                         // 1299\n        ws.close();                                                                                               // 1300\n        utils.unload_del(that.unload_ref);                                                                        // 1301\n        that.unload_ref = that.ri = that.ws = null;                                                               // 1302\n    }                                                                                                             // 1303\n};                                                                                                                // 1304\n                                                                                                                  // 1305\nWebSocketTransport.enabled = function() {                                                                         // 1306\n    return !!(_window.WebSocket || _window.MozWebSocket);                                                         // 1307\n};                                                                                                                // 1308\n                                                                                                                  // 1309\n// In theory, ws should require 1 round trip. But in chrome, this is                                              // 1310\n// not very stable over SSL. Most likely a ws connection requires a                                               // 1311\n// separate SSL connection, in which case 2 round trips are an                                                    // 1312\n// absolute minumum.                                                                                              // 1313\nWebSocketTransport.roundTrips = 2;                                                                                // 1314\n//         [*] End of lib/trans-websocket.js                                                                      // 1315\n                                                                                                                  // 1316\n                                                                                                                  // 1317\n//         [*] Including lib/trans-sender.js                                                                      // 1318\n/*                                                                                                                // 1319\n * ***** BEGIN LICENSE BLOCK *****                                                                                // 1320\n * Copyright (c) 2011-2012 VMware, Inc.                                                                           // 1321\n *                                                                                                                // 1322\n * For the license see COPYING.                                                                                   // 1323\n * ***** END LICENSE BLOCK *****                                                                                  // 1324\n */                                                                                                               // 1325\n                                                                                                                  // 1326\nvar BufferedSender = function() {};                                                                               // 1327\nBufferedSender.prototype.send_constructor = function(sender) {                                                    // 1328\n    var that = this;                                                                                              // 1329\n    that.send_buffer = [];                                                                                        // 1330\n    that.sender = sender;                                                                                         // 1331\n};                                                                                                                // 1332\nBufferedSender.prototype.doSend = function(message) {                                                             // 1333\n    var that = this;                                                                                              // 1334\n    that.send_buffer.push(message);                                                                               // 1335\n    if (!that.send_stop) {                                                                                        // 1336\n        that.send_schedule();                                                                                     // 1337\n    }                                                                                                             // 1338\n};                                                                                                                // 1339\n                                                                                                                  // 1340\n// For polling transports in a situation when in the message callback,                                            // 1341\n// new message is being send. If the sending connection was started                                               // 1342\n// before receiving one, it is possible to saturate the network and                                               // 1343\n// timeout due to the lack of receiving socket. To avoid that we delay                                            // 1344\n// sending messages by some small time, in order to let receiving                                                 // 1345\n// connection be started beforehand. This is only a halfmeasure and                                               // 1346\n// does not fix the big problem, but it does make the tests go more                                               // 1347\n// stable on slow networks.                                                                                       // 1348\nBufferedSender.prototype.send_schedule_wait = function() {                                                        // 1349\n    var that = this;                                                                                              // 1350\n    var tref;                                                                                                     // 1351\n    that.send_stop = function() {                                                                                 // 1352\n        that.send_stop = null;                                                                                    // 1353\n        clearTimeout(tref);                                                                                       // 1354\n    };                                                                                                            // 1355\n    tref = utils.delay(25, function() {                                                                           // 1356\n        that.send_stop = null;                                                                                    // 1357\n        that.send_schedule();                                                                                     // 1358\n    });                                                                                                           // 1359\n};                                                                                                                // 1360\n                                                                                                                  // 1361\nBufferedSender.prototype.send_schedule = function() {                                                             // 1362\n    var that = this;                                                                                              // 1363\n    if (that.send_buffer.length > 0) {                                                                            // 1364\n        var payload = '[' + that.send_buffer.join(',') + ']';                                                     // 1365\n        that.send_stop = that.sender(that.trans_url, payload, function(success, abort_reason) {                   // 1366\n            that.send_stop = null;                                                                                // 1367\n            if (success === false) {                                                                              // 1368\n                that.ri._didClose(1006, 'Sending error ' + abort_reason);                                         // 1369\n            } else {                                                                                              // 1370\n                that.send_schedule_wait();                                                                        // 1371\n            }                                                                                                     // 1372\n        });                                                                                                       // 1373\n        that.send_buffer = [];                                                                                    // 1374\n    }                                                                                                             // 1375\n};                                                                                                                // 1376\n                                                                                                                  // 1377\nBufferedSender.prototype.send_destructor = function() {                                                           // 1378\n    var that = this;                                                                                              // 1379\n    if (that._send_stop) {                                                                                        // 1380\n        that._send_stop();                                                                                        // 1381\n    }                                                                                                             // 1382\n    that._send_stop = null;                                                                                       // 1383\n};                                                                                                                // 1384\n                                                                                                                  // 1385\nvar jsonPGenericSender = function(url, payload, callback) {                                                       // 1386\n    var that = this;                                                                                              // 1387\n                                                                                                                  // 1388\n    if (!('_send_form' in that)) {                                                                                // 1389\n        var form = that._send_form = _document.createElement('form');                                             // 1390\n        var area = that._send_area = _document.createElement('textarea');                                         // 1391\n        area.name = 'd';                                                                                          // 1392\n        form.style.display = 'none';                                                                              // 1393\n        form.style.position = 'absolute';                                                                         // 1394\n        form.method = 'POST';                                                                                     // 1395\n        form.enctype = 'application/x-www-form-urlencoded';                                                       // 1396\n        form.acceptCharset = \"UTF-8\";                                                                             // 1397\n        form.appendChild(area);                                                                                   // 1398\n        _document.body.appendChild(form);                                                                         // 1399\n    }                                                                                                             // 1400\n    var form = that._send_form;                                                                                   // 1401\n    var area = that._send_area;                                                                                   // 1402\n    var id = 'a' + utils.random_string(8);                                                                        // 1403\n    form.target = id;                                                                                             // 1404\n    form.action = url + '/jsonp_send?i=' + id;                                                                    // 1405\n                                                                                                                  // 1406\n    var iframe;                                                                                                   // 1407\n    try {                                                                                                         // 1408\n        // ie6 dynamic iframes with target=\"\" support (thanks Chris Lambacher)                                    // 1409\n        iframe = _document.createElement('<iframe name=\"'+ id +'\">');                                             // 1410\n    } catch(x) {                                                                                                  // 1411\n        iframe = _document.createElement('iframe');                                                               // 1412\n        iframe.name = id;                                                                                         // 1413\n    }                                                                                                             // 1414\n    iframe.id = id;                                                                                               // 1415\n    form.appendChild(iframe);                                                                                     // 1416\n    iframe.style.display = 'none';                                                                                // 1417\n                                                                                                                  // 1418\n    try {                                                                                                         // 1419\n        area.value = payload;                                                                                     // 1420\n    } catch(e) {                                                                                                  // 1421\n        utils.log('Your browser is seriously broken. Go home! ' + e.message);                                     // 1422\n    }                                                                                                             // 1423\n    form.submit();                                                                                                // 1424\n                                                                                                                  // 1425\n    var completed = function(e) {                                                                                 // 1426\n        if (!iframe.onerror) return;                                                                              // 1427\n        iframe.onreadystatechange = iframe.onerror = iframe.onload = null;                                        // 1428\n        // Opera mini doesn't like if we GC iframe                                                                // 1429\n        // immediately, thus this timeout.                                                                        // 1430\n        utils.delay(500, function() {                                                                             // 1431\n                       iframe.parentNode.removeChild(iframe);                                                     // 1432\n                       iframe = null;                                                                             // 1433\n                   });                                                                                            // 1434\n        area.value = '';                                                                                          // 1435\n        // It is not possible to detect if the iframe succeeded or                                                // 1436\n        // failed to submit our form.                                                                             // 1437\n        callback(true);                                                                                           // 1438\n    };                                                                                                            // 1439\n    iframe.onerror = iframe.onload = completed;                                                                   // 1440\n    iframe.onreadystatechange = function(e) {                                                                     // 1441\n        if (iframe.readyState == 'complete') completed();                                                         // 1442\n    };                                                                                                            // 1443\n    return completed;                                                                                             // 1444\n};                                                                                                                // 1445\n                                                                                                                  // 1446\nvar createAjaxSender = function(AjaxObject) {                                                                     // 1447\n    return function(url, payload, callback) {                                                                     // 1448\n        var xo = new AjaxObject('POST', url + '/xhr_send', payload);                                              // 1449\n        xo.onfinish = function(status, text) {                                                                    // 1450\n            callback(status === 200 || status === 204,                                                            // 1451\n                     'http status ' + status);                                                                    // 1452\n        };                                                                                                        // 1453\n        return function(abort_reason) {                                                                           // 1454\n            callback(false, abort_reason);                                                                        // 1455\n        };                                                                                                        // 1456\n    };                                                                                                            // 1457\n};                                                                                                                // 1458\n//         [*] End of lib/trans-sender.js                                                                         // 1459\n                                                                                                                  // 1460\n                                                                                                                  // 1461\n//         [*] Including lib/trans-jsonp-receiver.js                                                              // 1462\n/*                                                                                                                // 1463\n * ***** BEGIN LICENSE BLOCK *****                                                                                // 1464\n * Copyright (c) 2011-2012 VMware, Inc.                                                                           // 1465\n *                                                                                                                // 1466\n * For the license see COPYING.                                                                                   // 1467\n * ***** END LICENSE BLOCK *****                                                                                  // 1468\n */                                                                                                               // 1469\n                                                                                                                  // 1470\n// Parts derived from Socket.io:                                                                                  // 1471\n//    https://github.com/LearnBoost/socket.io/blob/0.6.17/lib/socket.io/transports/jsonp-polling.js               // 1472\n// and jQuery-JSONP:                                                                                              // 1473\n//    https://code.google.com/p/jquery-jsonp/source/browse/trunk/core/jquery.jsonp.js                             // 1474\nvar jsonPGenericReceiver = function(url, callback) {                                                              // 1475\n    var tref;                                                                                                     // 1476\n    var script = _document.createElement('script');                                                               // 1477\n    var script2;  // Opera synchronous load trick.                                                                // 1478\n    var close_script = function(frame) {                                                                          // 1479\n        if (script2) {                                                                                            // 1480\n            script2.parentNode.removeChild(script2);                                                              // 1481\n            script2 = null;                                                                                       // 1482\n        }                                                                                                         // 1483\n        if (script) {                                                                                             // 1484\n            clearTimeout(tref);                                                                                   // 1485\n            // Unfortunately, you can't really abort script loading of                                            // 1486\n            // the script.                                                                                        // 1487\n            script.parentNode.removeChild(script);                                                                // 1488\n            script.onreadystatechange = script.onerror =                                                          // 1489\n                script.onload = script.onclick = null;                                                            // 1490\n            script = null;                                                                                        // 1491\n            callback(frame);                                                                                      // 1492\n            callback = null;                                                                                      // 1493\n        }                                                                                                         // 1494\n    };                                                                                                            // 1495\n                                                                                                                  // 1496\n    // IE9 fires 'error' event after orsc or before, in random order.                                             // 1497\n    var loaded_okay = false;                                                                                      // 1498\n    var error_timer = null;                                                                                       // 1499\n                                                                                                                  // 1500\n    script.id = 'a' + utils.random_string(8);                                                                     // 1501\n    script.src = url;                                                                                             // 1502\n    script.type = 'text/javascript';                                                                              // 1503\n    script.charset = 'UTF-8';                                                                                     // 1504\n    script.onerror = function(e) {                                                                                // 1505\n        if (!error_timer) {                                                                                       // 1506\n            // Delay firing close_script.                                                                         // 1507\n            error_timer = setTimeout(function() {                                                                 // 1508\n                if (!loaded_okay) {                                                                               // 1509\n                    close_script(utils.closeFrame(                                                                // 1510\n                        1006,                                                                                     // 1511\n                        \"JSONP script loaded abnormally (onerror)\"));                                             // 1512\n                }                                                                                                 // 1513\n            }, 1000);                                                                                             // 1514\n        }                                                                                                         // 1515\n    };                                                                                                            // 1516\n    script.onload = function(e) {                                                                                 // 1517\n        close_script(utils.closeFrame(1006, \"JSONP script loaded abnormally (onload)\"));                          // 1518\n    };                                                                                                            // 1519\n                                                                                                                  // 1520\n    script.onreadystatechange = function(e) {                                                                     // 1521\n        if (/loaded|closed/.test(script.readyState)) {                                                            // 1522\n            if (script && script.htmlFor && script.onclick) {                                                     // 1523\n                loaded_okay = true;                                                                               // 1524\n                try {                                                                                             // 1525\n                    // In IE, actually execute the script.                                                        // 1526\n                    script.onclick();                                                                             // 1527\n                } catch (x) {}                                                                                    // 1528\n            }                                                                                                     // 1529\n            if (script) {                                                                                         // 1530\n                close_script(utils.closeFrame(1006, \"JSONP script loaded abnormally (onreadystatechange)\"));      // 1531\n            }                                                                                                     // 1532\n        }                                                                                                         // 1533\n    };                                                                                                            // 1534\n    // IE: event/htmlFor/onclick trick.                                                                           // 1535\n    // One can't rely on proper order for onreadystatechange. In order to                                         // 1536\n    // make sure, set a 'htmlFor' and 'event' properties, so that                                                 // 1537\n    // script code will be installed as 'onclick' handler for the                                                 // 1538\n    // script object. Later, onreadystatechange, manually execute this                                            // 1539\n    // code. FF and Chrome doesn't work with 'event' and 'htmlFor'                                                // 1540\n    // set. For reference see:                                                                                    // 1541\n    //   http://jaubourg.net/2010/07/loading-script-as-onclick-handler-of.html                                    // 1542\n    // Also, read on that about script ordering:                                                                  // 1543\n    //   http://wiki.whatwg.org/wiki/Dynamic_Script_Execution_Order                                               // 1544\n    if (typeof script.async === 'undefined' && _document.attachEvent) {                                           // 1545\n        // According to mozilla docs, in recent browsers script.async defaults                                    // 1546\n        // to 'true', so we may use it to detect a good browser:                                                  // 1547\n        // https://developer.mozilla.org/en/HTML/Element/script                                                   // 1548\n        if (!/opera/i.test(navigator.userAgent)) {                                                                // 1549\n            // Naively assume we're in IE                                                                         // 1550\n            try {                                                                                                 // 1551\n                script.htmlFor = script.id;                                                                       // 1552\n                script.event = \"onclick\";                                                                         // 1553\n            } catch (x) {}                                                                                        // 1554\n            script.async = true;                                                                                  // 1555\n        } else {                                                                                                  // 1556\n            // Opera, second sync script hack                                                                     // 1557\n            script2 = _document.createElement('script');                                                          // 1558\n            script2.text = \"try{var a = document.getElementById('\"+script.id+\"'); if(a)a.onerror();}catch(x){};\";\n            script.async = script2.async = false;                                                                 // 1560\n        }                                                                                                         // 1561\n    }                                                                                                             // 1562\n    if (typeof script.async !== 'undefined') {                                                                    // 1563\n        script.async = true;                                                                                      // 1564\n    }                                                                                                             // 1565\n                                                                                                                  // 1566\n    // Fallback mostly for Konqueror - stupid timer, 35 seconds shall be plenty.                                  // 1567\n    tref = setTimeout(function() {                                                                                // 1568\n                          close_script(utils.closeFrame(1006, \"JSONP script loaded abnormally (timeout)\"));       // 1569\n                      }, 35000);                                                                                  // 1570\n                                                                                                                  // 1571\n    var head = _document.getElementsByTagName('head')[0];                                                         // 1572\n    head.insertBefore(script, head.firstChild);                                                                   // 1573\n    if (script2) {                                                                                                // 1574\n        head.insertBefore(script2, head.firstChild);                                                              // 1575\n    }                                                                                                             // 1576\n    return close_script;                                                                                          // 1577\n};                                                                                                                // 1578\n//         [*] End of lib/trans-jsonp-receiver.js                                                                 // 1579\n                                                                                                                  // 1580\n                                                                                                                  // 1581\n//         [*] Including lib/trans-jsonp-polling.js                                                               // 1582\n/*                                                                                                                // 1583\n * ***** BEGIN LICENSE BLOCK *****                                                                                // 1584\n * Copyright (c) 2011-2012 VMware, Inc.                                                                           // 1585\n *                                                                                                                // 1586\n * For the license see COPYING.                                                                                   // 1587\n * ***** END LICENSE BLOCK *****                                                                                  // 1588\n */                                                                                                               // 1589\n                                                                                                                  // 1590\n// The simplest and most robust transport, using the well-know cross                                              // 1591\n// domain hack - JSONP. This transport is quite inefficient - one                                                 // 1592\n// mssage could use up to one http request. But at least it works almost                                          // 1593\n// everywhere.                                                                                                    // 1594\n// Known limitations:                                                                                             // 1595\n//   o you will get a spinning cursor                                                                             // 1596\n//   o for Konqueror a dumb timer is needed to detect errors                                                      // 1597\n                                                                                                                  // 1598\n                                                                                                                  // 1599\nvar JsonPTransport = SockJS['jsonp-polling'] = function(ri, trans_url) {                                          // 1600\n    utils.polluteGlobalNamespace();                                                                               // 1601\n    var that = this;                                                                                              // 1602\n    that.ri = ri;                                                                                                 // 1603\n    that.trans_url = trans_url;                                                                                   // 1604\n    that.send_constructor(jsonPGenericSender);                                                                    // 1605\n    that._schedule_recv();                                                                                        // 1606\n};                                                                                                                // 1607\n                                                                                                                  // 1608\n// Inheritnace                                                                                                    // 1609\nJsonPTransport.prototype = new BufferedSender();                                                                  // 1610\n                                                                                                                  // 1611\nJsonPTransport.prototype._schedule_recv = function() {                                                            // 1612\n    var that = this;                                                                                              // 1613\n    var callback = function(data) {                                                                               // 1614\n        that._recv_stop = null;                                                                                   // 1615\n        if (data) {                                                                                               // 1616\n            // no data - heartbeat;                                                                               // 1617\n            if (!that._is_closing) {                                                                              // 1618\n                that.ri._didMessage(data);                                                                        // 1619\n            }                                                                                                     // 1620\n        }                                                                                                         // 1621\n        // The message can be a close message, and change is_closing state.                                       // 1622\n        if (!that._is_closing) {                                                                                  // 1623\n            that._schedule_recv();                                                                                // 1624\n        }                                                                                                         // 1625\n    };                                                                                                            // 1626\n    that._recv_stop = jsonPReceiverWrapper(that.trans_url + '/jsonp',                                             // 1627\n                                           jsonPGenericReceiver, callback);                                       // 1628\n};                                                                                                                // 1629\n                                                                                                                  // 1630\nJsonPTransport.enabled = function() {                                                                             // 1631\n    return true;                                                                                                  // 1632\n};                                                                                                                // 1633\n                                                                                                                  // 1634\nJsonPTransport.need_body = true;                                                                                  // 1635\n                                                                                                                  // 1636\n                                                                                                                  // 1637\nJsonPTransport.prototype.doCleanup = function() {                                                                 // 1638\n    var that = this;                                                                                              // 1639\n    that._is_closing = true;                                                                                      // 1640\n    if (that._recv_stop) {                                                                                        // 1641\n        that._recv_stop();                                                                                        // 1642\n    }                                                                                                             // 1643\n    that.ri = that._recv_stop = null;                                                                             // 1644\n    that.send_destructor();                                                                                       // 1645\n};                                                                                                                // 1646\n                                                                                                                  // 1647\n                                                                                                                  // 1648\n// Abstract away code that handles global namespace pollution.                                                    // 1649\nvar jsonPReceiverWrapper = function(url, constructReceiver, user_callback) {                                      // 1650\n    var id = 'a' + utils.random_string(6);                                                                        // 1651\n    var url_id = url + '?c=' + escape(WPrefix + '.' + id);                                                        // 1652\n                                                                                                                  // 1653\n    // Unfortunately it is not possible to abort loading of the                                                   // 1654\n    // script. We need to keep track of frake close frames.                                                       // 1655\n    var aborting = 0;                                                                                             // 1656\n                                                                                                                  // 1657\n    // Callback will be called exactly once.                                                                      // 1658\n    var callback = function(frame) {                                                                              // 1659\n        switch(aborting) {                                                                                        // 1660\n        case 0:                                                                                                   // 1661\n            // Normal behaviour - delete hook _and_ emit message.                                                 // 1662\n            delete _window[WPrefix][id];                                                                          // 1663\n            user_callback(frame);                                                                                 // 1664\n            break;                                                                                                // 1665\n        case 1:                                                                                                   // 1666\n            // Fake close frame - emit but don't delete hook.                                                     // 1667\n            user_callback(frame);                                                                                 // 1668\n            aborting = 2;                                                                                         // 1669\n            break;                                                                                                // 1670\n        case 2:                                                                                                   // 1671\n            // Got frame after connection was closed, delete hook, don't emit.                                    // 1672\n            delete _window[WPrefix][id];                                                                          // 1673\n            break;                                                                                                // 1674\n        }                                                                                                         // 1675\n    };                                                                                                            // 1676\n                                                                                                                  // 1677\n    var close_script = constructReceiver(url_id, callback);                                                       // 1678\n    _window[WPrefix][id] = close_script;                                                                          // 1679\n    var stop = function() {                                                                                       // 1680\n        if (_window[WPrefix][id]) {                                                                               // 1681\n            aborting = 1;                                                                                         // 1682\n            _window[WPrefix][id](utils.closeFrame(1000, \"JSONP user aborted read\"));                              // 1683\n        }                                                                                                         // 1684\n    };                                                                                                            // 1685\n    return stop;                                                                                                  // 1686\n};                                                                                                                // 1687\n//         [*] End of lib/trans-jsonp-polling.js                                                                  // 1688\n                                                                                                                  // 1689\n                                                                                                                  // 1690\n//         [*] Including lib/trans-xhr.js                                                                         // 1691\n/*                                                                                                                // 1692\n * ***** BEGIN LICENSE BLOCK *****                                                                                // 1693\n * Copyright (c) 2011-2012 VMware, Inc.                                                                           // 1694\n *                                                                                                                // 1695\n * For the license see COPYING.                                                                                   // 1696\n * ***** END LICENSE BLOCK *****                                                                                  // 1697\n */                                                                                                               // 1698\n                                                                                                                  // 1699\nvar AjaxBasedTransport = function() {};                                                                           // 1700\nAjaxBasedTransport.prototype = new BufferedSender();                                                              // 1701\n                                                                                                                  // 1702\nAjaxBasedTransport.prototype.run = function(ri, trans_url,                                                        // 1703\n                                            url_suffix, Receiver, AjaxObject) {                                   // 1704\n    var that = this;                                                                                              // 1705\n    that.ri = ri;                                                                                                 // 1706\n    that.trans_url = trans_url;                                                                                   // 1707\n    that.send_constructor(createAjaxSender(AjaxObject));                                                          // 1708\n    that.poll = new Polling(ri, Receiver,                                                                         // 1709\n                            trans_url + url_suffix, AjaxObject);                                                  // 1710\n};                                                                                                                // 1711\n                                                                                                                  // 1712\nAjaxBasedTransport.prototype.doCleanup = function() {                                                             // 1713\n    var that = this;                                                                                              // 1714\n    if (that.poll) {                                                                                              // 1715\n        that.poll.abort();                                                                                        // 1716\n        that.poll = null;                                                                                         // 1717\n    }                                                                                                             // 1718\n};                                                                                                                // 1719\n                                                                                                                  // 1720\n// xhr-streaming                                                                                                  // 1721\nvar XhrStreamingTransport = SockJS['xhr-streaming'] = function(ri, trans_url) {                                   // 1722\n    this.run(ri, trans_url, '/xhr_streaming', XhrReceiver, utils.XHRCorsObject);                                  // 1723\n};                                                                                                                // 1724\n                                                                                                                  // 1725\nXhrStreamingTransport.prototype = new AjaxBasedTransport();                                                       // 1726\n                                                                                                                  // 1727\nXhrStreamingTransport.enabled = function() {                                                                      // 1728\n    // Support for CORS Ajax aka Ajax2? Opera 12 claims CORS but                                                  // 1729\n    // doesn't do streaming.                                                                                      // 1730\n    return (_window.XMLHttpRequest &&                                                                             // 1731\n            'withCredentials' in new XMLHttpRequest() &&                                                          // 1732\n            (!/opera/i.test(navigator.userAgent)));                                                               // 1733\n};                                                                                                                // 1734\nXhrStreamingTransport.roundTrips = 2; // preflight, ajax                                                          // 1735\n                                                                                                                  // 1736\n// Safari gets confused when a streaming ajax request is started                                                  // 1737\n// before onload. This causes the load indicator to spin indefinetely.                                            // 1738\nXhrStreamingTransport.need_body = true;                                                                           // 1739\n                                                                                                                  // 1740\n                                                                                                                  // 1741\n// According to:                                                                                                  // 1742\n//   http://stackoverflow.com/questions/1641507/detect-browser-support-for-cross-domain-xmlhttprequests           // 1743\n//   http://hacks.mozilla.org/2009/07/cross-site-xmlhttprequest-with-cors/                                        // 1744\n                                                                                                                  // 1745\n                                                                                                                  // 1746\n// xdr-streaming                                                                                                  // 1747\nvar XdrStreamingTransport = SockJS['xdr-streaming'] = function(ri, trans_url) {                                   // 1748\n    this.run(ri, trans_url, '/xhr_streaming', XhrReceiver, utils.XDRObject);                                      // 1749\n};                                                                                                                // 1750\n                                                                                                                  // 1751\nXdrStreamingTransport.prototype = new AjaxBasedTransport();                                                       // 1752\n                                                                                                                  // 1753\nXdrStreamingTransport.enabled = function() {                                                                      // 1754\n    return !!_window.XDomainRequest;                                                                              // 1755\n};                                                                                                                // 1756\nXdrStreamingTransport.roundTrips = 2; // preflight, ajax                                                          // 1757\n                                                                                                                  // 1758\n                                                                                                                  // 1759\n                                                                                                                  // 1760\n// xhr-polling                                                                                                    // 1761\nvar XhrPollingTransport = SockJS['xhr-polling'] = function(ri, trans_url) {                                       // 1762\n    this.run(ri, trans_url, '/xhr', XhrReceiver, utils.XHRCorsObject);                                            // 1763\n};                                                                                                                // 1764\n                                                                                                                  // 1765\nXhrPollingTransport.prototype = new AjaxBasedTransport();                                                         // 1766\n                                                                                                                  // 1767\nXhrPollingTransport.enabled = XhrStreamingTransport.enabled;                                                      // 1768\nXhrPollingTransport.roundTrips = 2; // preflight, ajax                                                            // 1769\n                                                                                                                  // 1770\n                                                                                                                  // 1771\n// xdr-polling                                                                                                    // 1772\nvar XdrPollingTransport = SockJS['xdr-polling'] = function(ri, trans_url) {                                       // 1773\n    this.run(ri, trans_url, '/xhr', XhrReceiver, utils.XDRObject);                                                // 1774\n};                                                                                                                // 1775\n                                                                                                                  // 1776\nXdrPollingTransport.prototype = new AjaxBasedTransport();                                                         // 1777\n                                                                                                                  // 1778\nXdrPollingTransport.enabled = XdrStreamingTransport.enabled;                                                      // 1779\nXdrPollingTransport.roundTrips = 2; // preflight, ajax                                                            // 1780\n//         [*] End of lib/trans-xhr.js                                                                            // 1781\n                                                                                                                  // 1782\n                                                                                                                  // 1783\n//         [*] Including lib/trans-iframe.js                                                                      // 1784\n/*                                                                                                                // 1785\n * ***** BEGIN LICENSE BLOCK *****                                                                                // 1786\n * Copyright (c) 2011-2012 VMware, Inc.                                                                           // 1787\n *                                                                                                                // 1788\n * For the license see COPYING.                                                                                   // 1789\n * ***** END LICENSE BLOCK *****                                                                                  // 1790\n */                                                                                                               // 1791\n                                                                                                                  // 1792\n// Few cool transports do work only for same-origin. In order to make                                             // 1793\n// them working cross-domain we shall use iframe, served form the                                                 // 1794\n// remote domain. New browsers, have capabilities to communicate with                                             // 1795\n// cross domain iframe, using postMessage(). In IE it was implemented                                             // 1796\n// from IE 8+, but of course, IE got some details wrong:                                                          // 1797\n//    http://msdn.microsoft.com/en-us/library/cc197015(v=VS.85).aspx                                              // 1798\n//    http://stevesouders.com/misc/test-postmessage.php                                                           // 1799\n                                                                                                                  // 1800\nvar IframeTransport = function() {};                                                                              // 1801\n                                                                                                                  // 1802\nIframeTransport.prototype.i_constructor = function(ri, trans_url, base_url) {                                     // 1803\n    var that = this;                                                                                              // 1804\n    that.ri = ri;                                                                                                 // 1805\n    that.origin = utils.getOrigin(base_url);                                                                      // 1806\n    that.base_url = base_url;                                                                                     // 1807\n    that.trans_url = trans_url;                                                                                   // 1808\n                                                                                                                  // 1809\n    var iframe_url = base_url + '/iframe.html';                                                                   // 1810\n    if (that.ri._options.devel) {                                                                                 // 1811\n        iframe_url += '?t=' + (+new Date);                                                                        // 1812\n    }                                                                                                             // 1813\n    that.window_id = utils.random_string(8);                                                                      // 1814\n    iframe_url += '#' + that.window_id;                                                                           // 1815\n                                                                                                                  // 1816\n    that.iframeObj = utils.createIframe(iframe_url, function(r) {                                                 // 1817\n                                            that.ri._didClose(1006, \"Unable to load an iframe (\" + r + \")\");      // 1818\n                                        });                                                                       // 1819\n                                                                                                                  // 1820\n    that.onmessage_cb = utils.bind(that.onmessage, that);                                                         // 1821\n    utils.attachMessage(that.onmessage_cb);                                                                       // 1822\n};                                                                                                                // 1823\n                                                                                                                  // 1824\nIframeTransport.prototype.doCleanup = function() {                                                                // 1825\n    var that = this;                                                                                              // 1826\n    if (that.iframeObj) {                                                                                         // 1827\n        utils.detachMessage(that.onmessage_cb);                                                                   // 1828\n        try {                                                                                                     // 1829\n            // When the iframe is not loaded, IE raises an exception                                              // 1830\n            // on 'contentWindow'.                                                                                // 1831\n            if (that.iframeObj.iframe.contentWindow) {                                                            // 1832\n                that.postMessage('c');                                                                            // 1833\n            }                                                                                                     // 1834\n        } catch (x) {}                                                                                            // 1835\n        that.iframeObj.cleanup();                                                                                 // 1836\n        that.iframeObj = null;                                                                                    // 1837\n        that.onmessage_cb = that.iframeObj = null;                                                                // 1838\n    }                                                                                                             // 1839\n};                                                                                                                // 1840\n                                                                                                                  // 1841\nIframeTransport.prototype.onmessage = function(e) {                                                               // 1842\n    var that = this;                                                                                              // 1843\n    if (e.origin !== that.origin) return;                                                                         // 1844\n    var window_id = e.data.slice(0, 8);                                                                           // 1845\n    var type = e.data.slice(8, 9);                                                                                // 1846\n    var data = e.data.slice(9);                                                                                   // 1847\n                                                                                                                  // 1848\n    if (window_id !== that.window_id) return;                                                                     // 1849\n                                                                                                                  // 1850\n    switch(type) {                                                                                                // 1851\n    case 's':                                                                                                     // 1852\n        that.iframeObj.loaded();                                                                                  // 1853\n        that.postMessage('s', JSON.stringify([SockJS.version, that.protocol, that.trans_url, that.base_url]));    // 1854\n        break;                                                                                                    // 1855\n    case 't':                                                                                                     // 1856\n        that.ri._didMessage(data);                                                                                // 1857\n        break;                                                                                                    // 1858\n    }                                                                                                             // 1859\n};                                                                                                                // 1860\n                                                                                                                  // 1861\nIframeTransport.prototype.postMessage = function(type, data) {                                                    // 1862\n    var that = this;                                                                                              // 1863\n    that.iframeObj.post(that.window_id + type + (data || ''), that.origin);                                       // 1864\n};                                                                                                                // 1865\n                                                                                                                  // 1866\nIframeTransport.prototype.doSend = function (message) {                                                           // 1867\n    this.postMessage('m', message);                                                                               // 1868\n};                                                                                                                // 1869\n                                                                                                                  // 1870\nIframeTransport.enabled = function() {                                                                            // 1871\n    // postMessage misbehaves in konqueror 4.6.5 - the messages are delivered with                                // 1872\n    // huge delay, or not at all.                                                                                 // 1873\n    var konqueror = navigator && navigator.userAgent && navigator.userAgent.indexOf('Konqueror') !== -1;          // 1874\n    return ((typeof _window.postMessage === 'function' ||                                                         // 1875\n            typeof _window.postMessage === 'object') && (!konqueror));                                            // 1876\n};                                                                                                                // 1877\n//         [*] End of lib/trans-iframe.js                                                                         // 1878\n                                                                                                                  // 1879\n                                                                                                                  // 1880\n//         [*] Including lib/trans-iframe-within.js                                                               // 1881\n/*                                                                                                                // 1882\n * ***** BEGIN LICENSE BLOCK *****                                                                                // 1883\n * Copyright (c) 2011-2012 VMware, Inc.                                                                           // 1884\n *                                                                                                                // 1885\n * For the license see COPYING.                                                                                   // 1886\n * ***** END LICENSE BLOCK *****                                                                                  // 1887\n */                                                                                                               // 1888\n                                                                                                                  // 1889\nvar curr_window_id;                                                                                               // 1890\n                                                                                                                  // 1891\nvar postMessage = function (type, data) {                                                                         // 1892\n    if(parent !== _window) {                                                                                      // 1893\n        parent.postMessage(curr_window_id + type + (data || ''), '*');                                            // 1894\n    } else {                                                                                                      // 1895\n        utils.log(\"Can't postMessage, no parent window.\", type, data);                                            // 1896\n    }                                                                                                             // 1897\n};                                                                                                                // 1898\n                                                                                                                  // 1899\nvar FacadeJS = function() {};                                                                                     // 1900\nFacadeJS.prototype._didClose = function (code, reason) {                                                          // 1901\n    postMessage('t', utils.closeFrame(code, reason));                                                             // 1902\n};                                                                                                                // 1903\nFacadeJS.prototype._didMessage = function (frame) {                                                               // 1904\n    postMessage('t', frame);                                                                                      // 1905\n};                                                                                                                // 1906\nFacadeJS.prototype._doSend = function (data) {                                                                    // 1907\n    this._transport.doSend(data);                                                                                 // 1908\n};                                                                                                                // 1909\nFacadeJS.prototype._doCleanup = function () {                                                                     // 1910\n    this._transport.doCleanup();                                                                                  // 1911\n};                                                                                                                // 1912\n                                                                                                                  // 1913\nutils.parent_origin = undefined;                                                                                  // 1914\n                                                                                                                  // 1915\nSockJS.bootstrap_iframe = function() {                                                                            // 1916\n    var facade;                                                                                                   // 1917\n    curr_window_id = _document.location.hash.slice(1);                                                            // 1918\n    var onMessage = function(e) {                                                                                 // 1919\n        if(e.source !== parent) return;                                                                           // 1920\n        if(typeof utils.parent_origin === 'undefined')                                                            // 1921\n            utils.parent_origin = e.origin;                                                                       // 1922\n        if (e.origin !== utils.parent_origin) return;                                                             // 1923\n                                                                                                                  // 1924\n        var window_id = e.data.slice(0, 8);                                                                       // 1925\n        var type = e.data.slice(8, 9);                                                                            // 1926\n        var data = e.data.slice(9);                                                                               // 1927\n        if (window_id !== curr_window_id) return;                                                                 // 1928\n        switch(type) {                                                                                            // 1929\n        case 's':                                                                                                 // 1930\n            var p = JSON.parse(data);                                                                             // 1931\n            var version = p[0];                                                                                   // 1932\n            var protocol = p[1];                                                                                  // 1933\n            var trans_url = p[2];                                                                                 // 1934\n            var base_url = p[3];                                                                                  // 1935\n            if (version !== SockJS.version) {                                                                     // 1936\n                utils.log(\"Incompatibile SockJS! Main site uses:\" +                                               // 1937\n                          \" \\\"\" + version + \"\\\", the iframe:\" +                                                   // 1938\n                          \" \\\"\" + SockJS.version + \"\\\".\");                                                        // 1939\n            }                                                                                                     // 1940\n            if (!utils.flatUrl(trans_url) || !utils.flatUrl(base_url)) {                                          // 1941\n                utils.log(\"Only basic urls are supported in SockJS\");                                             // 1942\n                return;                                                                                           // 1943\n            }                                                                                                     // 1944\n                                                                                                                  // 1945\n            if (!utils.isSameOriginUrl(trans_url) ||                                                              // 1946\n                !utils.isSameOriginUrl(base_url)) {                                                               // 1947\n                utils.log(\"Can't connect to different domain from within an \" +                                   // 1948\n                          \"iframe. (\" + JSON.stringify([_window.location.href, trans_url, base_url]) +            // 1949\n                          \")\");                                                                                   // 1950\n                return;                                                                                           // 1951\n            }                                                                                                     // 1952\n            facade = new FacadeJS();                                                                              // 1953\n            facade._transport = new FacadeJS[protocol](facade, trans_url, base_url);                              // 1954\n            break;                                                                                                // 1955\n        case 'm':                                                                                                 // 1956\n            facade._doSend(data);                                                                                 // 1957\n            break;                                                                                                // 1958\n        case 'c':                                                                                                 // 1959\n            if (facade)                                                                                           // 1960\n                facade._doCleanup();                                                                              // 1961\n            facade = null;                                                                                        // 1962\n            break;                                                                                                // 1963\n        }                                                                                                         // 1964\n    };                                                                                                            // 1965\n                                                                                                                  // 1966\n    // alert('test ticker');                                                                                      // 1967\n    // facade = new FacadeJS();                                                                                   // 1968\n    // facade._transport = new FacadeJS['w-iframe-xhr-polling'](facade, 'http://host.com:9999/ticker/12/basd');   // 1969\n                                                                                                                  // 1970\n    utils.attachMessage(onMessage);                                                                               // 1971\n                                                                                                                  // 1972\n    // Start                                                                                                      // 1973\n    postMessage('s');                                                                                             // 1974\n};                                                                                                                // 1975\n//         [*] End of lib/trans-iframe-within.js                                                                  // 1976\n                                                                                                                  // 1977\n                                                                                                                  // 1978\n//         [*] Including lib/info.js                                                                              // 1979\n/*                                                                                                                // 1980\n * ***** BEGIN LICENSE BLOCK *****                                                                                // 1981\n * Copyright (c) 2011-2012 VMware, Inc.                                                                           // 1982\n *                                                                                                                // 1983\n * For the license see COPYING.                                                                                   // 1984\n * ***** END LICENSE BLOCK *****                                                                                  // 1985\n */                                                                                                               // 1986\n                                                                                                                  // 1987\nvar InfoReceiver = function(base_url, AjaxObject) {                                                               // 1988\n    var that = this;                                                                                              // 1989\n    utils.delay(function(){that.doXhr(base_url, AjaxObject);});                                                   // 1990\n};                                                                                                                // 1991\n                                                                                                                  // 1992\nInfoReceiver.prototype = new EventEmitter(['finish']);                                                            // 1993\n                                                                                                                  // 1994\nInfoReceiver.prototype.doXhr = function(base_url, AjaxObject) {                                                   // 1995\n    var that = this;                                                                                              // 1996\n    var t0 = (new Date()).getTime();                                                                              // 1997\n                                                                                                                  // 1998\n// <METEOR>                                                                                                       // 1999\n  // https://github.com/sockjs/sockjs-client/pull/129                                                             // 2000\n  // var xo = new AjaxObject('GET', base_url + '/info');                                                          // 2001\n                                                                                                                  // 2002\n    var xo = new AjaxObject(                                                                                      // 2003\n      // add cachebusting parameter to url to work around a chrome bug:                                           // 2004\n      // https://code.google.com/p/chromium/issues/detail?id=263981                                               // 2005\n      // or misbehaving proxies.                                                                                  // 2006\n      'GET', base_url + '/info?cb=' + utils.random_string(10))                                                    // 2007\n// </METEOR>                                                                                                      // 2008\n                                                                                                                  // 2009\n    var tref = utils.delay(8000,                                                                                  // 2010\n                           function(){xo.ontimeout();});                                                          // 2011\n                                                                                                                  // 2012\n    xo.onfinish = function(status, text) {                                                                        // 2013\n        clearTimeout(tref);                                                                                       // 2014\n        tref = null;                                                                                              // 2015\n        if (status === 200) {                                                                                     // 2016\n            var rtt = (new Date()).getTime() - t0;                                                                // 2017\n            var info = JSON.parse(text);                                                                          // 2018\n            if (typeof info !== 'object') info = {};                                                              // 2019\n            that.emit('finish', info, rtt);                                                                       // 2020\n        } else {                                                                                                  // 2021\n            that.emit('finish');                                                                                  // 2022\n        }                                                                                                         // 2023\n    };                                                                                                            // 2024\n    xo.ontimeout = function() {                                                                                   // 2025\n        xo.close();                                                                                               // 2026\n        that.emit('finish');                                                                                      // 2027\n    };                                                                                                            // 2028\n};                                                                                                                // 2029\n                                                                                                                  // 2030\nvar InfoReceiverIframe = function(base_url) {                                                                     // 2031\n    var that = this;                                                                                              // 2032\n    var go = function() {                                                                                         // 2033\n        var ifr = new IframeTransport();                                                                          // 2034\n        ifr.protocol = 'w-iframe-info-receiver';                                                                  // 2035\n        var fun = function(r) {                                                                                   // 2036\n            if (typeof r === 'string' && r.substr(0,1) === 'm') {                                                 // 2037\n                var d = JSON.parse(r.substr(1));                                                                  // 2038\n                var info = d[0], rtt = d[1];                                                                      // 2039\n                that.emit('finish', info, rtt);                                                                   // 2040\n            } else {                                                                                              // 2041\n                that.emit('finish');                                                                              // 2042\n            }                                                                                                     // 2043\n            ifr.doCleanup();                                                                                      // 2044\n            ifr = null;                                                                                           // 2045\n        };                                                                                                        // 2046\n        var mock_ri = {                                                                                           // 2047\n            _options: {},                                                                                         // 2048\n            _didClose: fun,                                                                                       // 2049\n            _didMessage: fun                                                                                      // 2050\n        };                                                                                                        // 2051\n        ifr.i_constructor(mock_ri, base_url, base_url);                                                           // 2052\n    }                                                                                                             // 2053\n    if(!_document.body) {                                                                                         // 2054\n        utils.attachEvent('load', go);                                                                            // 2055\n    } else {                                                                                                      // 2056\n        go();                                                                                                     // 2057\n    }                                                                                                             // 2058\n};                                                                                                                // 2059\nInfoReceiverIframe.prototype = new EventEmitter(['finish']);                                                      // 2060\n                                                                                                                  // 2061\n                                                                                                                  // 2062\nvar InfoReceiverFake = function() {                                                                               // 2063\n    // It may not be possible to do cross domain AJAX to get the info                                             // 2064\n    // data, for example for IE7. But we want to run JSONP, so let's                                              // 2065\n    // fake the response, with rtt=2s (rto=6s).                                                                   // 2066\n    var that = this;                                                                                              // 2067\n    utils.delay(function() {                                                                                      // 2068\n        that.emit('finish', {}, 2000);                                                                            // 2069\n    });                                                                                                           // 2070\n};                                                                                                                // 2071\nInfoReceiverFake.prototype = new EventEmitter(['finish']);                                                        // 2072\n                                                                                                                  // 2073\nvar createInfoReceiver = function(base_url) {                                                                     // 2074\n    if (utils.isSameOriginUrl(base_url)) {                                                                        // 2075\n        // If, for some reason, we have SockJS locally - there's no                                               // 2076\n        // need to start up the complex machinery. Just use ajax.                                                 // 2077\n        return new InfoReceiver(base_url, utils.XHRLocalObject);                                                  // 2078\n    }                                                                                                             // 2079\n    switch (utils.isXHRCorsCapable()) {                                                                           // 2080\n    case 1:                                                                                                       // 2081\n        // XHRLocalObject -> no_credentials=true                                                                  // 2082\n        return new InfoReceiver(base_url, utils.XHRLocalObject);                                                  // 2083\n    case 2:                                                                                                       // 2084\n// <METEOR>                                                                                                       // 2085\n// https://github.com/sockjs/sockjs-client/issues/79                                                              // 2086\n        // XDR doesn't work across different schemes                                                              // 2087\n        // http://blogs.msdn.com/b/ieinternals/archive/2010/05/13/xdomainrequest-restrictions-limitations-and-workarounds.aspx\n        if (utils.isSameOriginScheme(base_url))                                                                   // 2089\n            return new InfoReceiver(base_url, utils.XDRObject);                                                   // 2090\n        else                                                                                                      // 2091\n            return new InfoReceiverFake();                                                                        // 2092\n// </METEOR>                                                                                                      // 2093\n    case 3:                                                                                                       // 2094\n        // Opera                                                                                                  // 2095\n        return new InfoReceiverIframe(base_url);                                                                  // 2096\n    default:                                                                                                      // 2097\n        // IE 7                                                                                                   // 2098\n        return new InfoReceiverFake();                                                                            // 2099\n    };                                                                                                            // 2100\n};                                                                                                                // 2101\n                                                                                                                  // 2102\n                                                                                                                  // 2103\nvar WInfoReceiverIframe = FacadeJS['w-iframe-info-receiver'] = function(ri, _trans_url, base_url) {               // 2104\n    var ir = new InfoReceiver(base_url, utils.XHRLocalObject);                                                    // 2105\n    ir.onfinish = function(info, rtt) {                                                                           // 2106\n        ri._didMessage('m'+JSON.stringify([info, rtt]));                                                          // 2107\n        ri._didClose();                                                                                           // 2108\n    }                                                                                                             // 2109\n};                                                                                                                // 2110\nWInfoReceiverIframe.prototype.doCleanup = function() {};                                                          // 2111\n//         [*] End of lib/info.js                                                                                 // 2112\n                                                                                                                  // 2113\n                                                                                                                  // 2114\n//         [*] Including lib/trans-iframe-eventsource.js                                                          // 2115\n/*                                                                                                                // 2116\n * ***** BEGIN LICENSE BLOCK *****                                                                                // 2117\n * Copyright (c) 2011-2012 VMware, Inc.                                                                           // 2118\n *                                                                                                                // 2119\n * For the license see COPYING.                                                                                   // 2120\n * ***** END LICENSE BLOCK *****                                                                                  // 2121\n */                                                                                                               // 2122\n                                                                                                                  // 2123\nvar EventSourceIframeTransport = SockJS['iframe-eventsource'] = function () {                                     // 2124\n    var that = this;                                                                                              // 2125\n    that.protocol = 'w-iframe-eventsource';                                                                       // 2126\n    that.i_constructor.apply(that, arguments);                                                                    // 2127\n};                                                                                                                // 2128\n                                                                                                                  // 2129\nEventSourceIframeTransport.prototype = new IframeTransport();                                                     // 2130\n                                                                                                                  // 2131\nEventSourceIframeTransport.enabled = function () {                                                                // 2132\n    return ('EventSource' in _window) && IframeTransport.enabled();                                               // 2133\n};                                                                                                                // 2134\n                                                                                                                  // 2135\nEventSourceIframeTransport.need_body = true;                                                                      // 2136\nEventSourceIframeTransport.roundTrips = 3; // html, javascript, eventsource                                       // 2137\n                                                                                                                  // 2138\n                                                                                                                  // 2139\n// w-iframe-eventsource                                                                                           // 2140\nvar EventSourceTransport = FacadeJS['w-iframe-eventsource'] = function(ri, trans_url) {                           // 2141\n    this.run(ri, trans_url, '/eventsource', EventSourceReceiver, utils.XHRLocalObject);                           // 2142\n}                                                                                                                 // 2143\nEventSourceTransport.prototype = new AjaxBasedTransport();                                                        // 2144\n//         [*] End of lib/trans-iframe-eventsource.js                                                             // 2145\n                                                                                                                  // 2146\n                                                                                                                  // 2147\n//         [*] Including lib/trans-iframe-xhr-polling.js                                                          // 2148\n/*                                                                                                                // 2149\n * ***** BEGIN LICENSE BLOCK *****                                                                                // 2150\n * Copyright (c) 2011-2012 VMware, Inc.                                                                           // 2151\n *                                                                                                                // 2152\n * For the license see COPYING.                                                                                   // 2153\n * ***** END LICENSE BLOCK *****                                                                                  // 2154\n */                                                                                                               // 2155\n                                                                                                                  // 2156\nvar XhrPollingIframeTransport = SockJS['iframe-xhr-polling'] = function () {                                      // 2157\n    var that = this;                                                                                              // 2158\n    that.protocol = 'w-iframe-xhr-polling';                                                                       // 2159\n    that.i_constructor.apply(that, arguments);                                                                    // 2160\n};                                                                                                                // 2161\n                                                                                                                  // 2162\nXhrPollingIframeTransport.prototype = new IframeTransport();                                                      // 2163\n                                                                                                                  // 2164\nXhrPollingIframeTransport.enabled = function () {                                                                 // 2165\n    return _window.XMLHttpRequest && IframeTransport.enabled();                                                   // 2166\n};                                                                                                                // 2167\n                                                                                                                  // 2168\nXhrPollingIframeTransport.need_body = true;                                                                       // 2169\nXhrPollingIframeTransport.roundTrips = 3; // html, javascript, xhr                                                // 2170\n                                                                                                                  // 2171\n                                                                                                                  // 2172\n// w-iframe-xhr-polling                                                                                           // 2173\nvar XhrPollingITransport = FacadeJS['w-iframe-xhr-polling'] = function(ri, trans_url) {                           // 2174\n    this.run(ri, trans_url, '/xhr', XhrReceiver, utils.XHRLocalObject);                                           // 2175\n};                                                                                                                // 2176\n                                                                                                                  // 2177\nXhrPollingITransport.prototype = new AjaxBasedTransport();                                                        // 2178\n//         [*] End of lib/trans-iframe-xhr-polling.js                                                             // 2179\n                                                                                                                  // 2180\n                                                                                                                  // 2181\n//         [*] Including lib/trans-iframe-htmlfile.js                                                             // 2182\n/*                                                                                                                // 2183\n * ***** BEGIN LICENSE BLOCK *****                                                                                // 2184\n * Copyright (c) 2011-2012 VMware, Inc.                                                                           // 2185\n *                                                                                                                // 2186\n * For the license see COPYING.                                                                                   // 2187\n * ***** END LICENSE BLOCK *****                                                                                  // 2188\n */                                                                                                               // 2189\n                                                                                                                  // 2190\n// This transport generally works in any browser, but will cause a                                                // 2191\n// spinning cursor to appear in any browser other than IE.                                                        // 2192\n// We may test this transport in all browsers - why not, but in                                                   // 2193\n// production it should be only run in IE.                                                                        // 2194\n                                                                                                                  // 2195\nvar HtmlFileIframeTransport = SockJS['iframe-htmlfile'] = function () {                                           // 2196\n    var that = this;                                                                                              // 2197\n    that.protocol = 'w-iframe-htmlfile';                                                                          // 2198\n    that.i_constructor.apply(that, arguments);                                                                    // 2199\n};                                                                                                                // 2200\n                                                                                                                  // 2201\n// Inheritance.                                                                                                   // 2202\nHtmlFileIframeTransport.prototype = new IframeTransport();                                                        // 2203\n                                                                                                                  // 2204\nHtmlFileIframeTransport.enabled = function() {                                                                    // 2205\n    return IframeTransport.enabled();                                                                             // 2206\n};                                                                                                                // 2207\n                                                                                                                  // 2208\nHtmlFileIframeTransport.need_body = true;                                                                         // 2209\nHtmlFileIframeTransport.roundTrips = 3; // html, javascript, htmlfile                                             // 2210\n                                                                                                                  // 2211\n                                                                                                                  // 2212\n// w-iframe-htmlfile                                                                                              // 2213\nvar HtmlFileTransport = FacadeJS['w-iframe-htmlfile'] = function(ri, trans_url) {                                 // 2214\n    this.run(ri, trans_url, '/htmlfile', HtmlfileReceiver, utils.XHRLocalObject);                                 // 2215\n};                                                                                                                // 2216\nHtmlFileTransport.prototype = new AjaxBasedTransport();                                                           // 2217\n//         [*] End of lib/trans-iframe-htmlfile.js                                                                // 2218\n                                                                                                                  // 2219\n                                                                                                                  // 2220\n//         [*] Including lib/trans-polling.js                                                                     // 2221\n/*                                                                                                                // 2222\n * ***** BEGIN LICENSE BLOCK *****                                                                                // 2223\n * Copyright (c) 2011-2012 VMware, Inc.                                                                           // 2224\n *                                                                                                                // 2225\n * For the license see COPYING.                                                                                   // 2226\n * ***** END LICENSE BLOCK *****                                                                                  // 2227\n */                                                                                                               // 2228\n                                                                                                                  // 2229\nvar Polling = function(ri, Receiver, recv_url, AjaxObject) {                                                      // 2230\n    var that = this;                                                                                              // 2231\n    that.ri = ri;                                                                                                 // 2232\n    that.Receiver = Receiver;                                                                                     // 2233\n    that.recv_url = recv_url;                                                                                     // 2234\n    that.AjaxObject = AjaxObject;                                                                                 // 2235\n    that._scheduleRecv();                                                                                         // 2236\n};                                                                                                                // 2237\n                                                                                                                  // 2238\nPolling.prototype._scheduleRecv = function() {                                                                    // 2239\n    var that = this;                                                                                              // 2240\n    var poll = that.poll = new that.Receiver(that.recv_url, that.AjaxObject);                                     // 2241\n    var msg_counter = 0;                                                                                          // 2242\n    poll.onmessage = function(e) {                                                                                // 2243\n        msg_counter += 1;                                                                                         // 2244\n        that.ri._didMessage(e.data);                                                                              // 2245\n    };                                                                                                            // 2246\n    poll.onclose = function(e) {                                                                                  // 2247\n        that.poll = poll = poll.onmessage = poll.onclose = null;                                                  // 2248\n        if (!that.poll_is_closing) {                                                                              // 2249\n            if (e.reason === 'permanent') {                                                                       // 2250\n                that.ri._didClose(1006, 'Polling error (' + e.reason + ')');                                      // 2251\n            } else {                                                                                              // 2252\n                that._scheduleRecv();                                                                             // 2253\n            }                                                                                                     // 2254\n        }                                                                                                         // 2255\n    };                                                                                                            // 2256\n};                                                                                                                // 2257\n                                                                                                                  // 2258\nPolling.prototype.abort = function() {                                                                            // 2259\n    var that = this;                                                                                              // 2260\n    that.poll_is_closing = true;                                                                                  // 2261\n    if (that.poll) {                                                                                              // 2262\n        that.poll.abort();                                                                                        // 2263\n    }                                                                                                             // 2264\n};                                                                                                                // 2265\n//         [*] End of lib/trans-polling.js                                                                        // 2266\n                                                                                                                  // 2267\n                                                                                                                  // 2268\n//         [*] Including lib/trans-receiver-eventsource.js                                                        // 2269\n/*                                                                                                                // 2270\n * ***** BEGIN LICENSE BLOCK *****                                                                                // 2271\n * Copyright (c) 2011-2012 VMware, Inc.                                                                           // 2272\n *                                                                                                                // 2273\n * For the license see COPYING.                                                                                   // 2274\n * ***** END LICENSE BLOCK *****                                                                                  // 2275\n */                                                                                                               // 2276\n                                                                                                                  // 2277\nvar EventSourceReceiver = function(url) {                                                                         // 2278\n    var that = this;                                                                                              // 2279\n    var es = new EventSource(url);                                                                                // 2280\n    es.onmessage = function(e) {                                                                                  // 2281\n        that.dispatchEvent(new SimpleEvent('message',                                                             // 2282\n                                           {'data': unescape(e.data)}));                                          // 2283\n    };                                                                                                            // 2284\n    that.es_close = es.onerror = function(e, abort_reason) {                                                      // 2285\n        // ES on reconnection has readyState = 0 or 1.                                                            // 2286\n        // on network error it's CLOSED = 2                                                                       // 2287\n        var reason = abort_reason ? 'user' :                                                                      // 2288\n            (es.readyState !== 2 ? 'network' : 'permanent');                                                      // 2289\n        that.es_close = es.onmessage = es.onerror = null;                                                         // 2290\n        // EventSource reconnects automatically.                                                                  // 2291\n        es.close();                                                                                               // 2292\n        es = null;                                                                                                // 2293\n        // Safari and chrome < 15 crash if we close window before                                                 // 2294\n        // waiting for ES cleanup. See:                                                                           // 2295\n        //   https://code.google.com/p/chromium/issues/detail?id=89155                                            // 2296\n        utils.delay(200, function() {                                                                             // 2297\n                        that.dispatchEvent(new SimpleEvent('close', {reason: reason}));                           // 2298\n                    });                                                                                           // 2299\n    };                                                                                                            // 2300\n};                                                                                                                // 2301\n                                                                                                                  // 2302\nEventSourceReceiver.prototype = new REventTarget();                                                               // 2303\n                                                                                                                  // 2304\nEventSourceReceiver.prototype.abort = function() {                                                                // 2305\n    var that = this;                                                                                              // 2306\n    if (that.es_close) {                                                                                          // 2307\n        that.es_close({}, true);                                                                                  // 2308\n    }                                                                                                             // 2309\n};                                                                                                                // 2310\n//         [*] End of lib/trans-receiver-eventsource.js                                                           // 2311\n                                                                                                                  // 2312\n                                                                                                                  // 2313\n//         [*] Including lib/trans-receiver-htmlfile.js                                                           // 2314\n/*                                                                                                                // 2315\n * ***** BEGIN LICENSE BLOCK *****                                                                                // 2316\n * Copyright (c) 2011-2012 VMware, Inc.                                                                           // 2317\n *                                                                                                                // 2318\n * For the license see COPYING.                                                                                   // 2319\n * ***** END LICENSE BLOCK *****                                                                                  // 2320\n */                                                                                                               // 2321\n                                                                                                                  // 2322\nvar _is_ie_htmlfile_capable;                                                                                      // 2323\nvar isIeHtmlfileCapable = function() {                                                                            // 2324\n    if (_is_ie_htmlfile_capable === undefined) {                                                                  // 2325\n        if ('ActiveXObject' in _window) {                                                                         // 2326\n            try {                                                                                                 // 2327\n                _is_ie_htmlfile_capable = !!new ActiveXObject('htmlfile');                                        // 2328\n            } catch (x) {}                                                                                        // 2329\n        } else {                                                                                                  // 2330\n            _is_ie_htmlfile_capable = false;                                                                      // 2331\n        }                                                                                                         // 2332\n    }                                                                                                             // 2333\n    return _is_ie_htmlfile_capable;                                                                               // 2334\n};                                                                                                                // 2335\n                                                                                                                  // 2336\n                                                                                                                  // 2337\nvar HtmlfileReceiver = function(url) {                                                                            // 2338\n    var that = this;                                                                                              // 2339\n    utils.polluteGlobalNamespace();                                                                               // 2340\n                                                                                                                  // 2341\n    that.id = 'a' + utils.random_string(6, 26);                                                                   // 2342\n    url += ((url.indexOf('?') === -1) ? '?' : '&') +                                                              // 2343\n        'c=' + escape(WPrefix + '.' + that.id);                                                                   // 2344\n                                                                                                                  // 2345\n    var constructor = isIeHtmlfileCapable() ?                                                                     // 2346\n        utils.createHtmlfile : utils.createIframe;                                                                // 2347\n                                                                                                                  // 2348\n    var iframeObj;                                                                                                // 2349\n    _window[WPrefix][that.id] = {                                                                                 // 2350\n        start: function () {                                                                                      // 2351\n            iframeObj.loaded();                                                                                   // 2352\n        },                                                                                                        // 2353\n        message: function (data) {                                                                                // 2354\n            that.dispatchEvent(new SimpleEvent('message', {'data': data}));                                       // 2355\n        },                                                                                                        // 2356\n        stop: function () {                                                                                       // 2357\n            that.iframe_close({}, 'network');                                                                     // 2358\n        }                                                                                                         // 2359\n    };                                                                                                            // 2360\n    that.iframe_close = function(e, abort_reason) {                                                               // 2361\n        iframeObj.cleanup();                                                                                      // 2362\n        that.iframe_close = iframeObj = null;                                                                     // 2363\n        delete _window[WPrefix][that.id];                                                                         // 2364\n        that.dispatchEvent(new SimpleEvent('close', {reason: abort_reason}));                                     // 2365\n    };                                                                                                            // 2366\n    iframeObj = constructor(url, function(e) {                                                                    // 2367\n                                that.iframe_close({}, 'permanent');                                               // 2368\n                            });                                                                                   // 2369\n};                                                                                                                // 2370\n                                                                                                                  // 2371\nHtmlfileReceiver.prototype = new REventTarget();                                                                  // 2372\n                                                                                                                  // 2373\nHtmlfileReceiver.prototype.abort = function() {                                                                   // 2374\n    var that = this;                                                                                              // 2375\n    if (that.iframe_close) {                                                                                      // 2376\n        that.iframe_close({}, 'user');                                                                            // 2377\n    }                                                                                                             // 2378\n};                                                                                                                // 2379\n//         [*] End of lib/trans-receiver-htmlfile.js                                                              // 2380\n                                                                                                                  // 2381\n                                                                                                                  // 2382\n//         [*] Including lib/trans-receiver-xhr.js                                                                // 2383\n/*                                                                                                                // 2384\n * ***** BEGIN LICENSE BLOCK *****                                                                                // 2385\n * Copyright (c) 2011-2012 VMware, Inc.                                                                           // 2386\n *                                                                                                                // 2387\n * For the license see COPYING.                                                                                   // 2388\n * ***** END LICENSE BLOCK *****                                                                                  // 2389\n */                                                                                                               // 2390\n                                                                                                                  // 2391\nvar XhrReceiver = function(url, AjaxObject) {                                                                     // 2392\n    var that = this;                                                                                              // 2393\n    var buf_pos = 0;                                                                                              // 2394\n                                                                                                                  // 2395\n    that.xo = new AjaxObject('POST', url, null);                                                                  // 2396\n    that.xo.onchunk = function(status, text) {                                                                    // 2397\n        if (status !== 200) return;                                                                               // 2398\n        while (1) {                                                                                               // 2399\n            var buf = text.slice(buf_pos);                                                                        // 2400\n            var p = buf.indexOf('\\n');                                                                            // 2401\n            if (p === -1) break;                                                                                  // 2402\n            buf_pos += p+1;                                                                                       // 2403\n            var msg = buf.slice(0, p);                                                                            // 2404\n            that.dispatchEvent(new SimpleEvent('message', {data: msg}));                                          // 2405\n        }                                                                                                         // 2406\n    };                                                                                                            // 2407\n    that.xo.onfinish = function(status, text) {                                                                   // 2408\n        that.xo.onchunk(status, text);                                                                            // 2409\n        that.xo = null;                                                                                           // 2410\n        var reason = status === 200 ? 'network' : 'permanent';                                                    // 2411\n        that.dispatchEvent(new SimpleEvent('close', {reason: reason}));                                           // 2412\n    }                                                                                                             // 2413\n};                                                                                                                // 2414\n                                                                                                                  // 2415\nXhrReceiver.prototype = new REventTarget();                                                                       // 2416\n                                                                                                                  // 2417\nXhrReceiver.prototype.abort = function() {                                                                        // 2418\n    var that = this;                                                                                              // 2419\n    if (that.xo) {                                                                                                // 2420\n        that.xo.close();                                                                                          // 2421\n        that.dispatchEvent(new SimpleEvent('close', {reason: 'user'}));                                           // 2422\n        that.xo = null;                                                                                           // 2423\n    }                                                                                                             // 2424\n};                                                                                                                // 2425\n//         [*] End of lib/trans-receiver-xhr.js                                                                   // 2426\n                                                                                                                  // 2427\n                                                                                                                  // 2428\n//         [*] Including lib/test-hooks.js                                                                        // 2429\n/*                                                                                                                // 2430\n * ***** BEGIN LICENSE BLOCK *****                                                                                // 2431\n * Copyright (c) 2011-2012 VMware, Inc.                                                                           // 2432\n *                                                                                                                // 2433\n * For the license see COPYING.                                                                                   // 2434\n * ***** END LICENSE BLOCK *****                                                                                  // 2435\n */                                                                                                               // 2436\n                                                                                                                  // 2437\n// For testing                                                                                                    // 2438\nSockJS.getUtils = function(){                                                                                     // 2439\n    return utils;                                                                                                 // 2440\n};                                                                                                                // 2441\n                                                                                                                  // 2442\nSockJS.getIframeTransport = function(){                                                                           // 2443\n    return IframeTransport;                                                                                       // 2444\n};                                                                                                                // 2445\n//         [*] End of lib/test-hooks.js                                                                           // 2446\n                                                                                                                  // 2447\n                  return SockJS;                                                                                  // 2448\n          })();                                                                                                   // 2449\nif ('_sockjs_onload' in window) setTimeout(_sockjs_onload, 1);                                                    // 2450\n                                                                                                                  // 2451\n// AMD compliance                                                                                                 // 2452\nif (typeof define === 'function' && define.amd) {                                                                 // 2453\n    define('sockjs', [], function(){return SockJS;});                                                             // 2454\n}                                                                                                                 // 2455\n//     [*] End of lib/index.js                                                                                    // 2456\n                                                                                                                  // 2457\n// [*] End of lib/all.js                                                                                          // 2458\n                                                                                                                  // 2459\n////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n}).call(this);\n\n\n\n\n\n\n(function(){\n\n////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n//                                                                                                                //\n// packages/ddp-client/stream_client_sockjs.js                                                                    //\n//                                                                                                                //\n////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n                                                                                                                  //\n// @param url {String} URL to Meteor app                                                                          // 1\n//   \"http://subdomain.meteor.com/\" or \"/\" or                                                                     // 2\n//   \"ddp+sockjs://foo-**.meteor.com/sockjs\"                                                                      // 3\nLivedataTest.ClientStream = function (url, options) {                                                             // 4\n  var self = this;                                                                                                // 5\n  self.options = _.extend({                                                                                       // 6\n    retry: true                                                                                                   // 7\n  }, options);                                                                                                    // 8\n  self._initCommon(self.options);                                                                                 // 9\n                                                                                                                  // 10\n  //// Constants                                                                                                  // 11\n                                                                                                                  // 12\n                                                                                                                  // 13\n  // how long between hearing heartbeat from the server until we declare                                          // 14\n  // the connection dead. heartbeats come every 45s (stream_server.js)                                            // 15\n  //                                                                                                              // 16\n  // NOTE: this is a older timeout mechanism. We now send heartbeats at                                           // 17\n  // the DDP level (https://github.com/meteor/meteor/pull/1865), and                                              // 18\n  // expect those timeouts to kill a non-responsive connection before                                             // 19\n  // this timeout fires. This is kept around for compatibility (when                                              // 20\n  // talking to a server that doesn't support DDP heartbeats) and can be                                          // 21\n  // removed later.                                                                                               // 22\n  self.HEARTBEAT_TIMEOUT = 100*1000;                                                                              // 23\n                                                                                                                  // 24\n  self.rawUrl = url;                                                                                              // 25\n  self.socket = null;                                                                                             // 26\n                                                                                                                  // 27\n  self.heartbeatTimer = null;                                                                                     // 28\n                                                                                                                  // 29\n  // Listen to global 'online' event if we are running in a browser.                                              // 30\n  // (IE8 does not support addEventListener)                                                                      // 31\n  if (typeof window !== 'undefined' && window.addEventListener)                                                   // 32\n    window.addEventListener(\"online\", _.bind(self._online, self),                                                 // 33\n                            false /* useCapture. make FF3.6 happy. */);                                           // 34\n                                                                                                                  // 35\n  //// Kickoff!                                                                                                   // 36\n  self._launchConnection();                                                                                       // 37\n};                                                                                                                // 38\n                                                                                                                  // 39\n_.extend(LivedataTest.ClientStream.prototype, {                                                                   // 40\n                                                                                                                  // 41\n  // data is a utf8 string. Data sent while not connected is dropped on                                           // 42\n  // the floor, and it is up the user of this API to retransmit lost                                              // 43\n  // messages on 'reset'                                                                                          // 44\n  send: function (data) {                                                                                         // 45\n    var self = this;                                                                                              // 46\n    if (self.currentStatus.connected) {                                                                           // 47\n      self.socket.send(data);                                                                                     // 48\n    }                                                                                                             // 49\n  },                                                                                                              // 50\n                                                                                                                  // 51\n  // Changes where this connection points                                                                         // 52\n  _changeUrl: function (url) {                                                                                    // 53\n    var self = this;                                                                                              // 54\n    self.rawUrl = url;                                                                                            // 55\n  },                                                                                                              // 56\n                                                                                                                  // 57\n  _connected: function () {                                                                                       // 58\n    var self = this;                                                                                              // 59\n                                                                                                                  // 60\n    if (self.connectionTimer) {                                                                                   // 61\n      clearTimeout(self.connectionTimer);                                                                         // 62\n      self.connectionTimer = null;                                                                                // 63\n    }                                                                                                             // 64\n                                                                                                                  // 65\n    if (self.currentStatus.connected) {                                                                           // 66\n      // already connected. do nothing. this probably shouldn't happen.                                           // 67\n      return;                                                                                                     // 68\n    }                                                                                                             // 69\n                                                                                                                  // 70\n    // update status                                                                                              // 71\n    self.currentStatus.status = \"connected\";                                                                      // 72\n    self.currentStatus.connected = true;                                                                          // 73\n    self.currentStatus.retryCount = 0;                                                                            // 74\n    self.statusChanged();                                                                                         // 75\n                                                                                                                  // 76\n    // fire resets. This must come after status change so that clients                                            // 77\n    // can call send from within a reset callback.                                                                // 78\n    _.each(self.eventCallbacks.reset, function (callback) { callback(); });                                       // 79\n                                                                                                                  // 80\n  },                                                                                                              // 81\n                                                                                                                  // 82\n  _cleanup: function (maybeError) {                                                                               // 83\n    var self = this;                                                                                              // 84\n                                                                                                                  // 85\n    self._clearConnectionAndHeartbeatTimers();                                                                    // 86\n    if (self.socket) {                                                                                            // 87\n      self.socket.onmessage = self.socket.onclose                                                                 // 88\n        = self.socket.onerror = self.socket.onheartbeat = function () {};                                         // 89\n      self.socket.close();                                                                                        // 90\n      self.socket = null;                                                                                         // 91\n    }                                                                                                             // 92\n                                                                                                                  // 93\n    _.each(self.eventCallbacks.disconnect, function (callback) {                                                  // 94\n      callback(maybeError);                                                                                       // 95\n    });                                                                                                           // 96\n  },                                                                                                              // 97\n                                                                                                                  // 98\n  _clearConnectionAndHeartbeatTimers: function () {                                                               // 99\n    var self = this;                                                                                              // 100\n    if (self.connectionTimer) {                                                                                   // 101\n      clearTimeout(self.connectionTimer);                                                                         // 102\n      self.connectionTimer = null;                                                                                // 103\n    }                                                                                                             // 104\n    if (self.heartbeatTimer) {                                                                                    // 105\n      clearTimeout(self.heartbeatTimer);                                                                          // 106\n      self.heartbeatTimer = null;                                                                                 // 107\n    }                                                                                                             // 108\n  },                                                                                                              // 109\n                                                                                                                  // 110\n  _heartbeat_timeout: function () {                                                                               // 111\n    var self = this;                                                                                              // 112\n    Meteor._debug(\"Connection timeout. No sockjs heartbeat received.\");                                           // 113\n    self._lostConnection(new DDP.ConnectionError(\"Heartbeat timed out\"));                                         // 114\n  },                                                                                                              // 115\n                                                                                                                  // 116\n  _heartbeat_received: function () {                                                                              // 117\n    var self = this;                                                                                              // 118\n    // If we've already permanently shut down this stream, the timeout is                                         // 119\n    // already cleared, and we don't need to set it again.                                                        // 120\n    if (self._forcedToDisconnect)                                                                                 // 121\n      return;                                                                                                     // 122\n    if (self.heartbeatTimer)                                                                                      // 123\n      clearTimeout(self.heartbeatTimer);                                                                          // 124\n    self.heartbeatTimer = setTimeout(                                                                             // 125\n      _.bind(self._heartbeat_timeout, self),                                                                      // 126\n      self.HEARTBEAT_TIMEOUT);                                                                                    // 127\n  },                                                                                                              // 128\n                                                                                                                  // 129\n  _sockjsProtocolsWhitelist: function () {                                                                        // 130\n    // only allow polling protocols. no streaming.  streaming                                                     // 131\n    // makes safari spin.                                                                                         // 132\n    var protocolsWhitelist = [                                                                                    // 133\n      'xdr-polling', 'xhr-polling', 'iframe-xhr-polling', 'jsonp-polling'];                                       // 134\n                                                                                                                  // 135\n    // iOS 4 and 5 and below crash when using websockets over certain                                             // 136\n    // proxies. this seems to be resolved with iOS 6. eg                                                          // 137\n    // https://github.com/LearnBoost/socket.io/issues/193#issuecomment-7308865.                                   // 138\n    //                                                                                                            // 139\n    // iOS <4 doesn't support websockets at all so sockjs will just                                               // 140\n    // immediately fall back to http                                                                              // 141\n    var noWebsockets = navigator &&                                                                               // 142\n          /iPhone|iPad|iPod/.test(navigator.userAgent) &&                                                         // 143\n          /OS 4_|OS 5_/.test(navigator.userAgent);                                                                // 144\n                                                                                                                  // 145\n    if (!noWebsockets)                                                                                            // 146\n      protocolsWhitelist = ['websocket'].concat(protocolsWhitelist);                                              // 147\n                                                                                                                  // 148\n    return protocolsWhitelist;                                                                                    // 149\n  },                                                                                                              // 150\n                                                                                                                  // 151\n  _launchConnection: function () {                                                                                // 152\n    var self = this;                                                                                              // 153\n    self._cleanup(); // cleanup the old socket, if there was one.                                                 // 154\n                                                                                                                  // 155\n    var options = _.extend({                                                                                      // 156\n      protocols_whitelist:self._sockjsProtocolsWhitelist()                                                        // 157\n    }, self.options._sockjsOptions);                                                                              // 158\n                                                                                                                  // 159\n    // Convert raw URL to SockJS URL each time we open a connection, so that we                                   // 160\n    // can connect to random hostnames and get around browser per-host                                            // 161\n    // connection limits.                                                                                         // 162\n    self.socket = new SockJS(toSockjsUrl(self.rawUrl), undefined, options);                                       // 163\n    self.socket.onopen = function (data) {                                                                        // 164\n      self._connected();                                                                                          // 165\n    };                                                                                                            // 166\n    self.socket.onmessage = function (data) {                                                                     // 167\n      self._heartbeat_received();                                                                                 // 168\n                                                                                                                  // 169\n      if (self.currentStatus.connected)                                                                           // 170\n        _.each(self.eventCallbacks.message, function (callback) {                                                 // 171\n          callback(data.data);                                                                                    // 172\n        });                                                                                                       // 173\n    };                                                                                                            // 174\n    self.socket.onclose = function () {                                                                           // 175\n      self._lostConnection();                                                                                     // 176\n    };                                                                                                            // 177\n    self.socket.onerror = function () {                                                                           // 178\n      // XXX is this ever called?                                                                                 // 179\n      Meteor._debug(\"stream error\", _.toArray(arguments), (new Date()).toDateString());                           // 180\n    };                                                                                                            // 181\n                                                                                                                  // 182\n    self.socket.onheartbeat =  function () {                                                                      // 183\n      self._heartbeat_received();                                                                                 // 184\n    };                                                                                                            // 185\n                                                                                                                  // 186\n    if (self.connectionTimer)                                                                                     // 187\n      clearTimeout(self.connectionTimer);                                                                         // 188\n    self.connectionTimer = setTimeout(function () {                                                               // 189\n      self._lostConnection(                                                                                       // 190\n        new DDP.ConnectionError(\"DDP connection timed out\"));                                                     // 191\n    }, self.CONNECT_TIMEOUT);                                                                                     // 192\n  }                                                                                                               // 193\n});                                                                                                               // 194\n                                                                                                                  // 195\n////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n}).call(this);\n\n\n\n\n\n\n(function(){\n\n////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n//                                                                                                                //\n// packages/ddp-client/stream_client_common.js                                                                    //\n//                                                                                                                //\n////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n                                                                                                                  //\n// XXX from Underscore.String (http://epeli.github.com/underscore.string/)                                        // 1\nvar startsWith = function(str, starts) {                                                                          // 2\n  return str.length >= starts.length &&                                                                           // 3\n    str.substring(0, starts.length) === starts;                                                                   // 4\n};                                                                                                                // 5\nvar endsWith = function(str, ends) {                                                                              // 6\n  return str.length >= ends.length &&                                                                             // 7\n    str.substring(str.length - ends.length) === ends;                                                             // 8\n};                                                                                                                // 9\n                                                                                                                  // 10\n// @param url {String} URL to Meteor app, eg:                                                                     // 11\n//   \"/\" or \"madewith.meteor.com\" or \"https://foo.meteor.com\"                                                     // 12\n//   or \"ddp+sockjs://ddp--****-foo.meteor.com/sockjs\"                                                            // 13\n// @returns {String} URL to the endpoint with the specific scheme and subPath, e.g.                               // 14\n// for scheme \"http\" and subPath \"sockjs\"                                                                         // 15\n//   \"http://subdomain.meteor.com/sockjs\" or \"/sockjs\"                                                            // 16\n//   or \"https://ddp--1234-foo.meteor.com/sockjs\"                                                                 // 17\nvar translateUrl =  function(url, newSchemeBase, subPath) {                                                       // 18\n  if (! newSchemeBase) {                                                                                          // 19\n    newSchemeBase = \"http\";                                                                                       // 20\n  }                                                                                                               // 21\n                                                                                                                  // 22\n  var ddpUrlMatch = url.match(/^ddp(i?)\\+sockjs:\\/\\//);                                                           // 23\n  var httpUrlMatch = url.match(/^http(s?):\\/\\//);                                                                 // 24\n  var newScheme;                                                                                                  // 25\n  if (ddpUrlMatch) {                                                                                              // 26\n    // Remove scheme and split off the host.                                                                      // 27\n    var urlAfterDDP = url.substr(ddpUrlMatch[0].length);                                                          // 28\n    newScheme = ddpUrlMatch[1] === \"i\" ? newSchemeBase : newSchemeBase + \"s\";                                     // 29\n    var slashPos = urlAfterDDP.indexOf('/');                                                                      // 30\n    var host =                                                                                                    // 31\n          slashPos === -1 ? urlAfterDDP : urlAfterDDP.substr(0, slashPos);                                        // 32\n    var rest = slashPos === -1 ? '' : urlAfterDDP.substr(slashPos);                                               // 33\n                                                                                                                  // 34\n    // In the host (ONLY!), change '*' characters into random digits. This                                        // 35\n    // allows different stream connections to connect to different hostnames                                      // 36\n    // and avoid browser per-hostname connection limits.                                                          // 37\n    host = host.replace(/\\*/g, function () {                                                                      // 38\n      return Math.floor(Random.fraction()*10);                                                                    // 39\n    });                                                                                                           // 40\n                                                                                                                  // 41\n    return newScheme + '://' + host + rest;                                                                       // 42\n  } else if (httpUrlMatch) {                                                                                      // 43\n    newScheme = !httpUrlMatch[1] ? newSchemeBase : newSchemeBase + \"s\";                                           // 44\n    var urlAfterHttp = url.substr(httpUrlMatch[0].length);                                                        // 45\n    url = newScheme + \"://\" + urlAfterHttp;                                                                       // 46\n  }                                                                                                               // 47\n                                                                                                                  // 48\n  // Prefix FQDNs but not relative URLs                                                                           // 49\n  if (url.indexOf(\"://\") === -1 && !startsWith(url, \"/\")) {                                                       // 50\n    url = newSchemeBase + \"://\" + url;                                                                            // 51\n  }                                                                                                               // 52\n                                                                                                                  // 53\n  // XXX This is not what we should be doing: if I have a site                                                    // 54\n  // deployed at \"/foo\", then DDP.connect(\"/\") should actually connect                                            // 55\n  // to \"/\", not to \"/foo\". \"/\" is an absolute path. (Contrast: if                                                // 56\n  // deployed at \"/foo\", it would be reasonable for DDP.connect(\"bar\")                                            // 57\n  // to connect to \"/foo/bar\").                                                                                   // 58\n  //                                                                                                              // 59\n  // We should make this properly honor absolute paths rather than                                                // 60\n  // forcing the path to be relative to the site root. Simultaneously,                                            // 61\n  // we should set DDP_DEFAULT_CONNECTION_URL to include the site                                                 // 62\n  // root. See also client_convenience.js #RationalizingRelativeDDPURLs                                           // 63\n  url = Meteor._relativeToSiteRootUrl(url);                                                                       // 64\n                                                                                                                  // 65\n  if (endsWith(url, \"/\"))                                                                                         // 66\n    return url + subPath;                                                                                         // 67\n  else                                                                                                            // 68\n    return url + \"/\" + subPath;                                                                                   // 69\n};                                                                                                                // 70\n                                                                                                                  // 71\ntoSockjsUrl = function (url) {                                                                                    // 72\n  return translateUrl(url, \"http\", \"sockjs\");                                                                     // 73\n};                                                                                                                // 74\n                                                                                                                  // 75\ntoWebsocketUrl = function (url) {                                                                                 // 76\n  var ret = translateUrl(url, \"ws\", \"websocket\");                                                                 // 77\n  return ret;                                                                                                     // 78\n};                                                                                                                // 79\n                                                                                                                  // 80\nLivedataTest.toSockjsUrl = toSockjsUrl;                                                                           // 81\n                                                                                                                  // 82\n                                                                                                                  // 83\n_.extend(LivedataTest.ClientStream.prototype, {                                                                   // 84\n                                                                                                                  // 85\n  // Register for callbacks.                                                                                      // 86\n  on: function (name, callback) {                                                                                 // 87\n    var self = this;                                                                                              // 88\n                                                                                                                  // 89\n    if (name !== 'message' && name !== 'reset' && name !== 'disconnect')                                          // 90\n      throw new Error(\"unknown event type: \" + name);                                                             // 91\n                                                                                                                  // 92\n    if (!self.eventCallbacks[name])                                                                               // 93\n      self.eventCallbacks[name] = [];                                                                             // 94\n    self.eventCallbacks[name].push(callback);                                                                     // 95\n  },                                                                                                              // 96\n                                                                                                                  // 97\n                                                                                                                  // 98\n  _initCommon: function (options) {                                                                               // 99\n    var self = this;                                                                                              // 100\n    options = options || {};                                                                                      // 101\n                                                                                                                  // 102\n    //// Constants                                                                                                // 103\n                                                                                                                  // 104\n    // how long to wait until we declare the connection attempt                                                   // 105\n    // failed.                                                                                                    // 106\n    self.CONNECT_TIMEOUT = options.connectTimeoutMs || 10000;                                                     // 107\n                                                                                                                  // 108\n    self.eventCallbacks = {}; // name -> [callback]                                                               // 109\n                                                                                                                  // 110\n    self._forcedToDisconnect = false;                                                                             // 111\n                                                                                                                  // 112\n    //// Reactive status                                                                                          // 113\n    self.currentStatus = {                                                                                        // 114\n      status: \"connecting\",                                                                                       // 115\n      connected: false,                                                                                           // 116\n      retryCount: 0                                                                                               // 117\n    };                                                                                                            // 118\n                                                                                                                  // 119\n                                                                                                                  // 120\n    self.statusListeners = typeof Tracker !== 'undefined' && new Tracker.Dependency;                              // 121\n    self.statusChanged = function () {                                                                            // 122\n      if (self.statusListeners)                                                                                   // 123\n        self.statusListeners.changed();                                                                           // 124\n    };                                                                                                            // 125\n                                                                                                                  // 126\n    //// Retry logic                                                                                              // 127\n    self._retry = new Retry;                                                                                      // 128\n    self.connectionTimer = null;                                                                                  // 129\n                                                                                                                  // 130\n  },                                                                                                              // 131\n                                                                                                                  // 132\n  // Trigger a reconnect.                                                                                         // 133\n  reconnect: function (options) {                                                                                 // 134\n    var self = this;                                                                                              // 135\n    options = options || {};                                                                                      // 136\n                                                                                                                  // 137\n    if (options.url) {                                                                                            // 138\n      self._changeUrl(options.url);                                                                               // 139\n    }                                                                                                             // 140\n                                                                                                                  // 141\n    if (options._sockjsOptions) {                                                                                 // 142\n      self.options._sockjsOptions = options._sockjsOptions;                                                       // 143\n    }                                                                                                             // 144\n                                                                                                                  // 145\n    if (self.currentStatus.connected) {                                                                           // 146\n      if (options._force || options.url) {                                                                        // 147\n        // force reconnect.                                                                                       // 148\n        self._lostConnection(new DDP.ForcedReconnectError);                                                       // 149\n      } // else, noop.                                                                                            // 150\n      return;                                                                                                     // 151\n    }                                                                                                             // 152\n                                                                                                                  // 153\n    // if we're mid-connection, stop it.                                                                          // 154\n    if (self.currentStatus.status === \"connecting\") {                                                             // 155\n      // Pretend it's a clean close.                                                                              // 156\n      self._lostConnection();                                                                                     // 157\n    }                                                                                                             // 158\n                                                                                                                  // 159\n    self._retry.clear();                                                                                          // 160\n    self.currentStatus.retryCount -= 1; // don't count manual retries                                             // 161\n    self._retryNow();                                                                                             // 162\n  },                                                                                                              // 163\n                                                                                                                  // 164\n  disconnect: function (options) {                                                                                // 165\n    var self = this;                                                                                              // 166\n    options = options || {};                                                                                      // 167\n                                                                                                                  // 168\n    // Failed is permanent. If we're failed, don't let people go back                                             // 169\n    // online by calling 'disconnect' then 'reconnect'.                                                           // 170\n    if (self._forcedToDisconnect)                                                                                 // 171\n      return;                                                                                                     // 172\n                                                                                                                  // 173\n    // If _permanent is set, permanently disconnect a stream. Once a stream                                       // 174\n    // is forced to disconnect, it can never reconnect. This is for                                               // 175\n    // error cases such as ddp version mismatch, where trying again                                               // 176\n    // won't fix the problem.                                                                                     // 177\n    if (options._permanent) {                                                                                     // 178\n      self._forcedToDisconnect = true;                                                                            // 179\n    }                                                                                                             // 180\n                                                                                                                  // 181\n    self._cleanup();                                                                                              // 182\n    self._retry.clear();                                                                                          // 183\n                                                                                                                  // 184\n    self.currentStatus = {                                                                                        // 185\n      status: (options._permanent ? \"failed\" : \"offline\"),                                                        // 186\n      connected: false,                                                                                           // 187\n      retryCount: 0                                                                                               // 188\n    };                                                                                                            // 189\n                                                                                                                  // 190\n    if (options._permanent && options._error)                                                                     // 191\n      self.currentStatus.reason = options._error;                                                                 // 192\n                                                                                                                  // 193\n    self.statusChanged();                                                                                         // 194\n  },                                                                                                              // 195\n                                                                                                                  // 196\n  // maybeError is set unless it's a clean protocol-level close.                                                  // 197\n  _lostConnection: function (maybeError) {                                                                        // 198\n    var self = this;                                                                                              // 199\n                                                                                                                  // 200\n    self._cleanup(maybeError);                                                                                    // 201\n    self._retryLater(maybeError); // sets status. no need to do it here.                                          // 202\n  },                                                                                                              // 203\n                                                                                                                  // 204\n  // fired when we detect that we've gone online. try to reconnect                                                // 205\n  // immediately.                                                                                                 // 206\n  _online: function () {                                                                                          // 207\n    // if we've requested to be offline by disconnecting, don't reconnect.                                        // 208\n    if (this.currentStatus.status != \"offline\")                                                                   // 209\n      this.reconnect();                                                                                           // 210\n  },                                                                                                              // 211\n                                                                                                                  // 212\n  _retryLater: function (maybeError) {                                                                            // 213\n    var self = this;                                                                                              // 214\n                                                                                                                  // 215\n    var timeout = 0;                                                                                              // 216\n    if (self.options.retry ||                                                                                     // 217\n        (maybeError && maybeError.errorType === \"DDP.ForcedReconnectError\")) {                                    // 218\n      timeout = self._retry.retryLater(                                                                           // 219\n        self.currentStatus.retryCount,                                                                            // 220\n        _.bind(self._retryNow, self)                                                                              // 221\n      );                                                                                                          // 222\n      self.currentStatus.status = \"waiting\";                                                                      // 223\n      self.currentStatus.retryTime = (new Date()).getTime() + timeout;                                            // 224\n    } else {                                                                                                      // 225\n      self.currentStatus.status = \"failed\";                                                                       // 226\n      delete self.currentStatus.retryTime;                                                                        // 227\n    }                                                                                                             // 228\n                                                                                                                  // 229\n    self.currentStatus.connected = false;                                                                         // 230\n    self.statusChanged();                                                                                         // 231\n  },                                                                                                              // 232\n                                                                                                                  // 233\n  _retryNow: function () {                                                                                        // 234\n    var self = this;                                                                                              // 235\n                                                                                                                  // 236\n    if (self._forcedToDisconnect)                                                                                 // 237\n      return;                                                                                                     // 238\n                                                                                                                  // 239\n    self.currentStatus.retryCount += 1;                                                                           // 240\n    self.currentStatus.status = \"connecting\";                                                                     // 241\n    self.currentStatus.connected = false;                                                                         // 242\n    delete self.currentStatus.retryTime;                                                                          // 243\n    self.statusChanged();                                                                                         // 244\n                                                                                                                  // 245\n    self._launchConnection();                                                                                     // 246\n  },                                                                                                              // 247\n                                                                                                                  // 248\n                                                                                                                  // 249\n  // Get current status. Reactive.                                                                                // 250\n  status: function () {                                                                                           // 251\n    var self = this;                                                                                              // 252\n    if (self.statusListeners)                                                                                     // 253\n      self.statusListeners.depend();                                                                              // 254\n    return self.currentStatus;                                                                                    // 255\n  }                                                                                                               // 256\n});                                                                                                               // 257\n                                                                                                                  // 258\nDDP.ConnectionError = Meteor.makeErrorType(                                                                       // 259\n  \"DDP.ConnectionError\", function (message) {                                                                     // 260\n    var self = this;                                                                                              // 261\n    self.message = message;                                                                                       // 262\n});                                                                                                               // 263\n                                                                                                                  // 264\nDDP.ForcedReconnectError = Meteor.makeErrorType(                                                                  // 265\n  \"DDP.ForcedReconnectError\", function () {});                                                                    // 266\n                                                                                                                  // 267\n////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n}).call(this);\n\n\n\n\n\n\n(function(){\n\n////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n//                                                                                                                //\n// packages/ddp-client/livedata_common.js                                                                         //\n//                                                                                                                //\n////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n                                                                                                                  //\nLivedataTest.SUPPORTED_DDP_VERSIONS = DDPCommon.SUPPORTED_DDP_VERSIONS;                                           // 1\n                                                                                                                  // 2\n// This is private but it's used in a few places. accounts-base uses                                              // 3\n// it to get the current user. Meteor.setTimeout and friends clear                                                // 4\n// it. We can probably find a better way to factor this.                                                          // 5\nDDP._CurrentInvocation = new Meteor.EnvironmentVariable;                                                          // 6\n                                                                                                                  // 7\n////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n}).call(this);\n\n\n\n\n\n\n(function(){\n\n////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n//                                                                                                                //\n// packages/ddp-client/random_stream.js                                                                           //\n//                                                                                                                //\n////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n                                                                                                                  //\n// Returns the named sequence of pseudo-random values.                                                            // 1\n// The scope will be DDP._CurrentInvocation.get(), so the stream will produce                                     // 2\n// consistent values for method calls on the client and server.                                                   // 3\nDDP.randomStream = function (name) {                                                                              // 4\n  var scope = DDP._CurrentInvocation.get();                                                                       // 5\n  return DDPCommon.RandomStream.get(scope, name);                                                                 // 6\n};                                                                                                                // 7\n                                                                                                                  // 8\n                                                                                                                  // 9\n                                                                                                                  // 10\n////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n}).call(this);\n\n\n\n\n\n\n(function(){\n\n////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n//                                                                                                                //\n// packages/ddp-client/livedata_connection.js                                                                     //\n//                                                                                                                //\n////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n                                                                                                                  //\nif (Meteor.isServer) {                                                                                            // 1\n  var path = Npm.require('path');                                                                                 // 2\n  var Fiber = Npm.require('fibers');                                                                              // 3\n  var Future = Npm.require(path.join('fibers', 'future'));                                                        // 4\n}                                                                                                                 // 5\n                                                                                                                  // 6\n// @param url {String|Object} URL to Meteor app,                                                                  // 7\n//   or an object as a test hook (see code)                                                                       // 8\n// Options:                                                                                                       // 9\n//   reloadWithOutstanding: is it OK to reload if there are outstanding methods?                                  // 10\n//   headers: extra headers to send on the websockets connection, for                                             // 11\n//     server-to-server DDP only                                                                                  // 12\n//   _sockjsOptions: Specifies options to pass through to the sockjs client                                       // 13\n//   onDDPNegotiationVersionFailure: callback when version negotiation fails.                                     // 14\n//                                                                                                                // 15\n// XXX There should be a way to destroy a DDP connection, causing all                                             // 16\n// outstanding method calls to fail.                                                                              // 17\n//                                                                                                                // 18\n// XXX Our current way of handling failure and reconnection is great                                              // 19\n// for an app (where we want to tolerate being disconnected as an                                                 // 20\n// expect state, and keep trying forever to reconnect) but cumbersome                                             // 21\n// for something like a command line tool that wants to make a                                                    // 22\n// connection, call a method, and print an error if connection                                                    // 23\n// fails. We should have better usability in the latter case (while                                               // 24\n// still transparently reconnecting if it's just a transient failure                                              // 25\n// or the server migrating us).                                                                                   // 26\nvar Connection = function (url, options) {                                                                        // 27\n  var self = this;                                                                                                // 28\n  options = _.extend({                                                                                            // 29\n    onConnected: function () {},                                                                                  // 30\n    onDDPVersionNegotiationFailure: function (description) {                                                      // 31\n      Meteor._debug(description);                                                                                 // 32\n    },                                                                                                            // 33\n    heartbeatInterval: 17500,                                                                                     // 34\n    heartbeatTimeout: 15000,                                                                                      // 35\n    npmFayeOptions: {},                                                                                           // 36\n    // These options are only for testing.                                                                        // 37\n    reloadWithOutstanding: false,                                                                                 // 38\n    supportedDDPVersions: DDPCommon.SUPPORTED_DDP_VERSIONS,                                                       // 39\n    retry: true,                                                                                                  // 40\n    respondToPings: true                                                                                          // 41\n  }, options);                                                                                                    // 42\n                                                                                                                  // 43\n  // If set, called when we reconnect, queuing method calls _before_ the                                          // 44\n  // existing outstanding ones. This is the only data member that is part of the                                  // 45\n  // public API!                                                                                                  // 46\n  self.onReconnect = null;                                                                                        // 47\n                                                                                                                  // 48\n  // as a test hook, allow passing a stream instead of a url.                                                     // 49\n  if (typeof url === \"object\") {                                                                                  // 50\n    self._stream = url;                                                                                           // 51\n  } else {                                                                                                        // 52\n    self._stream = new LivedataTest.ClientStream(url, {                                                           // 53\n      retry: options.retry,                                                                                       // 54\n      headers: options.headers,                                                                                   // 55\n      _sockjsOptions: options._sockjsOptions,                                                                     // 56\n      // Used to keep some tests quiet, or for other cases in which                                               // 57\n      // the right thing to do with connection errors is to silently                                              // 58\n      // fail (e.g. sending package usage stats). At some point we                                                // 59\n      // should have a real API for handling client-stream-level                                                  // 60\n      // errors.                                                                                                  // 61\n      _dontPrintErrors: options._dontPrintErrors,                                                                 // 62\n      connectTimeoutMs: options.connectTimeoutMs,                                                                 // 63\n      npmFayeOptions: options.npmFayeOptions                                                                      // 64\n    });                                                                                                           // 65\n  }                                                                                                               // 66\n                                                                                                                  // 67\n  self._lastSessionId = null;                                                                                     // 68\n  self._versionSuggestion = null;  // The last proposed DDP version.                                              // 69\n  self._version = null;   // The DDP version agreed on by client and server.                                      // 70\n  self._stores = {}; // name -> object with methods                                                               // 71\n  self._methodHandlers = {}; // name -> func                                                                      // 72\n  self._nextMethodId = 1;                                                                                         // 73\n  self._supportedDDPVersions = options.supportedDDPVersions;                                                      // 74\n                                                                                                                  // 75\n  self._heartbeatInterval = options.heartbeatInterval;                                                            // 76\n  self._heartbeatTimeout = options.heartbeatTimeout;                                                              // 77\n                                                                                                                  // 78\n  // Tracks methods which the user has tried to call but which have not yet                                       // 79\n  // called their user callback (ie, they are waiting on their result or for all                                  // 80\n  // of their writes to be written to the local cache). Map from method ID to                                     // 81\n  // MethodInvoker object.                                                                                        // 82\n  self._methodInvokers = {};                                                                                      // 83\n                                                                                                                  // 84\n  // Tracks methods which the user has called but whose result messages have not                                  // 85\n  // arrived yet.                                                                                                 // 86\n  //                                                                                                              // 87\n  // _outstandingMethodBlocks is an array of blocks of methods. Each block                                        // 88\n  // represents a set of methods that can run at the same time. The first block                                   // 89\n  // represents the methods which are currently in flight; subsequent blocks                                      // 90\n  // must wait for previous blocks to be fully finished before they can be sent                                   // 91\n  // to the server.                                                                                               // 92\n  //                                                                                                              // 93\n  // Each block is an object with the following fields:                                                           // 94\n  // - methods: a list of MethodInvoker objects                                                                   // 95\n  // - wait: a boolean; if true, this block had a single method invoked with                                      // 96\n  //         the \"wait\" option                                                                                    // 97\n  //                                                                                                              // 98\n  // There will never be adjacent blocks with wait=false, because the only thing                                  // 99\n  // that makes methods need to be serialized is a wait method.                                                   // 100\n  //                                                                                                              // 101\n  // Methods are removed from the first block when their \"result\" is                                              // 102\n  // received. The entire first block is only removed when all of the in-flight                                   // 103\n  // methods have received their results (so the \"methods\" list is empty) *AND*                                   // 104\n  // all of the data written by those methods are visible in the local cache. So                                  // 105\n  // it is possible for the first block's methods list to be empty, if we are                                     // 106\n  // still waiting for some objects to quiesce.                                                                   // 107\n  //                                                                                                              // 108\n  // Example:                                                                                                     // 109\n  //  _outstandingMethodBlocks = [                                                                                // 110\n  //    {wait: false, methods: []},                                                                               // 111\n  //    {wait: true, methods: [<MethodInvoker for 'login'>]},                                                     // 112\n  //    {wait: false, methods: [<MethodInvoker for 'foo'>,                                                        // 113\n  //                            <MethodInvoker for 'bar'>]}]                                                      // 114\n  // This means that there were some methods which were sent to the server and                                    // 115\n  // which have returned their results, but some of the data written by                                           // 116\n  // the methods may not be visible in the local cache. Once all that data is                                     // 117\n  // visible, we will send a 'login' method. Once the login method has returned                                   // 118\n  // and all the data is visible (including re-running subs if userId changes),                                   // 119\n  // we will send the 'foo' and 'bar' methods in parallel.                                                        // 120\n  self._outstandingMethodBlocks = [];                                                                             // 121\n                                                                                                                  // 122\n  // method ID -> array of objects with keys 'collection' and 'id', listing                                       // 123\n  // documents written by a given method's stub. keys are associated with                                         // 124\n  // methods whose stub wrote at least one document, and whose data-done message                                  // 125\n  // has not yet been received.                                                                                   // 126\n  self._documentsWrittenByStub = {};                                                                              // 127\n  // collection -> IdMap of \"server document\" object. A \"server document\" has:                                    // 128\n  // - \"document\": the version of the document according the                                                      // 129\n  //   server (ie, the snapshot before a stub wrote it, amended by any changes                                    // 130\n  //   received from the server)                                                                                  // 131\n  //   It is undefined if we think the document does not exist                                                    // 132\n  // - \"writtenByStubs\": a set of method IDs whose stubs wrote to the document                                    // 133\n  //   whose \"data done\" messages have not yet been processed                                                     // 134\n  self._serverDocuments = {};                                                                                     // 135\n                                                                                                                  // 136\n  // Array of callbacks to be called after the next update of the local                                           // 137\n  // cache. Used for:                                                                                             // 138\n  //  - Calling methodInvoker.dataVisible and sub ready callbacks after                                           // 139\n  //    the relevant data is flushed.                                                                             // 140\n  //  - Invoking the callbacks of \"half-finished\" methods after reconnect                                         // 141\n  //    quiescence. Specifically, methods whose result was received over the old                                  // 142\n  //    connection (so we don't re-send it) but whose data had not been made                                      // 143\n  //    visible.                                                                                                  // 144\n  self._afterUpdateCallbacks = [];                                                                                // 145\n                                                                                                                  // 146\n  // In two contexts, we buffer all incoming data messages and then process them                                  // 147\n  // all at once in a single update:                                                                              // 148\n  //   - During reconnect, we buffer all data messages until all subs that had                                    // 149\n  //     been ready before reconnect are ready again, and all methods that are                                    // 150\n  //     active have returned their \"data done message\"; then                                                     // 151\n  //   - During the execution of a \"wait\" method, we buffer all data messages                                     // 152\n  //     until the wait method gets its \"data done\" message. (If the wait method                                  // 153\n  //     occurs during reconnect, it doesn't get any special handling.)                                           // 154\n  // all data messages are processed in one update.                                                               // 155\n  //                                                                                                              // 156\n  // The following fields are used for this \"quiescence\" process.                                                 // 157\n                                                                                                                  // 158\n  // This buffers the messages that aren't being processed yet.                                                   // 159\n  self._messagesBufferedUntilQuiescence = [];                                                                     // 160\n  // Map from method ID -> true. Methods are removed from this when their                                         // 161\n  // \"data done\" message is received, and we will not quiesce until it is                                         // 162\n  // empty.                                                                                                       // 163\n  self._methodsBlockingQuiescence = {};                                                                           // 164\n  // map from sub ID -> true for subs that were ready (ie, called the sub                                         // 165\n  // ready callback) before reconnect but haven't become ready again yet                                          // 166\n  self._subsBeingRevived = {}; // map from sub._id -> true                                                        // 167\n  // if true, the next data update should reset all stores. (set during                                           // 168\n  // reconnect.)                                                                                                  // 169\n  self._resetStores = false;                                                                                      // 170\n                                                                                                                  // 171\n  // name -> array of updates for (yet to be created) collections                                                 // 172\n  self._updatesForUnknownStores = {};                                                                             // 173\n  // if we're blocking a migration, the retry func                                                                // 174\n  self._retryMigrate = null;                                                                                      // 175\n                                                                                                                  // 176\n  // metadata for subscriptions.  Map from sub ID to object with keys:                                            // 177\n  //   - id                                                                                                       // 178\n  //   - name                                                                                                     // 179\n  //   - params                                                                                                   // 180\n  //   - inactive (if true, will be cleaned up if not reused in re-run)                                           // 181\n  //   - ready (has the 'ready' message been received?)                                                           // 182\n  //   - readyCallback (an optional callback to call when ready)                                                  // 183\n  //   - errorCallback (an optional callback to call if the sub terminates with                                   // 184\n  //                    an error, XXX COMPAT WITH 1.0.3.1)                                                        // 185\n  //   - stopCallback (an optional callback to call when the sub terminates                                       // 186\n  //     for any reason, with an error argument if an error triggered the stop)                                   // 187\n  self._subscriptions = {};                                                                                       // 188\n                                                                                                                  // 189\n  // Reactive userId.                                                                                             // 190\n  self._userId = null;                                                                                            // 191\n  self._userIdDeps = new Tracker.Dependency;                                                                      // 192\n                                                                                                                  // 193\n  // Block auto-reload while we're waiting for method responses.                                                  // 194\n  if (Meteor.isClient && Package.reload && !options.reloadWithOutstanding) {                                      // 195\n    Package.reload.Reload._onMigrate(function (retry) {                                                           // 196\n      if (!self._readyToMigrate()) {                                                                              // 197\n        if (self._retryMigrate)                                                                                   // 198\n          throw new Error(\"Two migrations in progress?\");                                                         // 199\n        self._retryMigrate = retry;                                                                               // 200\n        return false;                                                                                             // 201\n      } else {                                                                                                    // 202\n        return [true];                                                                                            // 203\n      }                                                                                                           // 204\n    });                                                                                                           // 205\n  }                                                                                                               // 206\n                                                                                                                  // 207\n  var onMessage = function (raw_msg) {                                                                            // 208\n    try {                                                                                                         // 209\n      var msg = DDPCommon.parseDDP(raw_msg);                                                                      // 210\n    } catch (e) {                                                                                                 // 211\n      Meteor._debug(\"Exception while parsing DDP\", e);                                                            // 212\n      return;                                                                                                     // 213\n    }                                                                                                             // 214\n                                                                                                                  // 215\n    // Any message counts as receiving a pong, as it demonstrates that                                            // 216\n    // the server is still alive.                                                                                 // 217\n    if (self._heartbeat) {                                                                                        // 218\n      self._heartbeat.messageReceived();                                                                          // 219\n    }                                                                                                             // 220\n                                                                                                                  // 221\n    if (msg === null || !msg.msg) {                                                                               // 222\n      // XXX COMPAT WITH 0.6.6. ignore the old welcome message for back                                           // 223\n      // compat.  Remove this 'if' once the server stops sending welcome                                          // 224\n      // messages (stream_server.js).                                                                             // 225\n      if (! (msg && msg.server_id))                                                                               // 226\n        Meteor._debug(\"discarding invalid livedata message\", msg);                                                // 227\n      return;                                                                                                     // 228\n    }                                                                                                             // 229\n                                                                                                                  // 230\n    if (msg.msg === 'connected') {                                                                                // 231\n      self._version = self._versionSuggestion;                                                                    // 232\n      self._livedata_connected(msg);                                                                              // 233\n      options.onConnected();                                                                                      // 234\n    }                                                                                                             // 235\n    else if (msg.msg === 'failed') {                                                                              // 236\n      if (_.contains(self._supportedDDPVersions, msg.version)) {                                                  // 237\n        self._versionSuggestion = msg.version;                                                                    // 238\n        self._stream.reconnect({_force: true});                                                                   // 239\n      } else {                                                                                                    // 240\n        var description =                                                                                         // 241\n              \"DDP version negotiation failed; server requested version \" + msg.version;                          // 242\n        self._stream.disconnect({_permanent: true, _error: description});                                         // 243\n        options.onDDPVersionNegotiationFailure(description);                                                      // 244\n      }                                                                                                           // 245\n    }                                                                                                             // 246\n    else if (msg.msg === 'ping' && options.respondToPings) {                                                      // 247\n      self._send({msg: \"pong\", id: msg.id});                                                                      // 248\n    }                                                                                                             // 249\n    else if (msg.msg === 'pong') {                                                                                // 250\n      // noop, as we assume everything's a pong                                                                   // 251\n    }                                                                                                             // 252\n    else if (_.include(['added', 'changed', 'removed', 'ready', 'updated'], msg.msg))                             // 253\n      self._livedata_data(msg);                                                                                   // 254\n    else if (msg.msg === 'nosub')                                                                                 // 255\n      self._livedata_nosub(msg);                                                                                  // 256\n    else if (msg.msg === 'result')                                                                                // 257\n      self._livedata_result(msg);                                                                                 // 258\n    else if (msg.msg === 'error')                                                                                 // 259\n      self._livedata_error(msg);                                                                                  // 260\n    else                                                                                                          // 261\n      Meteor._debug(\"discarding unknown livedata message type\", msg);                                             // 262\n  };                                                                                                              // 263\n                                                                                                                  // 264\n  var onReset = function () {                                                                                     // 265\n    // Send a connect message at the beginning of the stream.                                                     // 266\n    // NOTE: reset is called even on the first connection, so this is                                             // 267\n    // the only place we send this message.                                                                       // 268\n    var msg = {msg: 'connect'};                                                                                   // 269\n    if (self._lastSessionId)                                                                                      // 270\n      msg.session = self._lastSessionId;                                                                          // 271\n    msg.version = self._versionSuggestion || self._supportedDDPVersions[0];                                       // 272\n    self._versionSuggestion = msg.version;                                                                        // 273\n    msg.support = self._supportedDDPVersions;                                                                     // 274\n    self._send(msg);                                                                                              // 275\n                                                                                                                  // 276\n    // Mark non-retry calls as failed. This has to be done early as getting these methods out of the              // 277\n    // current block is pretty important to making sure that quiescence is properly calculated, as                // 278\n    // well as possibly moving on to another useful block.                                                        // 279\n                                                                                                                  // 280\n    // Only bother testing if there is an outstandingMethodBlock (there might not be, especially if               // 281\n    // we are connecting for the first time.                                                                      // 282\n    if (self._outstandingMethodBlocks.length > 0) {                                                               // 283\n      // If there is an outstanding method block, we only care about the first one as that is the                 // 284\n      // one that could have already sent messages with no response, that are not allowed to retry.               // 285\n      _.each(self._outstandingMethodBlocks[0].methods, function(methodInvoker) {                                  // 286\n        // If the message wasn't sent or it's allowed to retry, do nothing.                                       // 287\n        if (methodInvoker.sentMessage && methodInvoker.noRetry) {                                                 // 288\n          // The next loop serves to get the index in the current method block of this method.                    // 289\n          var currentMethodBlock = self._outstandingMethodBlocks[0].methods;                                      // 290\n          var loopMethod;                                                                                         // 291\n          for (var i = 0; i < currentMethodBlock.length; i++) {                                                   // 292\n            loopMethod = currentMethodBlock[i];                                                                   // 293\n            if (loopMethod.methodId === methodInvoker.methodId) {                                                 // 294\n              break;                                                                                              // 295\n            }                                                                                                     // 296\n          }                                                                                                       // 297\n                                                                                                                  // 298\n          // Remove from current method block. This may leave the block empty, but we                             // 299\n          // don't move on to the next block until the callback has been delivered, in                            // 300\n          // _outstandingMethodFinished.                                                                          // 301\n          currentMethodBlock.splice(i, 1);                                                                        // 302\n                                                                                                                  // 303\n          // Make sure that the method is told that it failed.                                                    // 304\n          methodInvoker.receiveResult(Meteor.Error('invocation-failed',                                           // 305\n            'Method invocation might have failed due to dropped connection. ' +                                   // 306\n            'Failing because `noRetry` option was passed to Meteor.apply.'));                                     // 307\n        }                                                                                                         // 308\n      });                                                                                                         // 309\n    }                                                                                                             // 310\n                                                                                                                  // 311\n    // Now, to minimize setup latency, go ahead and blast out all of                                              // 312\n    // our pending methods ands subscriptions before we've even taken                                             // 313\n    // the necessary RTT to know if we successfully reconnected. (1)                                              // 314\n    // They're supposed to be idempotent, and where they are not,                                                 // 315\n    // they can block retry in apply; (2) even if we did reconnect,                                               // 316\n    // we're not sure what messages might have gotten lost                                                        // 317\n    // (in either direction) since we were disconnected (TCP being                                                // 318\n    // sloppy about that.)                                                                                        // 319\n                                                                                                                  // 320\n    // If the current block of methods all got their results (but didn't all get                                  // 321\n    // their data visible), discard the empty block now.                                                          // 322\n    if (! _.isEmpty(self._outstandingMethodBlocks) &&                                                             // 323\n        _.isEmpty(self._outstandingMethodBlocks[0].methods)) {                                                    // 324\n      self._outstandingMethodBlocks.shift();                                                                      // 325\n    }                                                                                                             // 326\n                                                                                                                  // 327\n    // Mark all messages as unsent, they have not yet been sent on this                                           // 328\n    // connection.                                                                                                // 329\n    _.each(self._methodInvokers, function (m) {                                                                   // 330\n      m.sentMessage = false;                                                                                      // 331\n    });                                                                                                           // 332\n                                                                                                                  // 333\n    // If an `onReconnect` handler is set, call it first. Go through                                              // 334\n    // some hoops to ensure that methods that are called from within                                              // 335\n    // `onReconnect` get executed _before_ ones that were originally                                              // 336\n    // outstanding (since `onReconnect` is used to re-establish auth                                              // 337\n    // certificates)                                                                                              // 338\n    if (self.onReconnect)                                                                                         // 339\n      self._callOnReconnectAndSendAppropriateOutstandingMethods();                                                // 340\n    else                                                                                                          // 341\n      self._sendOutstandingMethods();                                                                             // 342\n                                                                                                                  // 343\n    // add new subscriptions at the end. this way they take effect after                                          // 344\n    // the handlers and we don't see flicker.                                                                     // 345\n    _.each(self._subscriptions, function (sub, id) {                                                              // 346\n      self._send({                                                                                                // 347\n        msg: 'sub',                                                                                               // 348\n        id: id,                                                                                                   // 349\n        name: sub.name,                                                                                           // 350\n        params: sub.params                                                                                        // 351\n      });                                                                                                         // 352\n    });                                                                                                           // 353\n  };                                                                                                              // 354\n                                                                                                                  // 355\n  var onDisconnect = function () {                                                                                // 356\n    if (self._heartbeat) {                                                                                        // 357\n      self._heartbeat.stop();                                                                                     // 358\n      self._heartbeat = null;                                                                                     // 359\n    }                                                                                                             // 360\n  };                                                                                                              // 361\n                                                                                                                  // 362\n  if (Meteor.isServer) {                                                                                          // 363\n    self._stream.on('message', Meteor.bindEnvironment(onMessage, \"handling DDP message\"));                        // 364\n    self._stream.on('reset', Meteor.bindEnvironment(onReset, \"handling DDP reset\"));                              // 365\n    self._stream.on('disconnect', Meteor.bindEnvironment(onDisconnect, \"handling DDP disconnect\"));               // 366\n  } else {                                                                                                        // 367\n    self._stream.on('message', onMessage);                                                                        // 368\n    self._stream.on('reset', onReset);                                                                            // 369\n    self._stream.on('disconnect', onDisconnect);                                                                  // 370\n  }                                                                                                               // 371\n};                                                                                                                // 372\n                                                                                                                  // 373\n// A MethodInvoker manages sending a method to the server and calling the user's                                  // 374\n// callbacks. On construction, it registers itself in the connection's                                            // 375\n// _methodInvokers map; it removes itself once the method is fully finished and                                   // 376\n// the callback is invoked. This occurs when it has both received a result,                                       // 377\n// and the data written by it is fully visible.                                                                   // 378\nvar MethodInvoker = function (options) {                                                                          // 379\n  var self = this;                                                                                                // 380\n                                                                                                                  // 381\n  // Public (within this file) fields.                                                                            // 382\n  self.methodId = options.methodId;                                                                               // 383\n  self.sentMessage = false;                                                                                       // 384\n                                                                                                                  // 385\n  self._callback = options.callback;                                                                              // 386\n  self._connection = options.connection;                                                                          // 387\n  self._message = options.message;                                                                                // 388\n  self._onResultReceived = options.onResultReceived || function () {};                                            // 389\n  self._wait = options.wait;                                                                                      // 390\n  self.noRetry = options.noRetry;                                                                                 // 391\n  self._methodResult = null;                                                                                      // 392\n  self._dataVisible = false;                                                                                      // 393\n                                                                                                                  // 394\n  // Register with the connection.                                                                                // 395\n  self._connection._methodInvokers[self.methodId] = self;                                                         // 396\n};                                                                                                                // 397\n_.extend(MethodInvoker.prototype, {                                                                               // 398\n  // Sends the method message to the server. May be called additional times if                                    // 399\n  // we lose the connection and reconnect before receiving a result.                                              // 400\n  sendMessage: function () {                                                                                      // 401\n    var self = this;                                                                                              // 402\n    // This function is called before sending a method (including resending on                                    // 403\n    // reconnect). We should only (re)send methods where we don't already have a                                  // 404\n    // result!                                                                                                    // 405\n    if (self.gotResult())                                                                                         // 406\n      throw new Error(\"sendingMethod is called on method with result\");                                           // 407\n                                                                                                                  // 408\n                                                                                                                  // 409\n    // If we're re-sending it, it doesn't matter if data was written the first                                    // 410\n    // time.                                                                                                      // 411\n    self._dataVisible = false;                                                                                    // 412\n    self.sentMessage = true;                                                                                      // 413\n                                                                                                                  // 414\n    // If this is a wait method, make all data messages be buffered until it is                                   // 415\n    // done.                                                                                                      // 416\n    if (self._wait)                                                                                               // 417\n      self._connection._methodsBlockingQuiescence[self.methodId] = true;                                          // 418\n                                                                                                                  // 419\n    // Actually send the message.                                                                                 // 420\n    self._connection._send(self._message);                                                                        // 421\n  },                                                                                                              // 422\n  // Invoke the callback, if we have both a result and know that all data has                                     // 423\n  // been written to the local cache.                                                                             // 424\n  _maybeInvokeCallback: function () {                                                                             // 425\n    var self = this;                                                                                              // 426\n    if (self._methodResult && self._dataVisible) {                                                                // 427\n      // Call the callback. (This won't throw: the callback was wrapped with                                      // 428\n      // bindEnvironment.)                                                                                        // 429\n      self._callback(self._methodResult[0], self._methodResult[1]);                                               // 430\n                                                                                                                  // 431\n      // Forget about this method.                                                                                // 432\n      delete self._connection._methodInvokers[self.methodId];                                                     // 433\n                                                                                                                  // 434\n      // Let the connection know that this method is finished, so it can try to                                   // 435\n      // move on to the next block of methods.                                                                    // 436\n      self._connection._outstandingMethodFinished();                                                              // 437\n    }                                                                                                             // 438\n  },                                                                                                              // 439\n  // Call with the result of the method from the server. Only may be called                                       // 440\n  // once; once it is called, you should not call sendMessage again.                                              // 441\n  // If the user provided an onResultReceived callback, call it immediately.                                      // 442\n  // Then invoke the main callback if data is also visible.                                                       // 443\n  receiveResult: function (err, result) {                                                                         // 444\n    var self = this;                                                                                              // 445\n    if (self.gotResult())                                                                                         // 446\n      throw new Error(\"Methods should only receive results once\");                                                // 447\n    self._methodResult = [err, result];                                                                           // 448\n    self._onResultReceived(err, result);                                                                          // 449\n    self._maybeInvokeCallback();                                                                                  // 450\n  },                                                                                                              // 451\n  // Call this when all data written by the method is visible. This means that                                    // 452\n  // the method has returns its \"data is done\" message *AND* all server                                           // 453\n  // documents that are buffered at that time have been written to the local                                      // 454\n  // cache. Invokes the main callback if the result has been received.                                            // 455\n  dataVisible: function () {                                                                                      // 456\n    var self = this;                                                                                              // 457\n    self._dataVisible = true;                                                                                     // 458\n    self._maybeInvokeCallback();                                                                                  // 459\n  },                                                                                                              // 460\n  // True if receiveResult has been called.                                                                       // 461\n  gotResult: function () {                                                                                        // 462\n    var self = this;                                                                                              // 463\n    return !!self._methodResult;                                                                                  // 464\n  }                                                                                                               // 465\n});                                                                                                               // 466\n                                                                                                                  // 467\n_.extend(Connection.prototype, {                                                                                  // 468\n  // 'name' is the name of the data on the wire that should go in the                                             // 469\n  // store. 'wrappedStore' should be an object with methods beginUpdate, update,                                  // 470\n  // endUpdate, saveOriginals, retrieveOriginals. see Collection for an example.                                  // 471\n  registerStore: function (name, wrappedStore) {                                                                  // 472\n    var self = this;                                                                                              // 473\n                                                                                                                  // 474\n    if (name in self._stores)                                                                                     // 475\n      return false;                                                                                               // 476\n                                                                                                                  // 477\n    // Wrap the input object in an object which makes any store method not                                        // 478\n    // implemented by 'store' into a no-op.                                                                       // 479\n    var store = {};                                                                                               // 480\n    _.each(['update', 'beginUpdate', 'endUpdate', 'saveOriginals',                                                // 481\n            'retrieveOriginals', 'getDoc',                                                                        // 482\n\t\t\t'_getCollection'], function (method) {                                                                         // 483\n              store[method] = function () {                                                                       // 484\n                return (wrappedStore[method]                                                                      // 485\n                        ? wrappedStore[method].apply(wrappedStore, arguments)                                     // 486\n                        : undefined);                                                                             // 487\n              };                                                                                                  // 488\n            });                                                                                                   // 489\n                                                                                                                  // 490\n    self._stores[name] = store;                                                                                   // 491\n                                                                                                                  // 492\n    var queued = self._updatesForUnknownStores[name];                                                             // 493\n    if (queued) {                                                                                                 // 494\n      store.beginUpdate(queued.length, false);                                                                    // 495\n      _.each(queued, function (msg) {                                                                             // 496\n        store.update(msg);                                                                                        // 497\n      });                                                                                                         // 498\n      store.endUpdate();                                                                                          // 499\n      delete self._updatesForUnknownStores[name];                                                                 // 500\n    }                                                                                                             // 501\n                                                                                                                  // 502\n    return true;                                                                                                  // 503\n  },                                                                                                              // 504\n                                                                                                                  // 505\n  /**                                                                                                             // 506\n   * @memberOf Meteor                                                                                             // 507\n   * @importFromPackage meteor                                                                                    // 508\n   * @summary Subscribe to a record set.  Returns a handle that provides                                          // 509\n   * `stop()` and `ready()` methods.                                                                              // 510\n   * @locus Client                                                                                                // 511\n   * @param {String} name Name of the subscription.  Matches the name of the                                      // 512\n   * server's `publish()` call.                                                                                   // 513\n   * @param {EJSONable} [arg1,arg2...] Optional arguments passed to publisher                                     // 514\n   * function on server.                                                                                          // 515\n   * @param {Function|Object} [callbacks] Optional. May include `onStop`                                          // 516\n   * and `onReady` callbacks. If there is an error, it is passed as an                                            // 517\n   * argument to `onStop`. If a function is passed instead of an object, it                                       // 518\n   * is interpreted as an `onReady` callback.                                                                     // 519\n   */                                                                                                             // 520\n  subscribe: function (name /* .. [arguments] .. (callback|callbacks) */) {                                       // 521\n    var self = this;                                                                                              // 522\n                                                                                                                  // 523\n    var params = Array.prototype.slice.call(arguments, 1);                                                        // 524\n    var callbacks = {};                                                                                           // 525\n    if (params.length) {                                                                                          // 526\n      var lastParam = params[params.length - 1];                                                                  // 527\n      if (_.isFunction(lastParam)) {                                                                              // 528\n        callbacks.onReady = params.pop();                                                                         // 529\n      } else if (lastParam &&                                                                                     // 530\n        // XXX COMPAT WITH 1.0.3.1 onError used to exist, but now we use                                          // 531\n        // onStop with an error callback instead.                                                                 // 532\n        _.any([lastParam.onReady, lastParam.onError, lastParam.onStop],                                           // 533\n          _.isFunction)) {                                                                                        // 534\n        callbacks = params.pop();                                                                                 // 535\n      }                                                                                                           // 536\n    }                                                                                                             // 537\n                                                                                                                  // 538\n    // Is there an existing sub with the same name and param, run in an                                           // 539\n    // invalidated Computation? This will happen if we are rerunning an                                           // 540\n    // existing computation.                                                                                      // 541\n    //                                                                                                            // 542\n    // For example, consider a rerun of:                                                                          // 543\n    //                                                                                                            // 544\n    //     Tracker.autorun(function () {                                                                          // 545\n    //       Meteor.subscribe(\"foo\", Session.get(\"foo\"));                                                         // 546\n    //       Meteor.subscribe(\"bar\", Session.get(\"bar\"));                                                         // 547\n    //     });                                                                                                    // 548\n    //                                                                                                            // 549\n    // If \"foo\" has changed but \"bar\" has not, we will match the \"bar\"                                            // 550\n    // subcribe to an existing inactive subscription in order to not                                              // 551\n    // unsub and resub the subscription unnecessarily.                                                            // 552\n    //                                                                                                            // 553\n    // We only look for one such sub; if there are N apparently-identical subs                                    // 554\n    // being invalidated, we will require N matching subscribe calls to keep                                      // 555\n    // them all active.                                                                                           // 556\n    var existing = _.find(self._subscriptions, function (sub) {                                                   // 557\n      return sub.inactive && sub.name === name &&                                                                 // 558\n        EJSON.equals(sub.params, params);                                                                         // 559\n    });                                                                                                           // 560\n                                                                                                                  // 561\n    var id;                                                                                                       // 562\n    if (existing) {                                                                                               // 563\n      id = existing.id;                                                                                           // 564\n      existing.inactive = false; // reactivate                                                                    // 565\n                                                                                                                  // 566\n      if (callbacks.onReady) {                                                                                    // 567\n        // If the sub is not already ready, replace any ready callback with the                                   // 568\n        // one provided now. (It's not really clear what users would expect for                                   // 569\n        // an onReady callback inside an autorun; the semantics we provide is                                     // 570\n        // that at the time the sub first becomes ready, we call the last                                         // 571\n        // onReady callback provided, if any.)                                                                    // 572\n        if (!existing.ready)                                                                                      // 573\n          existing.readyCallback = callbacks.onReady;                                                             // 574\n      }                                                                                                           // 575\n                                                                                                                  // 576\n      // XXX COMPAT WITH 1.0.3.1 we used to have onError but now we call                                          // 577\n      // onStop with an optional error argument                                                                   // 578\n      if (callbacks.onError) {                                                                                    // 579\n        // Replace existing callback if any, so that errors aren't                                                // 580\n        // double-reported.                                                                                       // 581\n        existing.errorCallback = callbacks.onError;                                                               // 582\n      }                                                                                                           // 583\n                                                                                                                  // 584\n      if (callbacks.onStop) {                                                                                     // 585\n        existing.stopCallback = callbacks.onStop;                                                                 // 586\n      }                                                                                                           // 587\n    } else {                                                                                                      // 588\n      // New sub! Generate an id, save it locally, and send message.                                              // 589\n      id = Random.id();                                                                                           // 590\n      self._subscriptions[id] = {                                                                                 // 591\n        id: id,                                                                                                   // 592\n        name: name,                                                                                               // 593\n        params: EJSON.clone(params),                                                                              // 594\n        inactive: false,                                                                                          // 595\n        ready: false,                                                                                             // 596\n        readyDeps: new Tracker.Dependency,                                                                        // 597\n        readyCallback: callbacks.onReady,                                                                         // 598\n        // XXX COMPAT WITH 1.0.3.1 #errorCallback                                                                 // 599\n        errorCallback: callbacks.onError,                                                                         // 600\n        stopCallback: callbacks.onStop,                                                                           // 601\n        connection: self,                                                                                         // 602\n        remove: function() {                                                                                      // 603\n          delete this.connection._subscriptions[this.id];                                                         // 604\n          this.ready && this.readyDeps.changed();                                                                 // 605\n        },                                                                                                        // 606\n        stop: function() {                                                                                        // 607\n          this.connection._send({msg: 'unsub', id: id});                                                          // 608\n          this.remove();                                                                                          // 609\n                                                                                                                  // 610\n          if (callbacks.onStop) {                                                                                 // 611\n            callbacks.onStop();                                                                                   // 612\n          }                                                                                                       // 613\n        }                                                                                                         // 614\n      };                                                                                                          // 615\n      self._send({msg: 'sub', id: id, name: name, params: params});                                               // 616\n    }                                                                                                             // 617\n                                                                                                                  // 618\n    // return a handle to the application.                                                                        // 619\n    var handle = {                                                                                                // 620\n      stop: function () {                                                                                         // 621\n        if (!_.has(self._subscriptions, id))                                                                      // 622\n          return;                                                                                                 // 623\n                                                                                                                  // 624\n        self._subscriptions[id].stop();                                                                           // 625\n      },                                                                                                          // 626\n      ready: function () {                                                                                        // 627\n        // return false if we've unsubscribed.                                                                    // 628\n        if (!_.has(self._subscriptions, id))                                                                      // 629\n          return false;                                                                                           // 630\n        var record = self._subscriptions[id];                                                                     // 631\n        record.readyDeps.depend();                                                                                // 632\n        return record.ready;                                                                                      // 633\n      },                                                                                                          // 634\n      subscriptionId: id                                                                                          // 635\n    };                                                                                                            // 636\n                                                                                                                  // 637\n    if (Tracker.active) {                                                                                         // 638\n      // We're in a reactive computation, so we'd like to unsubscribe when the                                    // 639\n      // computation is invalidated... but not if the rerun just re-subscribes                                    // 640\n      // to the same subscription!  When a rerun happens, we use onInvalidate                                     // 641\n      // as a change to mark the subscription \"inactive\" so that it can                                           // 642\n      // be reused from the rerun.  If it isn't reused, it's killed from                                          // 643\n      // an afterFlush.                                                                                           // 644\n      Tracker.onInvalidate(function (c) {                                                                         // 645\n        if (_.has(self._subscriptions, id))                                                                       // 646\n          self._subscriptions[id].inactive = true;                                                                // 647\n                                                                                                                  // 648\n        Tracker.afterFlush(function () {                                                                          // 649\n          if (_.has(self._subscriptions, id) &&                                                                   // 650\n              self._subscriptions[id].inactive)                                                                   // 651\n            handle.stop();                                                                                        // 652\n        });                                                                                                       // 653\n      });                                                                                                         // 654\n    }                                                                                                             // 655\n                                                                                                                  // 656\n    return handle;                                                                                                // 657\n  },                                                                                                              // 658\n                                                                                                                  // 659\n  // options:                                                                                                     // 660\n  // - onLateError {Function(error)} called if an error was received after the ready event.                       // 661\n  //     (errors received before ready cause an error to be thrown)                                               // 662\n  _subscribeAndWait: function (name, args, options) {                                                             // 663\n    var self = this;                                                                                              // 664\n    var f = new Future();                                                                                         // 665\n    var ready = false;                                                                                            // 666\n    var handle;                                                                                                   // 667\n    args = args || [];                                                                                            // 668\n    args.push({                                                                                                   // 669\n      onReady: function () {                                                                                      // 670\n        ready = true;                                                                                             // 671\n        f['return']();                                                                                            // 672\n      },                                                                                                          // 673\n      onError: function (e) {                                                                                     // 674\n        if (!ready)                                                                                               // 675\n          f['throw'](e);                                                                                          // 676\n        else                                                                                                      // 677\n          options && options.onLateError && options.onLateError(e);                                               // 678\n      }                                                                                                           // 679\n    });                                                                                                           // 680\n                                                                                                                  // 681\n    handle = self.subscribe.apply(self, [name].concat(args));                                                     // 682\n    f.wait();                                                                                                     // 683\n    return handle;                                                                                                // 684\n  },                                                                                                              // 685\n                                                                                                                  // 686\n  methods: function (methods) {                                                                                   // 687\n    var self = this;                                                                                              // 688\n    _.each(methods, function (func, name) {                                                                       // 689\n      if (typeof func !== 'function')                                                                             // 690\n        throw new Error(\"Method '\" + name + \"' must be a function\");                                              // 691\n      if (self._methodHandlers[name])                                                                             // 692\n        throw new Error(\"A method named '\" + name + \"' is already defined\");                                      // 693\n      self._methodHandlers[name] = func;                                                                          // 694\n    });                                                                                                           // 695\n  },                                                                                                              // 696\n                                                                                                                  // 697\n  /**                                                                                                             // 698\n   * @memberOf Meteor                                                                                             // 699\n   * @importFromPackage meteor                                                                                    // 700\n   * @summary Invokes a method passing any number of arguments.                                                   // 701\n   * @locus Anywhere                                                                                              // 702\n   * @param {String} name Name of method to invoke                                                                // 703\n   * @param {EJSONable} [arg1,arg2...] Optional method arguments                                                  // 704\n   * @param {Function} [asyncCallback] Optional callback, which is called asynchronously with the error or result after the method is complete. If not provided, the method runs synchronously if possible (see below).\n   */                                                                                                             // 706\n  call: function (name /* .. [arguments] .. callback */) {                                                        // 707\n    // if it's a function, the last argument is the result callback,                                              // 708\n    // not a parameter to the remote method.                                                                      // 709\n    var args = Array.prototype.slice.call(arguments, 1);                                                          // 710\n    if (args.length && typeof args[args.length - 1] === \"function\")                                               // 711\n      var callback = args.pop();                                                                                  // 712\n    return this.apply(name, args, callback);                                                                      // 713\n  },                                                                                                              // 714\n                                                                                                                  // 715\n  // @param options {Optional Object}                                                                             // 716\n  //   wait: Boolean - Should we wait to call this until all current methods                                      // 717\n  //                   are fully finished, and block subsequent method calls                                      // 718\n  //                   until this method is fully finished?                                                       // 719\n  //                   (does not affect methods called from within this method)                                   // 720\n  //   onResultReceived: Function - a callback to call as soon as the method                                      // 721\n  //                                result is received. the data written by                                       // 722\n  //                                the method may not yet be in the cache!                                       // 723\n  //   returnStubValue: Boolean - If true then in cases where we would have                                       // 724\n  //                              otherwise discarded the stub's return value                                     // 725\n  //                              and returned undefined, instead we go ahead                                     // 726\n  //                              and return it.  Specifically, this is any                                       // 727\n  //                              time other than when (a) we are already                                         // 728\n  //                              inside a stub or (b) we are in Node and no                                      // 729\n  //                              callback was provided.  Currently we require                                    // 730\n  //                              this flag to be explicitly passed to reduce                                     // 731\n  //                              the likelihood that stub return values will                                     // 732\n  //                              be confused with server return values; we                                       // 733\n  //                              may improve this in future.                                                     // 734\n  // @param callback {Optional Function}                                                                          // 735\n                                                                                                                  // 736\n  /**                                                                                                             // 737\n   * @memberOf Meteor                                                                                             // 738\n   * @importFromPackage meteor                                                                                    // 739\n   * @summary Invoke a method passing an array of arguments.                                                      // 740\n   * @locus Anywhere                                                                                              // 741\n   * @param {String} name Name of method to invoke                                                                // 742\n   * @param {EJSONable[]} args Method arguments                                                                   // 743\n   * @param {Object} [options]                                                                                    // 744\n   * @param {Boolean} options.wait (Client only) If true, don't send this method until all previous method calls have completed, and don't send any subsequent method calls until this one is completed.\n   * @param {Function} options.onResultReceived (Client only) This callback is invoked with the error or result of the method (just like `asyncCallback`) as soon as the error or result is available. The local cache may not yet reflect the writes performed by the method.\n   * @param (Boolean) options.noRetry (Client only) if true, don't send this method again on reload, simply call the callback an error with the error code 'invocation-failed'.\n   * @param {Function} [asyncCallback] Optional callback; same semantics as in [`Meteor.call`](#meteor_call).     // 748\n   */                                                                                                             // 749\n  apply: function (name, args, options, callback) {                                                               // 750\n    var self = this;                                                                                              // 751\n                                                                                                                  // 752\n    // We were passed 3 arguments. They may be either (name, args, options)                                       // 753\n    // or (name, args, callback)                                                                                  // 754\n    if (!callback && typeof options === 'function') {                                                             // 755\n      callback = options;                                                                                         // 756\n      options = {};                                                                                               // 757\n    }                                                                                                             // 758\n    options = options || {};                                                                                      // 759\n                                                                                                                  // 760\n    if (callback) {                                                                                               // 761\n      // XXX would it be better form to do the binding in stream.on,                                              // 762\n      // or caller, instead of here?                                                                              // 763\n      // XXX improve error message (and how we report it)                                                         // 764\n      callback = Meteor.bindEnvironment(                                                                          // 765\n        callback,                                                                                                 // 766\n        \"delivering result of invoking '\" + name + \"'\"                                                            // 767\n      );                                                                                                          // 768\n    }                                                                                                             // 769\n                                                                                                                  // 770\n    // Keep our args safe from mutation (eg if we don't send the message for a                                    // 771\n    // while because of a wait method).                                                                           // 772\n    args = EJSON.clone(args);                                                                                     // 773\n                                                                                                                  // 774\n    // Lazily allocate method ID once we know that it'll be needed.                                               // 775\n    var methodId = (function () {                                                                                 // 776\n      var id;                                                                                                     // 777\n      return function () {                                                                                        // 778\n        if (id === undefined)                                                                                     // 779\n          id = '' + (self._nextMethodId++);                                                                       // 780\n        return id;                                                                                                // 781\n      };                                                                                                          // 782\n    })();                                                                                                         // 783\n                                                                                                                  // 784\n    var enclosing = DDP._CurrentInvocation.get();                                                                 // 785\n    var alreadyInSimulation = enclosing && enclosing.isSimulation;                                                // 786\n                                                                                                                  // 787\n    // Lazily generate a randomSeed, only if it is requested by the stub.                                         // 788\n    // The random streams only have utility if they're used on both the client                                    // 789\n    // and the server; if the client doesn't generate any 'random' values                                         // 790\n    // then we don't expect the server to generate any either.                                                    // 791\n    // Less commonly, the server may perform different actions from the client,                                   // 792\n    // and may in fact generate values where the client did not, but we don't                                     // 793\n    // have any client-side values to match, so even here we may as well just                                     // 794\n    // use a random seed on the server.  In that case, we don't pass the                                          // 795\n    // randomSeed to save bandwidth, and we don't even generate it to save a                                      // 796\n    // bit of CPU and to avoid consuming entropy.                                                                 // 797\n    var randomSeed = null;                                                                                        // 798\n    var randomSeedGenerator = function () {                                                                       // 799\n      if (randomSeed === null) {                                                                                  // 800\n        randomSeed = DDPCommon.makeRpcSeed(enclosing, name);                                                      // 801\n      }                                                                                                           // 802\n      return randomSeed;                                                                                          // 803\n    };                                                                                                            // 804\n                                                                                                                  // 805\n    // Run the stub, if we have one. The stub is supposed to make some                                            // 806\n    // temporary writes to the database to give the user a smooth experience                                      // 807\n    // until the actual result of executing the method comes back from the                                        // 808\n    // server (whereupon the temporary writes to the database will be reversed                                    // 809\n    // during the beginUpdate/endUpdate process.)                                                                 // 810\n    //                                                                                                            // 811\n    // Normally, we ignore the return value of the stub (even if it is an                                         // 812\n    // exception), in favor of the real return value from the server. The                                         // 813\n    // exception is if the *caller* is a stub. In that case, we're not going                                      // 814\n    // to do a RPC, so we use the return value of the stub as our return                                          // 815\n    // value.                                                                                                     // 816\n                                                                                                                  // 817\n    var stub = self._methodHandlers[name];                                                                        // 818\n    if (stub) {                                                                                                   // 819\n      var setUserId = function(userId) {                                                                          // 820\n        self.setUserId(userId);                                                                                   // 821\n      };                                                                                                          // 822\n                                                                                                                  // 823\n      var invocation = new DDPCommon.MethodInvocation({                                                           // 824\n        isSimulation: true,                                                                                       // 825\n        userId: self.userId(),                                                                                    // 826\n        setUserId: setUserId,                                                                                     // 827\n        randomSeed: function () { return randomSeedGenerator(); }                                                 // 828\n      });                                                                                                         // 829\n                                                                                                                  // 830\n      if (!alreadyInSimulation)                                                                                   // 831\n        self._saveOriginals();                                                                                    // 832\n                                                                                                                  // 833\n      try {                                                                                                       // 834\n        // Note that unlike in the corresponding server code, we never audit                                      // 835\n        // that stubs check() their arguments.                                                                    // 836\n        var stubReturnValue = DDP._CurrentInvocation.withValue(invocation, function () {                          // 837\n          if (Meteor.isServer) {                                                                                  // 838\n            // Because saveOriginals and retrieveOriginals aren't reentrant,                                      // 839\n            // don't allow stubs to yield.                                                                        // 840\n            return Meteor._noYieldsAllowed(function () {                                                          // 841\n              // re-clone, so that the stub can't affect our caller's values                                      // 842\n              return stub.apply(invocation, EJSON.clone(args));                                                   // 843\n            });                                                                                                   // 844\n          } else {                                                                                                // 845\n            return stub.apply(invocation, EJSON.clone(args));                                                     // 846\n          }                                                                                                       // 847\n        });                                                                                                       // 848\n      }                                                                                                           // 849\n      catch (e) {                                                                                                 // 850\n        var exception = e;                                                                                        // 851\n      }                                                                                                           // 852\n                                                                                                                  // 853\n      if (!alreadyInSimulation)                                                                                   // 854\n        self._retrieveAndStoreOriginals(methodId());                                                              // 855\n    }                                                                                                             // 856\n                                                                                                                  // 857\n    // If we're in a simulation, stop and return the result we have,                                              // 858\n    // rather than going on to do an RPC. If there was no stub,                                                   // 859\n    // we'll end up returning undefined.                                                                          // 860\n    if (alreadyInSimulation) {                                                                                    // 861\n      if (callback) {                                                                                             // 862\n        callback(exception, stubReturnValue);                                                                     // 863\n        return undefined;                                                                                         // 864\n      }                                                                                                           // 865\n      if (exception)                                                                                              // 866\n        throw exception;                                                                                          // 867\n      return stubReturnValue;                                                                                     // 868\n    }                                                                                                             // 869\n                                                                                                                  // 870\n    // If an exception occurred in a stub, and we're ignoring it                                                  // 871\n    // because we're doing an RPC and want to use what the server                                                 // 872\n    // returns instead, log it so the developer knows                                                             // 873\n    // (unless they explicitly ask to see the error).                                                             // 874\n    //                                                                                                            // 875\n    // Tests can set the 'expected' flag on an exception so it won't                                              // 876\n    // go to log.                                                                                                 // 877\n    if (exception) {                                                                                              // 878\n      if (options.throwStubExceptions) {                                                                          // 879\n        throw exception;                                                                                          // 880\n      } else if (!exception.expected) {                                                                           // 881\n        Meteor._debug(\"Exception while simulating the effect of invoking '\" +                                     // 882\n          name + \"'\", exception, exception.stack);                                                                // 883\n      }                                                                                                           // 884\n    }                                                                                                             // 885\n                                                                                                                  // 886\n                                                                                                                  // 887\n    // At this point we're definitely doing an RPC, and we're going to                                            // 888\n    // return the value of the RPC to the caller.                                                                 // 889\n                                                                                                                  // 890\n    // If the caller didn't give a callback, decide what to do.                                                   // 891\n    if (!callback) {                                                                                              // 892\n      if (Meteor.isClient) {                                                                                      // 893\n        // On the client, we don't have fibers, so we can't block. The                                            // 894\n        // only thing we can do is to return undefined and discard the                                            // 895\n        // result of the RPC. If an error occurred then print the error                                           // 896\n        // to the console.                                                                                        // 897\n        callback = function (err) {                                                                               // 898\n          err && Meteor._debug(\"Error invoking Method '\" + name + \"':\",                                           // 899\n                               err.message);                                                                      // 900\n        };                                                                                                        // 901\n      } else {                                                                                                    // 902\n        // On the server, make the function synchronous. Throw on                                                 // 903\n        // errors, return on success.                                                                             // 904\n        var future = new Future;                                                                                  // 905\n        callback = future.resolver();                                                                             // 906\n      }                                                                                                           // 907\n    }                                                                                                             // 908\n    // Send the RPC. Note that on the client, it is important that the                                            // 909\n    // stub have finished before we send the RPC, so that we know we have                                         // 910\n    // a complete list of which local documents the stub wrote.                                                   // 911\n    var message = {                                                                                               // 912\n      msg: 'method',                                                                                              // 913\n      method: name,                                                                                               // 914\n      params: args,                                                                                               // 915\n      id: methodId()                                                                                              // 916\n    };                                                                                                            // 917\n                                                                                                                  // 918\n    // Send the randomSeed only if we used it                                                                     // 919\n    if (randomSeed !== null) {                                                                                    // 920\n      message.randomSeed = randomSeed;                                                                            // 921\n    }                                                                                                             // 922\n                                                                                                                  // 923\n    var methodInvoker = new MethodInvoker({                                                                       // 924\n      methodId: methodId(),                                                                                       // 925\n      callback: callback,                                                                                         // 926\n      connection: self,                                                                                           // 927\n      onResultReceived: options.onResultReceived,                                                                 // 928\n      wait: !!options.wait,                                                                                       // 929\n      message: message,                                                                                           // 930\n      noRetry: !!options.noRetry                                                                                  // 931\n    });                                                                                                           // 932\n                                                                                                                  // 933\n    if (options.wait) {                                                                                           // 934\n      // It's a wait method! Wait methods go in their own block.                                                  // 935\n      self._outstandingMethodBlocks.push(                                                                         // 936\n        {wait: true, methods: [methodInvoker]});                                                                  // 937\n    } else {                                                                                                      // 938\n      // Not a wait method. Start a new block if the previous block was a wait                                    // 939\n      // block, and add it to the last block of methods.                                                          // 940\n      if (_.isEmpty(self._outstandingMethodBlocks) ||                                                             // 941\n          _.last(self._outstandingMethodBlocks).wait)                                                             // 942\n        self._outstandingMethodBlocks.push({wait: false, methods: []});                                           // 943\n      _.last(self._outstandingMethodBlocks).methods.push(methodInvoker);                                          // 944\n    }                                                                                                             // 945\n                                                                                                                  // 946\n    // If we added it to the first block, send it out now.                                                        // 947\n    if (self._outstandingMethodBlocks.length === 1)                                                               // 948\n      methodInvoker.sendMessage();                                                                                // 949\n                                                                                                                  // 950\n    // If we're using the default callback on the server,                                                         // 951\n    // block waiting for the result.                                                                              // 952\n    if (future) {                                                                                                 // 953\n      return future.wait();                                                                                       // 954\n    }                                                                                                             // 955\n    return options.returnStubValue ? stubReturnValue : undefined;                                                 // 956\n  },                                                                                                              // 957\n                                                                                                                  // 958\n  // Before calling a method stub, prepare all stores to track changes and allow                                  // 959\n  // _retrieveAndStoreOriginals to get the original versions of changed                                           // 960\n  // documents.                                                                                                   // 961\n  _saveOriginals: function () {                                                                                   // 962\n    var self = this;                                                                                              // 963\n    _.each(self._stores, function (s) {                                                                           // 964\n      s.saveOriginals();                                                                                          // 965\n    });                                                                                                           // 966\n  },                                                                                                              // 967\n  // Retrieves the original versions of all documents modified by the stub for                                    // 968\n  // method 'methodId' from all stores and saves them to _serverDocuments (keyed                                  // 969\n  // by document) and _documentsWrittenByStub (keyed by method ID).                                               // 970\n  _retrieveAndStoreOriginals: function (methodId) {                                                               // 971\n    var self = this;                                                                                              // 972\n    if (self._documentsWrittenByStub[methodId])                                                                   // 973\n      throw new Error(\"Duplicate methodId in _retrieveAndStoreOriginals\");                                        // 974\n                                                                                                                  // 975\n    var docsWritten = [];                                                                                         // 976\n    _.each(self._stores, function (s, collection) {                                                               // 977\n      var originals = s.retrieveOriginals();                                                                      // 978\n      // not all stores define retrieveOriginals                                                                  // 979\n      if (!originals)                                                                                             // 980\n        return;                                                                                                   // 981\n      originals.forEach(function (doc, id) {                                                                      // 982\n        docsWritten.push({collection: collection, id: id});                                                       // 983\n        if (!_.has(self._serverDocuments, collection))                                                            // 984\n          self._serverDocuments[collection] = new MongoIDMap;                                                     // 985\n        var serverDoc = self._serverDocuments[collection].setDefault(id, {});                                     // 986\n        if (serverDoc.writtenByStubs) {                                                                           // 987\n          // We're not the first stub to write this doc. Just add our method ID                                   // 988\n          // to the record.                                                                                       // 989\n          serverDoc.writtenByStubs[methodId] = true;                                                              // 990\n        } else {                                                                                                  // 991\n          // First stub! Save the original value and our method ID.                                               // 992\n          serverDoc.document = doc;                                                                               // 993\n          serverDoc.flushCallbacks = [];                                                                          // 994\n          serverDoc.writtenByStubs = {};                                                                          // 995\n          serverDoc.writtenByStubs[methodId] = true;                                                              // 996\n        }                                                                                                         // 997\n      });                                                                                                         // 998\n    });                                                                                                           // 999\n    if (!_.isEmpty(docsWritten)) {                                                                                // 1000\n      self._documentsWrittenByStub[methodId] = docsWritten;                                                       // 1001\n    }                                                                                                             // 1002\n  },                                                                                                              // 1003\n                                                                                                                  // 1004\n  // This is very much a private function we use to make the tests                                                // 1005\n  // take up fewer server resources after they complete.                                                          // 1006\n  _unsubscribeAll: function () {                                                                                  // 1007\n    var self = this;                                                                                              // 1008\n    _.each(_.clone(self._subscriptions), function (sub, id) {                                                     // 1009\n      // Avoid killing the autoupdate subscription so that developers                                             // 1010\n      // still get hot code pushes when writing tests.                                                            // 1011\n      //                                                                                                          // 1012\n      // XXX it's a hack to encode knowledge about autoupdate here,                                               // 1013\n      // but it doesn't seem worth it yet to have a special API for                                               // 1014\n      // subscriptions to preserve after unit tests.                                                              // 1015\n      if (sub.name !== 'meteor_autoupdate_clientVersions') {                                                      // 1016\n        self._subscriptions[id].stop();                                                                           // 1017\n      }                                                                                                           // 1018\n    });                                                                                                           // 1019\n  },                                                                                                              // 1020\n                                                                                                                  // 1021\n  // Sends the DDP stringification of the given message object                                                    // 1022\n  _send: function (obj) {                                                                                         // 1023\n    var self = this;                                                                                              // 1024\n    self._stream.send(DDPCommon.stringifyDDP(obj));                                                               // 1025\n  },                                                                                                              // 1026\n                                                                                                                  // 1027\n  // We detected via DDP-level heartbeats that we've lost the                                                     // 1028\n  // connection.  Unlike `disconnect` or `close`, a lost connection                                               // 1029\n  // will be automatically retried.                                                                               // 1030\n  _lostConnection: function (error) {                                                                             // 1031\n    var self = this;                                                                                              // 1032\n    self._stream._lostConnection(error);                                                                          // 1033\n  },                                                                                                              // 1034\n                                                                                                                  // 1035\n  /**                                                                                                             // 1036\n   * @summary Get the current connection status. A reactive data source.                                          // 1037\n   * @locus Client                                                                                                // 1038\n   * @memberOf Meteor                                                                                             // 1039\n   * @importFromPackage meteor                                                                                    // 1040\n   */                                                                                                             // 1041\n  status: function (/*passthrough args*/) {                                                                       // 1042\n    var self = this;                                                                                              // 1043\n    return self._stream.status.apply(self._stream, arguments);                                                    // 1044\n  },                                                                                                              // 1045\n                                                                                                                  // 1046\n  /**                                                                                                             // 1047\n   * @summary Force an immediate reconnection attempt if the client is not connected to the server.               // 1048\n                                                                                                                  // 1049\n  This method does nothing if the client is already connected.                                                    // 1050\n   * @locus Client                                                                                                // 1051\n   * @memberOf Meteor                                                                                             // 1052\n   * @importFromPackage meteor                                                                                    // 1053\n   */                                                                                                             // 1054\n  reconnect: function (/*passthrough args*/) {                                                                    // 1055\n    var self = this;                                                                                              // 1056\n    return self._stream.reconnect.apply(self._stream, arguments);                                                 // 1057\n  },                                                                                                              // 1058\n                                                                                                                  // 1059\n  /**                                                                                                             // 1060\n   * @summary Disconnect the client from the server.                                                              // 1061\n   * @locus Client                                                                                                // 1062\n   * @memberOf Meteor                                                                                             // 1063\n   * @importFromPackage meteor                                                                                    // 1064\n   */                                                                                                             // 1065\n  disconnect: function (/*passthrough args*/) {                                                                   // 1066\n    var self = this;                                                                                              // 1067\n    return self._stream.disconnect.apply(self._stream, arguments);                                                // 1068\n  },                                                                                                              // 1069\n                                                                                                                  // 1070\n  close: function () {                                                                                            // 1071\n    var self = this;                                                                                              // 1072\n    return self._stream.disconnect({_permanent: true});                                                           // 1073\n  },                                                                                                              // 1074\n                                                                                                                  // 1075\n  ///                                                                                                             // 1076\n  /// Reactive user system                                                                                        // 1077\n  ///                                                                                                             // 1078\n  userId: function () {                                                                                           // 1079\n    var self = this;                                                                                              // 1080\n    if (self._userIdDeps)                                                                                         // 1081\n      self._userIdDeps.depend();                                                                                  // 1082\n    return self._userId;                                                                                          // 1083\n  },                                                                                                              // 1084\n                                                                                                                  // 1085\n  setUserId: function (userId) {                                                                                  // 1086\n    var self = this;                                                                                              // 1087\n    // Avoid invalidating dependents if setUserId is called with current value.                                   // 1088\n    if (self._userId === userId)                                                                                  // 1089\n      return;                                                                                                     // 1090\n    self._userId = userId;                                                                                        // 1091\n    if (self._userIdDeps)                                                                                         // 1092\n      self._userIdDeps.changed();                                                                                 // 1093\n  },                                                                                                              // 1094\n                                                                                                                  // 1095\n  // Returns true if we are in a state after reconnect of waiting for subs to be                                  // 1096\n  // revived or early methods to finish their data, or we are waiting for a                                       // 1097\n  // \"wait\" method to finish.                                                                                     // 1098\n  _waitingForQuiescence: function () {                                                                            // 1099\n    var self = this;                                                                                              // 1100\n    return (! _.isEmpty(self._subsBeingRevived) ||                                                                // 1101\n            ! _.isEmpty(self._methodsBlockingQuiescence));                                                        // 1102\n  },                                                                                                              // 1103\n                                                                                                                  // 1104\n  // Returns true if any method whose message has been sent to the server has                                     // 1105\n  // not yet invoked its user callback.                                                                           // 1106\n  _anyMethodsAreOutstanding: function () {                                                                        // 1107\n    var self = this;                                                                                              // 1108\n    return _.any(_.pluck(self._methodInvokers, 'sentMessage'));                                                   // 1109\n  },                                                                                                              // 1110\n                                                                                                                  // 1111\n  _livedata_connected: function (msg) {                                                                           // 1112\n    var self = this;                                                                                              // 1113\n                                                                                                                  // 1114\n    if (self._version !== 'pre1' && self._heartbeatInterval !== 0) {                                              // 1115\n      self._heartbeat = new DDPCommon.Heartbeat({                                                                 // 1116\n        heartbeatInterval: self._heartbeatInterval,                                                               // 1117\n        heartbeatTimeout: self._heartbeatTimeout,                                                                 // 1118\n        onTimeout: function () {                                                                                  // 1119\n          self._lostConnection(                                                                                   // 1120\n            new DDP.ConnectionError(\"DDP heartbeat timed out\"));                                                  // 1121\n        },                                                                                                        // 1122\n        sendPing: function () {                                                                                   // 1123\n          self._send({msg: 'ping'});                                                                              // 1124\n        }                                                                                                         // 1125\n      });                                                                                                         // 1126\n      self._heartbeat.start();                                                                                    // 1127\n    }                                                                                                             // 1128\n                                                                                                                  // 1129\n    // If this is a reconnect, we'll have to reset all stores.                                                    // 1130\n    if (self._lastSessionId)                                                                                      // 1131\n      self._resetStores = true;                                                                                   // 1132\n                                                                                                                  // 1133\n    if (typeof (msg.session) === \"string\") {                                                                      // 1134\n      var reconnectedToPreviousSession = (self._lastSessionId === msg.session);                                   // 1135\n      self._lastSessionId = msg.session;                                                                          // 1136\n    }                                                                                                             // 1137\n                                                                                                                  // 1138\n    if (reconnectedToPreviousSession) {                                                                           // 1139\n      // Successful reconnection -- pick up where we left off.  Note that right                                   // 1140\n      // now, this never happens: the server never connects us to a previous                                      // 1141\n      // session, because DDP doesn't provide enough data for the server to know                                  // 1142\n      // what messages the client has processed. We need to improve DDP to make                                   // 1143\n      // this possible, at which point we'll probably need more code here.                                        // 1144\n      return;                                                                                                     // 1145\n    }                                                                                                             // 1146\n                                                                                                                  // 1147\n    // Server doesn't have our data any more. Re-sync a new session.                                              // 1148\n                                                                                                                  // 1149\n    // Forget about messages we were buffering for unknown collections. They'll                                   // 1150\n    // be resent if still relevant.                                                                               // 1151\n    self._updatesForUnknownStores = {};                                                                           // 1152\n                                                                                                                  // 1153\n    if (self._resetStores) {                                                                                      // 1154\n      // Forget about the effects of stubs. We'll be resetting all collections                                    // 1155\n      // anyway.                                                                                                  // 1156\n      self._documentsWrittenByStub = {};                                                                          // 1157\n      self._serverDocuments = {};                                                                                 // 1158\n    }                                                                                                             // 1159\n                                                                                                                  // 1160\n    // Clear _afterUpdateCallbacks.                                                                               // 1161\n    self._afterUpdateCallbacks = [];                                                                              // 1162\n                                                                                                                  // 1163\n    // Mark all named subscriptions which are ready (ie, we already called the                                    // 1164\n    // ready callback) as needing to be revived.                                                                  // 1165\n    // XXX We should also block reconnect quiescence until unnamed subscriptions                                  // 1166\n    //     (eg, autopublish) are done re-publishing to avoid flicker!                                             // 1167\n    self._subsBeingRevived = {};                                                                                  // 1168\n    _.each(self._subscriptions, function (sub, id) {                                                              // 1169\n      if (sub.ready)                                                                                              // 1170\n        self._subsBeingRevived[id] = true;                                                                        // 1171\n    });                                                                                                           // 1172\n                                                                                                                  // 1173\n    // Arrange for \"half-finished\" methods to have their callbacks run, and                                       // 1174\n    // track methods that were sent on this connection so that we don't                                           // 1175\n    // quiesce until they are all done.                                                                           // 1176\n    //                                                                                                            // 1177\n    // Start by clearing _methodsBlockingQuiescence: methods sent before                                          // 1178\n    // reconnect don't matter, and any \"wait\" methods sent on the new connection                                  // 1179\n    // that we drop here will be restored by the loop below.                                                      // 1180\n    self._methodsBlockingQuiescence = {};                                                                         // 1181\n    if (self._resetStores) {                                                                                      // 1182\n      _.each(self._methodInvokers, function (invoker) {                                                           // 1183\n        if (invoker.gotResult()) {                                                                                // 1184\n          // This method already got its result, but it didn't call its callback                                  // 1185\n          // because its data didn't become visible. We did not resend the                                        // 1186\n          // method RPC. We'll call its callback when we get a full quiesce,                                      // 1187\n          // since that's as close as we'll get to \"data must be visible\".                                        // 1188\n          self._afterUpdateCallbacks.push(_.bind(invoker.dataVisible, invoker));                                  // 1189\n        } else if (invoker.sentMessage) {                                                                         // 1190\n          // This method has been sent on this connection (maybe as a resend                                      // 1191\n          // from the last connection, maybe from onReconnect, maybe just very                                    // 1192\n          // quickly before processing the connected message).                                                    // 1193\n          //                                                                                                      // 1194\n          // We don't need to do anything special to ensure its callbacks get                                     // 1195\n          // called, but we'll count it as a method which is preventing                                           // 1196\n          // reconnect quiescence. (eg, it might be a login method that was run                                   // 1197\n          // from onReconnect, and we don't want to see flicker by seeing a                                       // 1198\n          // logged-out state.)                                                                                   // 1199\n          self._methodsBlockingQuiescence[invoker.methodId] = true;                                               // 1200\n        }                                                                                                         // 1201\n      });                                                                                                         // 1202\n    }                                                                                                             // 1203\n                                                                                                                  // 1204\n    self._messagesBufferedUntilQuiescence = [];                                                                   // 1205\n                                                                                                                  // 1206\n    // If we're not waiting on any methods or subs, we can reset the stores and                                   // 1207\n    // call the callbacks immediately.                                                                            // 1208\n    if (!self._waitingForQuiescence()) {                                                                          // 1209\n      if (self._resetStores) {                                                                                    // 1210\n        _.each(self._stores, function (s) {                                                                       // 1211\n          s.beginUpdate(0, true);                                                                                 // 1212\n          s.endUpdate();                                                                                          // 1213\n        });                                                                                                       // 1214\n        self._resetStores = false;                                                                                // 1215\n      }                                                                                                           // 1216\n      self._runAfterUpdateCallbacks();                                                                            // 1217\n    }                                                                                                             // 1218\n  },                                                                                                              // 1219\n                                                                                                                  // 1220\n                                                                                                                  // 1221\n  _processOneDataMessage: function (msg, updates) {                                                               // 1222\n    var self = this;                                                                                              // 1223\n    // Using underscore here so as not to need to capitalize.                                                     // 1224\n    self['_process_' + msg.msg](msg, updates);                                                                    // 1225\n  },                                                                                                              // 1226\n                                                                                                                  // 1227\n                                                                                                                  // 1228\n  _livedata_data: function (msg) {                                                                                // 1229\n    var self = this;                                                                                              // 1230\n                                                                                                                  // 1231\n    // collection name -> array of messages                                                                       // 1232\n    var updates = {};                                                                                             // 1233\n                                                                                                                  // 1234\n    if (self._waitingForQuiescence()) {                                                                           // 1235\n      self._messagesBufferedUntilQuiescence.push(msg);                                                            // 1236\n                                                                                                                  // 1237\n      if (msg.msg === \"nosub\")                                                                                    // 1238\n        delete self._subsBeingRevived[msg.id];                                                                    // 1239\n                                                                                                                  // 1240\n      _.each(msg.subs || [], function (subId) {                                                                   // 1241\n        delete self._subsBeingRevived[subId];                                                                     // 1242\n      });                                                                                                         // 1243\n      _.each(msg.methods || [], function (methodId) {                                                             // 1244\n        delete self._methodsBlockingQuiescence[methodId];                                                         // 1245\n      });                                                                                                         // 1246\n                                                                                                                  // 1247\n      if (self._waitingForQuiescence())                                                                           // 1248\n        return;                                                                                                   // 1249\n                                                                                                                  // 1250\n      // No methods or subs are blocking quiescence!                                                              // 1251\n      // We'll now process and all of our buffered messages, reset all stores,                                    // 1252\n      // and apply them all at once.                                                                              // 1253\n      _.each(self._messagesBufferedUntilQuiescence, function (bufferedMsg) {                                      // 1254\n        self._processOneDataMessage(bufferedMsg, updates);                                                        // 1255\n      });                                                                                                         // 1256\n      self._messagesBufferedUntilQuiescence = [];                                                                 // 1257\n    } else {                                                                                                      // 1258\n      self._processOneDataMessage(msg, updates);                                                                  // 1259\n    }                                                                                                             // 1260\n                                                                                                                  // 1261\n    if (self._resetStores || !_.isEmpty(updates)) {                                                               // 1262\n      // Begin a transactional update of each store.                                                              // 1263\n      _.each(self._stores, function (s, storeName) {                                                              // 1264\n        s.beginUpdate(_.has(updates, storeName) ? updates[storeName].length : 0,                                  // 1265\n                      self._resetStores);                                                                         // 1266\n      });                                                                                                         // 1267\n      self._resetStores = false;                                                                                  // 1268\n                                                                                                                  // 1269\n      _.each(updates, function (updateMessages, storeName) {                                                      // 1270\n        var store = self._stores[storeName];                                                                      // 1271\n        if (store) {                                                                                              // 1272\n          _.each(updateMessages, function (updateMessage) {                                                       // 1273\n            store.update(updateMessage);                                                                          // 1274\n          });                                                                                                     // 1275\n        } else {                                                                                                  // 1276\n          // Nobody's listening for this data. Queue it up until                                                  // 1277\n          // someone wants it.                                                                                    // 1278\n          // XXX memory use will grow without bound if you forget to                                              // 1279\n          // create a collection or just don't care about it... going                                             // 1280\n          // to have to do something about that.                                                                  // 1281\n          if (!_.has(self._updatesForUnknownStores, storeName))                                                   // 1282\n            self._updatesForUnknownStores[storeName] = [];                                                        // 1283\n          Array.prototype.push.apply(self._updatesForUnknownStores[storeName],                                    // 1284\n                                     updateMessages);                                                             // 1285\n        }                                                                                                         // 1286\n      });                                                                                                         // 1287\n                                                                                                                  // 1288\n      // End update transaction.                                                                                  // 1289\n      _.each(self._stores, function (s) { s.endUpdate(); });                                                      // 1290\n    }                                                                                                             // 1291\n                                                                                                                  // 1292\n    self._runAfterUpdateCallbacks();                                                                              // 1293\n  },                                                                                                              // 1294\n                                                                                                                  // 1295\n  // Call any callbacks deferred with _runWhenAllServerDocsAreFlushed whose                                       // 1296\n  // relevant docs have been flushed, as well as dataVisible callbacks at                                         // 1297\n  // reconnect-quiescence time.                                                                                   // 1298\n  _runAfterUpdateCallbacks: function () {                                                                         // 1299\n    var self = this;                                                                                              // 1300\n    var callbacks = self._afterUpdateCallbacks;                                                                   // 1301\n    self._afterUpdateCallbacks = [];                                                                              // 1302\n    _.each(callbacks, function (c) {                                                                              // 1303\n      c();                                                                                                        // 1304\n    });                                                                                                           // 1305\n  },                                                                                                              // 1306\n                                                                                                                  // 1307\n  _pushUpdate: function (updates, collection, msg) {                                                              // 1308\n    var self = this;                                                                                              // 1309\n    if (!_.has(updates, collection)) {                                                                            // 1310\n      updates[collection] = [];                                                                                   // 1311\n    }                                                                                                             // 1312\n    updates[collection].push(msg);                                                                                // 1313\n  },                                                                                                              // 1314\n                                                                                                                  // 1315\n  _getServerDoc: function (collection, id) {                                                                      // 1316\n    var self = this;                                                                                              // 1317\n    if (!_.has(self._serverDocuments, collection))                                                                // 1318\n      return null;                                                                                                // 1319\n    var serverDocsForCollection = self._serverDocuments[collection];                                              // 1320\n    return serverDocsForCollection.get(id) || null;                                                               // 1321\n  },                                                                                                              // 1322\n                                                                                                                  // 1323\n  _process_added: function (msg, updates) {                                                                       // 1324\n    var self = this;                                                                                              // 1325\n    var id = MongoID.idParse(msg.id);                                                                             // 1326\n    var serverDoc = self._getServerDoc(msg.collection, id);                                                       // 1327\n    if (serverDoc) {                                                                                              // 1328\n      // Some outstanding stub wrote here.                                                                        // 1329\n      var isExisting = (serverDoc.document !== undefined);                                                        // 1330\n                                                                                                                  // 1331\n      serverDoc.document = msg.fields || {};                                                                      // 1332\n      serverDoc.document._id = id;                                                                                // 1333\n                                                                                                                  // 1334\n      if (self._resetStores) {                                                                                    // 1335\n        // During reconnect the server is sending adds for existing ids.                                          // 1336\n        // Always push an update so that document stays in the store after                                        // 1337\n        // reset. Use current version of the document for this update, so                                         // 1338\n        // that stub-written values are preserved.                                                                // 1339\n        var currentDoc = self._stores[msg.collection].getDoc(msg.id);                                             // 1340\n        if (currentDoc !== undefined)                                                                             // 1341\n          msg.fields = currentDoc;                                                                                // 1342\n                                                                                                                  // 1343\n        self._pushUpdate(updates, msg.collection, msg);                                                           // 1344\n      } else if (isExisting) {                                                                                    // 1345\n        throw new Error(\"Server sent add for existing id: \" + msg.id);                                            // 1346\n      }                                                                                                           // 1347\n    } else {                                                                                                      // 1348\n      self._pushUpdate(updates, msg.collection, msg);                                                             // 1349\n    }                                                                                                             // 1350\n  },                                                                                                              // 1351\n                                                                                                                  // 1352\n  _process_changed: function (msg, updates) {                                                                     // 1353\n    var self = this;                                                                                              // 1354\n    var serverDoc = self._getServerDoc(                                                                           // 1355\n      msg.collection, MongoID.idParse(msg.id));                                                                   // 1356\n    if (serverDoc) {                                                                                              // 1357\n      if (serverDoc.document === undefined)                                                                       // 1358\n        throw new Error(\"Server sent changed for nonexisting id: \" + msg.id);                                     // 1359\n      DiffSequence.applyChanges(serverDoc.document, msg.fields);                                                  // 1360\n    } else {                                                                                                      // 1361\n      self._pushUpdate(updates, msg.collection, msg);                                                             // 1362\n    }                                                                                                             // 1363\n  },                                                                                                              // 1364\n                                                                                                                  // 1365\n  _process_removed: function (msg, updates) {                                                                     // 1366\n    var self = this;                                                                                              // 1367\n    var serverDoc = self._getServerDoc(                                                                           // 1368\n      msg.collection, MongoID.idParse(msg.id));                                                                   // 1369\n    if (serverDoc) {                                                                                              // 1370\n      // Some outstanding stub wrote here.                                                                        // 1371\n      if (serverDoc.document === undefined)                                                                       // 1372\n        throw new Error(\"Server sent removed for nonexisting id:\" + msg.id);                                      // 1373\n      serverDoc.document = undefined;                                                                             // 1374\n    } else {                                                                                                      // 1375\n      self._pushUpdate(updates, msg.collection, {                                                                 // 1376\n        msg: 'removed',                                                                                           // 1377\n        collection: msg.collection,                                                                               // 1378\n        id: msg.id                                                                                                // 1379\n      });                                                                                                         // 1380\n    }                                                                                                             // 1381\n  },                                                                                                              // 1382\n                                                                                                                  // 1383\n  _process_updated: function (msg, updates) {                                                                     // 1384\n    var self = this;                                                                                              // 1385\n    // Process \"method done\" messages.                                                                            // 1386\n    _.each(msg.methods, function (methodId) {                                                                     // 1387\n      _.each(self._documentsWrittenByStub[methodId], function (written) {                                         // 1388\n        var serverDoc = self._getServerDoc(written.collection, written.id);                                       // 1389\n        if (!serverDoc)                                                                                           // 1390\n          throw new Error(\"Lost serverDoc for \" + JSON.stringify(written));                                       // 1391\n        if (!serverDoc.writtenByStubs[methodId])                                                                  // 1392\n          throw new Error(\"Doc \" + JSON.stringify(written) +                                                      // 1393\n                          \" not written by  method \" + methodId);                                                 // 1394\n        delete serverDoc.writtenByStubs[methodId];                                                                // 1395\n        if (_.isEmpty(serverDoc.writtenByStubs)) {                                                                // 1396\n          // All methods whose stubs wrote this method have completed! We can                                     // 1397\n          // now copy the saved document to the database (reverting the stub's                                    // 1398\n          // change if the server did not write to this object, or applying the                                   // 1399\n          // server's writes if it did).                                                                          // 1400\n                                                                                                                  // 1401\n          // This is a fake ddp 'replace' message.  It's just for talking                                         // 1402\n          // between livedata connections and minimongo.  (We have to stringify                                   // 1403\n          // the ID because it's supposed to look like a wire message.)                                           // 1404\n          self._pushUpdate(updates, written.collection, {                                                         // 1405\n            msg: 'replace',                                                                                       // 1406\n            id: MongoID.idStringify(written.id),                                                                  // 1407\n            replace: serverDoc.document                                                                           // 1408\n          });                                                                                                     // 1409\n          // Call all flush callbacks.                                                                            // 1410\n          _.each(serverDoc.flushCallbacks, function (c) {                                                         // 1411\n            c();                                                                                                  // 1412\n          });                                                                                                     // 1413\n                                                                                                                  // 1414\n          // Delete this completed serverDocument. Don't bother to GC empty                                       // 1415\n          // IdMaps inside self._serverDocuments, since there probably aren't                                     // 1416\n          // many collections and they'll be written repeatedly.                                                  // 1417\n          self._serverDocuments[written.collection].remove(written.id);                                           // 1418\n        }                                                                                                         // 1419\n      });                                                                                                         // 1420\n      delete self._documentsWrittenByStub[methodId];                                                              // 1421\n                                                                                                                  // 1422\n      // We want to call the data-written callback, but we can't do so until all                                  // 1423\n      // currently buffered messages are flushed.                                                                 // 1424\n      var callbackInvoker = self._methodInvokers[methodId];                                                       // 1425\n      if (!callbackInvoker)                                                                                       // 1426\n        throw new Error(\"No callback invoker for method \" + methodId);                                            // 1427\n      self._runWhenAllServerDocsAreFlushed(                                                                       // 1428\n        _.bind(callbackInvoker.dataVisible, callbackInvoker));                                                    // 1429\n    });                                                                                                           // 1430\n  },                                                                                                              // 1431\n                                                                                                                  // 1432\n  _process_ready: function (msg, updates) {                                                                       // 1433\n    var self = this;                                                                                              // 1434\n    // Process \"sub ready\" messages. \"sub ready\" messages don't take effect                                       // 1435\n    // until all current server documents have been flushed to the local                                          // 1436\n    // database. We can use a write fence to implement this.                                                      // 1437\n    _.each(msg.subs, function (subId) {                                                                           // 1438\n      self._runWhenAllServerDocsAreFlushed(function () {                                                          // 1439\n        var subRecord = self._subscriptions[subId];                                                               // 1440\n        // Did we already unsubscribe?                                                                            // 1441\n        if (!subRecord)                                                                                           // 1442\n          return;                                                                                                 // 1443\n        // Did we already receive a ready message? (Oops!)                                                        // 1444\n        if (subRecord.ready)                                                                                      // 1445\n          return;                                                                                                 // 1446\n        subRecord.ready = true;                                                                                   // 1447\n        subRecord.readyCallback && subRecord.readyCallback();                                                     // 1448\n        subRecord.readyDeps.changed();                                                                            // 1449\n      });                                                                                                         // 1450\n    });                                                                                                           // 1451\n  },                                                                                                              // 1452\n                                                                                                                  // 1453\n  // Ensures that \"f\" will be called after all documents currently in                                             // 1454\n  // _serverDocuments have been written to the local cache. f will not be called                                  // 1455\n  // if the connection is lost before then!                                                                       // 1456\n  _runWhenAllServerDocsAreFlushed: function (f) {                                                                 // 1457\n    var self = this;                                                                                              // 1458\n    var runFAfterUpdates = function () {                                                                          // 1459\n      self._afterUpdateCallbacks.push(f);                                                                         // 1460\n    };                                                                                                            // 1461\n    var unflushedServerDocCount = 0;                                                                              // 1462\n    var onServerDocFlush = function () {                                                                          // 1463\n      --unflushedServerDocCount;                                                                                  // 1464\n      if (unflushedServerDocCount === 0) {                                                                        // 1465\n        // This was the last doc to flush! Arrange to run f after the updates                                     // 1466\n        // have been applied.                                                                                     // 1467\n        runFAfterUpdates();                                                                                       // 1468\n      }                                                                                                           // 1469\n    };                                                                                                            // 1470\n    _.each(self._serverDocuments, function (collectionDocs) {                                                     // 1471\n      collectionDocs.forEach(function (serverDoc) {                                                               // 1472\n        var writtenByStubForAMethodWithSentMessage = _.any(                                                       // 1473\n          serverDoc.writtenByStubs, function (dummy, methodId) {                                                  // 1474\n            var invoker = self._methodInvokers[methodId];                                                         // 1475\n            return invoker && invoker.sentMessage;                                                                // 1476\n          });                                                                                                     // 1477\n        if (writtenByStubForAMethodWithSentMessage) {                                                             // 1478\n          ++unflushedServerDocCount;                                                                              // 1479\n          serverDoc.flushCallbacks.push(onServerDocFlush);                                                        // 1480\n        }                                                                                                         // 1481\n      });                                                                                                         // 1482\n    });                                                                                                           // 1483\n    if (unflushedServerDocCount === 0) {                                                                          // 1484\n      // There aren't any buffered docs --- we can call f as soon as the current                                  // 1485\n      // round of updates is applied!                                                                             // 1486\n      runFAfterUpdates();                                                                                         // 1487\n    }                                                                                                             // 1488\n  },                                                                                                              // 1489\n                                                                                                                  // 1490\n  _livedata_nosub: function (msg) {                                                                               // 1491\n    var self = this;                                                                                              // 1492\n                                                                                                                  // 1493\n    // First pass it through _livedata_data, which only uses it to help get                                       // 1494\n    // towards quiescence.                                                                                        // 1495\n    self._livedata_data(msg);                                                                                     // 1496\n                                                                                                                  // 1497\n    // Do the rest of our processing immediately, with no                                                         // 1498\n    // buffering-until-quiescence.                                                                                // 1499\n                                                                                                                  // 1500\n    // we weren't subbed anyway, or we initiated the unsub.                                                       // 1501\n    if (!_.has(self._subscriptions, msg.id))                                                                      // 1502\n      return;                                                                                                     // 1503\n                                                                                                                  // 1504\n    // XXX COMPAT WITH 1.0.3.1 #errorCallback                                                                     // 1505\n    var errorCallback = self._subscriptions[msg.id].errorCallback;                                                // 1506\n    var stopCallback = self._subscriptions[msg.id].stopCallback;                                                  // 1507\n                                                                                                                  // 1508\n    self._subscriptions[msg.id].remove();                                                                         // 1509\n                                                                                                                  // 1510\n    var meteorErrorFromMsg = function (msgArg) {                                                                  // 1511\n      return msgArg && msgArg.error && new Meteor.Error(                                                          // 1512\n        msgArg.error.error, msgArg.error.reason, msgArg.error.details);                                           // 1513\n    }                                                                                                             // 1514\n                                                                                                                  // 1515\n    // XXX COMPAT WITH 1.0.3.1 #errorCallback                                                                     // 1516\n    if (errorCallback && msg.error) {                                                                             // 1517\n      errorCallback(meteorErrorFromMsg(msg));                                                                     // 1518\n    }                                                                                                             // 1519\n                                                                                                                  // 1520\n    if (stopCallback) {                                                                                           // 1521\n      stopCallback(meteorErrorFromMsg(msg));                                                                      // 1522\n    }                                                                                                             // 1523\n  },                                                                                                              // 1524\n                                                                                                                  // 1525\n  _process_nosub: function () {                                                                                   // 1526\n    // This is called as part of the \"buffer until quiescence\" process, but                                       // 1527\n    // nosub's effect is always immediate. It only goes in the buffer at all                                      // 1528\n    // because it's possible for a nosub to be the thing that triggers                                            // 1529\n    // quiescence, if we were waiting for a sub to be revived and it dies                                         // 1530\n    // instead.                                                                                                   // 1531\n  },                                                                                                              // 1532\n                                                                                                                  // 1533\n  _livedata_result: function (msg) {                                                                              // 1534\n    // id, result or error. error has error (code), reason, details                                               // 1535\n                                                                                                                  // 1536\n    var self = this;                                                                                              // 1537\n                                                                                                                  // 1538\n    // find the outstanding request                                                                               // 1539\n    // should be O(1) in nearly all realistic use cases                                                           // 1540\n    if (_.isEmpty(self._outstandingMethodBlocks)) {                                                               // 1541\n      Meteor._debug(\"Received method result but no methods outstanding\");                                         // 1542\n      return;                                                                                                     // 1543\n    }                                                                                                             // 1544\n    var currentMethodBlock = self._outstandingMethodBlocks[0].methods;                                            // 1545\n    var m;                                                                                                        // 1546\n    for (var i = 0; i < currentMethodBlock.length; i++) {                                                         // 1547\n      m = currentMethodBlock[i];                                                                                  // 1548\n      if (m.methodId === msg.id)                                                                                  // 1549\n        break;                                                                                                    // 1550\n    }                                                                                                             // 1551\n                                                                                                                  // 1552\n    if (!m) {                                                                                                     // 1553\n      Meteor._debug(\"Can't match method response to original method call\", msg);                                  // 1554\n      return;                                                                                                     // 1555\n    }                                                                                                             // 1556\n                                                                                                                  // 1557\n    // Remove from current method block. This may leave the block empty, but we                                   // 1558\n    // don't move on to the next block until the callback has been delivered, in                                  // 1559\n    // _outstandingMethodFinished.                                                                                // 1560\n    currentMethodBlock.splice(i, 1);                                                                              // 1561\n                                                                                                                  // 1562\n    if (_.has(msg, 'error')) {                                                                                    // 1563\n      m.receiveResult(new Meteor.Error(                                                                           // 1564\n        msg.error.error, msg.error.reason,                                                                        // 1565\n        msg.error.details));                                                                                      // 1566\n    } else {                                                                                                      // 1567\n      // msg.result may be undefined if the method didn't return a                                                // 1568\n      // value                                                                                                    // 1569\n      m.receiveResult(undefined, msg.result);                                                                     // 1570\n    }                                                                                                             // 1571\n  },                                                                                                              // 1572\n                                                                                                                  // 1573\n  // Called by MethodInvoker after a method's callback is invoked.  If this was                                   // 1574\n  // the last outstanding method in the current block, runs the next block. If                                    // 1575\n  // there are no more methods, consider accepting a hot code push.                                               // 1576\n  _outstandingMethodFinished: function () {                                                                       // 1577\n    var self = this;                                                                                              // 1578\n    if (self._anyMethodsAreOutstanding())                                                                         // 1579\n      return;                                                                                                     // 1580\n                                                                                                                  // 1581\n    // No methods are outstanding. This should mean that the first block of                                       // 1582\n    // methods is empty. (Or it might not exist, if this was a method that                                        // 1583\n    // half-finished before disconnect/reconnect.)                                                                // 1584\n    if (! _.isEmpty(self._outstandingMethodBlocks)) {                                                             // 1585\n      var firstBlock = self._outstandingMethodBlocks.shift();                                                     // 1586\n      if (! _.isEmpty(firstBlock.methods))                                                                        // 1587\n        throw new Error(\"No methods outstanding but nonempty block: \" +                                           // 1588\n                        JSON.stringify(firstBlock));                                                              // 1589\n                                                                                                                  // 1590\n      // Send the outstanding methods now in the first block.                                                     // 1591\n      if (!_.isEmpty(self._outstandingMethodBlocks))                                                              // 1592\n        self._sendOutstandingMethods();                                                                           // 1593\n    }                                                                                                             // 1594\n                                                                                                                  // 1595\n    // Maybe accept a hot code push.                                                                              // 1596\n    self._maybeMigrate();                                                                                         // 1597\n  },                                                                                                              // 1598\n                                                                                                                  // 1599\n  // Sends messages for all the methods in the first block in                                                     // 1600\n  // _outstandingMethodBlocks.                                                                                    // 1601\n  _sendOutstandingMethods: function() {                                                                           // 1602\n    var self = this;                                                                                              // 1603\n    if (_.isEmpty(self._outstandingMethodBlocks))                                                                 // 1604\n      return;                                                                                                     // 1605\n    _.each(self._outstandingMethodBlocks[0].methods, function (m) {                                               // 1606\n      m.sendMessage();                                                                                            // 1607\n    });                                                                                                           // 1608\n  },                                                                                                              // 1609\n                                                                                                                  // 1610\n  _livedata_error: function (msg) {                                                                               // 1611\n    Meteor._debug(\"Received error from server: \", msg.reason);                                                    // 1612\n    if (msg.offendingMessage)                                                                                     // 1613\n      Meteor._debug(\"For: \", msg.offendingMessage);                                                               // 1614\n  },                                                                                                              // 1615\n                                                                                                                  // 1616\n  _callOnReconnectAndSendAppropriateOutstandingMethods: function() {                                              // 1617\n    var self = this;                                                                                              // 1618\n    var oldOutstandingMethodBlocks = self._outstandingMethodBlocks;                                               // 1619\n    self._outstandingMethodBlocks = [];                                                                           // 1620\n                                                                                                                  // 1621\n    self.onReconnect();                                                                                           // 1622\n                                                                                                                  // 1623\n    if (_.isEmpty(oldOutstandingMethodBlocks))                                                                    // 1624\n      return;                                                                                                     // 1625\n                                                                                                                  // 1626\n    // We have at least one block worth of old outstanding methods to try                                         // 1627\n    // again. First: did onReconnect actually send anything? If not, we just                                      // 1628\n    // restore all outstanding methods and run the first block.                                                   // 1629\n    if (_.isEmpty(self._outstandingMethodBlocks)) {                                                               // 1630\n      self._outstandingMethodBlocks = oldOutstandingMethodBlocks;                                                 // 1631\n      self._sendOutstandingMethods();                                                                             // 1632\n      return;                                                                                                     // 1633\n    }                                                                                                             // 1634\n                                                                                                                  // 1635\n    // OK, there are blocks on both sides. Special case: merge the last block of                                  // 1636\n    // the reconnect methods with the first block of the original methods, if                                     // 1637\n    // neither of them are \"wait\" blocks.                                                                         // 1638\n    if (!_.last(self._outstandingMethodBlocks).wait &&                                                            // 1639\n        !oldOutstandingMethodBlocks[0].wait) {                                                                    // 1640\n      _.each(oldOutstandingMethodBlocks[0].methods, function (m) {                                                // 1641\n        _.last(self._outstandingMethodBlocks).methods.push(m);                                                    // 1642\n                                                                                                                  // 1643\n        // If this \"last block\" is also the first block, send the message.                                        // 1644\n        if (self._outstandingMethodBlocks.length === 1)                                                           // 1645\n          m.sendMessage();                                                                                        // 1646\n      });                                                                                                         // 1647\n                                                                                                                  // 1648\n      oldOutstandingMethodBlocks.shift();                                                                         // 1649\n    }                                                                                                             // 1650\n                                                                                                                  // 1651\n    // Now add the rest of the original blocks on.                                                                // 1652\n    _.each(oldOutstandingMethodBlocks, function (block) {                                                         // 1653\n      self._outstandingMethodBlocks.push(block);                                                                  // 1654\n    });                                                                                                           // 1655\n  },                                                                                                              // 1656\n                                                                                                                  // 1657\n  // We can accept a hot code push if there are no methods in flight.                                             // 1658\n  _readyToMigrate: function() {                                                                                   // 1659\n    var self = this;                                                                                              // 1660\n    return _.isEmpty(self._methodInvokers);                                                                       // 1661\n  },                                                                                                              // 1662\n                                                                                                                  // 1663\n  // If we were blocking a migration, see if it's now possible to continue.                                       // 1664\n  // Call whenever the set of outstanding/blocked methods shrinks.                                                // 1665\n  _maybeMigrate: function () {                                                                                    // 1666\n    var self = this;                                                                                              // 1667\n    if (self._retryMigrate && self._readyToMigrate()) {                                                           // 1668\n      self._retryMigrate();                                                                                       // 1669\n      self._retryMigrate = null;                                                                                  // 1670\n    }                                                                                                             // 1671\n  }                                                                                                               // 1672\n});                                                                                                               // 1673\n                                                                                                                  // 1674\nLivedataTest.Connection = Connection;                                                                             // 1675\n                                                                                                                  // 1676\n// @param url {String} URL to Meteor app,                                                                         // 1677\n//     e.g.:                                                                                                      // 1678\n//     \"subdomain.meteor.com\",                                                                                    // 1679\n//     \"http://subdomain.meteor.com\",                                                                             // 1680\n//     \"/\",                                                                                                       // 1681\n//     \"ddp+sockjs://ddp--****-foo.meteor.com/sockjs\"                                                             // 1682\n                                                                                                                  // 1683\n/**                                                                                                               // 1684\n * @summary Connect to the server of a different Meteor application to subscribe to its document sets and invoke its remote methods.\n * @locus Anywhere                                                                                                // 1686\n * @param {String} url The URL of another Meteor application.                                                     // 1687\n */                                                                                                               // 1688\nDDP.connect = function (url, options) {                                                                           // 1689\n  var ret = new Connection(url, options);                                                                         // 1690\n  allConnections.push(ret); // hack. see below.                                                                   // 1691\n  return ret;                                                                                                     // 1692\n};                                                                                                                // 1693\n                                                                                                                  // 1694\n// Hack for `spiderable` package: a way to see if the page is done                                                // 1695\n// loading all the data it needs.                                                                                 // 1696\n//                                                                                                                // 1697\nallConnections = [];                                                                                              // 1698\nDDP._allSubscriptionsReady = function () {                                                                        // 1699\n  return _.all(allConnections, function (conn) {                                                                  // 1700\n    return _.all(conn._subscriptions, function (sub) {                                                            // 1701\n      return sub.ready;                                                                                           // 1702\n    });                                                                                                           // 1703\n  });                                                                                                             // 1704\n};                                                                                                                // 1705\n                                                                                                                  // 1706\n////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n}).call(this);\n\n\n\n\n\n\n(function(){\n\n////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n//                                                                                                                //\n// packages/ddp-client/client_convenience.js                                                                      //\n//                                                                                                                //\n////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n                                                                                                                  //\n// Meteor.refresh can be called on the client (if you're in common code) but it                                   // 1\n// only has an effect on the server.                                                                              // 2\nMeteor.refresh = function (notification) {                                                                        // 3\n};                                                                                                                // 4\n                                                                                                                  // 5\nif (Meteor.isClient) {                                                                                            // 6\n  // By default, try to connect back to the same endpoint as the page                                             // 7\n  // was served from.                                                                                             // 8\n  //                                                                                                              // 9\n  // XXX We should be doing this a different way. Right now we don't                                              // 10\n  // include ROOT_URL_PATH_PREFIX when computing ddpUrl. (We don't                                                // 11\n  // include it on the server when computing                                                                      // 12\n  // DDP_DEFAULT_CONNECTION_URL, and we don't include it in our                                                   // 13\n  // default, '/'.) We get by with this because DDP.connect then                                                  // 14\n  // forces the URL passed to it to be interpreted relative to the                                                // 15\n  // app's deploy path, even if it is absolute. Instead, we should                                                // 16\n  // make DDP_DEFAULT_CONNECTION_URL, if set, include the path prefix;                                            // 17\n  // make the default ddpUrl be '' rather that '/'; and make                                                      // 18\n  // _translateUrl in stream_client_common.js not force absolute paths                                            // 19\n  // to be treated like relative paths. See also                                                                  // 20\n  // stream_client_common.js #RationalizingRelativeDDPURLs                                                        // 21\n  var ddpUrl = '/';                                                                                               // 22\n  if (typeof __meteor_runtime_config__ !== \"undefined\") {                                                         // 23\n    if (__meteor_runtime_config__.DDP_DEFAULT_CONNECTION_URL)                                                     // 24\n      ddpUrl = __meteor_runtime_config__.DDP_DEFAULT_CONNECTION_URL;                                              // 25\n  }                                                                                                               // 26\n                                                                                                                  // 27\n  var retry = new Retry();                                                                                        // 28\n                                                                                                                  // 29\n  var onDDPVersionNegotiationFailure = function (description) {                                                   // 30\n    Meteor._debug(description);                                                                                   // 31\n    if (Package.reload) {                                                                                         // 32\n      var migrationData = Package.reload.Reload._migrationData('livedata') || {};                                 // 33\n      var failures = migrationData.DDPVersionNegotiationFailures || 0;                                            // 34\n      ++failures;                                                                                                 // 35\n      Package.reload.Reload._onMigrate('livedata', function () {                                                  // 36\n        return [true, {DDPVersionNegotiationFailures: failures}];                                                 // 37\n      });                                                                                                         // 38\n      retry.retryLater(failures, function () {                                                                    // 39\n        Package.reload.Reload._reload();                                                                          // 40\n      });                                                                                                         // 41\n    }                                                                                                             // 42\n  };                                                                                                              // 43\n                                                                                                                  // 44\n  Meteor.connection =                                                                                             // 45\n    DDP.connect(ddpUrl, {                                                                                         // 46\n      onDDPVersionNegotiationFailure: onDDPVersionNegotiationFailure                                              // 47\n    });                                                                                                           // 48\n                                                                                                                  // 49\n  // Proxy the public methods of Meteor.connection so they can                                                    // 50\n  // be called directly on Meteor.                                                                                // 51\n  _.each(['subscribe', 'methods', 'call', 'apply', 'status', 'reconnect',                                         // 52\n          'disconnect'],                                                                                          // 53\n         function (name) {                                                                                        // 54\n           Meteor[name] = _.bind(Meteor.connection[name], Meteor.connection);                                     // 55\n         });                                                                                                      // 56\n} else {                                                                                                          // 57\n  // Never set up a default connection on the server. Don't even map                                              // 58\n  // subscribe/call/etc onto Meteor.                                                                              // 59\n  Meteor.connection = null;                                                                                       // 60\n}                                                                                                                 // 61\n                                                                                                                  // 62\n// Meteor.connection used to be called                                                                            // 63\n// Meteor.default_connection. Provide backcompat as a courtesy even                                               // 64\n// though it was never documented.                                                                                // 65\n// XXX COMPAT WITH 0.6.4                                                                                          // 66\nMeteor.default_connection = Meteor.connection;                                                                    // 67\n                                                                                                                  // 68\n// We should transition from Meteor.connect to DDP.connect.                                                       // 69\n// XXX COMPAT WITH 0.6.4                                                                                          // 70\nMeteor.connect = DDP.connect;                                                                                     // 71\n                                                                                                                  // 72\n////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n}).call(this);\n\n\n/* Exports */\nif (typeof Package === 'undefined') Package = {};\n(function (pkg, symbols) {\n  for (var s in symbols)\n    (s in pkg) || (pkg[s] = symbols[s]);\n})(Package['ddp-client'] = {}, {\n  DDP: DDP,\n  LivedataTest: LivedataTest\n});\n\n})();\n","servePath":"/packages/ddp-client.js","sourceMap":{"version":3,"sources":["/packages/ddp-client/namespace.js","/packages/ddp-client/id_map.js","/packages/ddp-client/sockjs-0.3.4.js","/packages/ddp-client/stream_client_sockjs.js","/packages/ddp-client/stream_client_common.js","/packages/ddp-client/livedata_common.js","/packages/ddp-client/random_stream.js","/packages/ddp-client/livedata_connection.js","/packages/ddp-client/client_convenience.js"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA,sH;;;;;;;;;;;;;;;;;;ACNA;AACA;AACA;AACA;AACA;AACA;AACA,sH;;;;;;;;;;;;;;;;;;ACNA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yH;;;;;;;;;;;;;;;;;;AC15EA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wH;;;;;;;;;;;;;;;;;;AClMA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wH;;;;;;;;;;;;;;;;;;AC1QA;AACA;AACA;AACA;AACA;AACA;AACA,sH;;;;;;;;;;;;;;;;;;ACNA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uH;;;;;;;;;;;;;;;;;;ACTA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yH;;;;;;;;;;;;;;;;;;ACzqDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uH","file":"/packages/ddp-client.js","sourcesContent":["/**\n * @namespace DDP\n * @summary Namespace for DDP-related methods/classes.\n */\nDDP          = {};\nLivedataTest = {};\n","MongoIDMap = function () {\n  var self = this;\n  IdMap.call(self, MongoID.idStringify, MongoID.idParse);\n};\n\nMeteor._inherits(MongoIDMap, IdMap);\n","// XXX METEOR changes in <METEOR>\n\n/* SockJS client, version 0.3.4, http://sockjs.org, MIT License\n\nCopyright (c) 2011-2012 VMware, Inc.\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in\nall copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\nTHE SOFTWARE.\n*/\n\n// <METEOR> Commented out JSO implementation (use json package instead).\n// JSON2 by Douglas Crockford (minified).\n// var JSON;JSON||(JSON={}),function(){function str(a,b){var c,d,e,f,g=gap,h,i=b[a];i&&typeof i==\"object\"&&typeof i.toJSON==\"function\"&&(i=i.toJSON(a)),typeof rep==\"function\"&&(i=rep.call(b,a,i));switch(typeof i){case\"string\":return quote(i);case\"number\":return isFinite(i)?String(i):\"null\";case\"boolean\":case\"null\":return String(i);case\"object\":if(!i)return\"null\";gap+=indent,h=[];if(Object.prototype.toString.apply(i)===\"[object Array]\"){f=i.length;for(c=0;c<f;c+=1)h[c]=str(c,i)||\"null\";e=h.length===0?\"[]\":gap?\"[\\n\"+gap+h.join(\",\\n\"+gap)+\"\\n\"+g+\"]\":\"[\"+h.join(\",\")+\"]\",gap=g;return e}if(rep&&typeof rep==\"object\"){f=rep.length;for(c=0;c<f;c+=1)typeof rep[c]==\"string\"&&(d=rep[c],e=str(d,i),e&&h.push(quote(d)+(gap?\": \":\":\")+e))}else for(d in i)Object.prototype.hasOwnProperty.call(i,d)&&(e=str(d,i),e&&h.push(quote(d)+(gap?\": \":\":\")+e));e=h.length===0?\"{}\":gap?\"{\\n\"+gap+h.join(\",\\n\"+gap)+\"\\n\"+g+\"}\":\"{\"+h.join(\",\")+\"}\",gap=g;return e}}function quote(a){escapable.lastIndex=0;return escapable.test(a)?'\"'+a.replace(escapable,function(a){var b=meta[a];return typeof b==\"string\"?b:\"\\\\u\"+(\"0000\"+a.charCodeAt(0).toString(16)).slice(-4)})+'\"':'\"'+a+'\"'}function f(a){return a<10?\"0\"+a:a}\"use strict\",typeof Date.prototype.toJSON!=\"function\"&&(Date.prototype.toJSON=function(a){return isFinite(this.valueOf())?this.getUTCFullYear()+\"-\"+f(this.getUTCMonth()+1)+\"-\"+f(this.getUTCDate())+\"T\"+f(this.getUTCHours())+\":\"+f(this.getUTCMinutes())+\":\"+f(this.getUTCSeconds())+\"Z\":null},String.prototype.toJSON=Number.prototype.toJSON=Boolean.prototype.toJSON=function(a){return this.valueOf()});var cx=/[\\u0000\\u00ad\\u0600-\\u0604\\u070f\\u17b4\\u17b5\\u200c-\\u200f\\u2028-\\u202f\\u2060-\\u206f\\ufeff\\ufff0-\\uffff]/g,escapable=/[\\\\\\\"\\x00-\\x1f\\x7f-\\x9f\\u00ad\\u0600-\\u0604\\u070f\\u17b4\\u17b5\\u200c-\\u200f\\u2028-\\u202f\\u2060-\\u206f\\ufeff\\ufff0-\\uffff]/g,gap,indent,meta={\"\\b\":\"\\\\b\",\"\\t\":\"\\\\t\",\"\\n\":\"\\\\n\",\"\\f\":\"\\\\f\",\"\\r\":\"\\\\r\",'\"':'\\\\\"',\"\\\\\":\"\\\\\\\\\"},rep;typeof JSON.stringify!=\"function\"&&(JSON.stringify=function(a,b,c){var d;gap=\"\",indent=\"\";if(typeof c==\"number\")for(d=0;d<c;d+=1)indent+=\" \";else typeof c==\"string\"&&(indent=c);rep=b;if(!b||typeof b==\"function\"||typeof b==\"object\"&&typeof b.length==\"number\")return str(\"\",{\"\":a});throw new Error(\"JSON.stringify\")}),typeof JSON.parse!=\"function\"&&(JSON.parse=function(text,reviver){function walk(a,b){var c,d,e=a[b];if(e&&typeof e==\"object\")for(c in e)Object.prototype.hasOwnProperty.call(e,c)&&(d=walk(e,c),d!==undefined?e[c]=d:delete e[c]);return reviver.call(a,b,e)}var j;text=String(text),cx.lastIndex=0,cx.test(text)&&(text=text.replace(cx,function(a){return\"\\\\u\"+(\"0000\"+a.charCodeAt(0).toString(16)).slice(-4)}));if(/^[\\],:{}\\s]*$/.test(text.replace(/\\\\(?:[\"\\\\\\/bfnrt]|u[0-9a-fA-F]{4})/g,\"@\").replace(/\"[^\"\\\\\\n\\r]*\"|true|false|null|-?\\d+(?:\\.\\d*)?(?:[eE][+\\-]?\\d+)?/g,\"]\").replace(/(?:^|:|,)(?:\\s*\\[)+/g,\"\"))){j=eval(\"(\"+text+\")\");return typeof reviver==\"function\"?walk({\"\":j},\"\"):j}throw new SyntaxError(\"JSON.parse\")})}()\n// </METEOR>\n\n//     [*] Including lib/index.js\n// Public object\nSockJS = (function(){\n              var _document = document;\n              var _window = window;\n              var utils = {};\n\n\n//         [*] Including lib/reventtarget.js\n/*\n * ***** BEGIN LICENSE BLOCK *****\n * Copyright (c) 2011-2012 VMware, Inc.\n *\n * For the license see COPYING.\n * ***** END LICENSE BLOCK *****\n */\n\n/* Simplified implementation of DOM2 EventTarget.\n *   http://www.w3.org/TR/DOM-Level-2-Events/events.html#Events-EventTarget\n */\nvar REventTarget = function() {};\nREventTarget.prototype.addEventListener = function (eventType, listener) {\n    if(!this._listeners) {\n         this._listeners = {};\n    }\n    if(!(eventType in this._listeners)) {\n        this._listeners[eventType] = [];\n    }\n    var arr = this._listeners[eventType];\n    if(utils.arrIndexOf(arr, listener) === -1) {\n        arr.push(listener);\n    }\n    return;\n};\n\nREventTarget.prototype.removeEventListener = function (eventType, listener) {\n    if(!(this._listeners && (eventType in this._listeners))) {\n        return;\n    }\n    var arr = this._listeners[eventType];\n    var idx = utils.arrIndexOf(arr, listener);\n    if (idx !== -1) {\n        if(arr.length > 1) {\n            this._listeners[eventType] = arr.slice(0, idx).concat( arr.slice(idx+1) );\n        } else {\n            delete this._listeners[eventType];\n        }\n        return;\n    }\n    return;\n};\n\nREventTarget.prototype.dispatchEvent = function (event) {\n    var t = event.type;\n    var args = Array.prototype.slice.call(arguments, 0);\n    if (this['on'+t]) {\n        this['on'+t].apply(this, args);\n    }\n    if (this._listeners && t in this._listeners) {\n        for(var i=0; i < this._listeners[t].length; i++) {\n            this._listeners[t][i].apply(this, args);\n        }\n    }\n};\n//         [*] End of lib/reventtarget.js\n\n\n//         [*] Including lib/simpleevent.js\n/*\n * ***** BEGIN LICENSE BLOCK *****\n * Copyright (c) 2011-2012 VMware, Inc.\n *\n * For the license see COPYING.\n * ***** END LICENSE BLOCK *****\n */\n\nvar SimpleEvent = function(type, obj) {\n    this.type = type;\n    if (typeof obj !== 'undefined') {\n        for(var k in obj) {\n            if (!obj.hasOwnProperty(k)) continue;\n            this[k] = obj[k];\n        }\n    }\n};\n\nSimpleEvent.prototype.toString = function() {\n    var r = [];\n    for(var k in this) {\n        if (!this.hasOwnProperty(k)) continue;\n        var v = this[k];\n        if (typeof v === 'function') v = '[function]';\n        r.push(k + '=' + v);\n    }\n    return 'SimpleEvent(' + r.join(', ') + ')';\n};\n//         [*] End of lib/simpleevent.js\n\n\n//         [*] Including lib/eventemitter.js\n/*\n * ***** BEGIN LICENSE BLOCK *****\n * Copyright (c) 2011-2012 VMware, Inc.\n *\n * For the license see COPYING.\n * ***** END LICENSE BLOCK *****\n */\n\nvar EventEmitter = function(events) {\n    var that = this;\n    that._events = events || [];\n    that._listeners = {};\n};\nEventEmitter.prototype.emit = function(type) {\n    var that = this;\n    that._verifyType(type);\n    if (that._nuked) return;\n\n    var args = Array.prototype.slice.call(arguments, 1);\n    if (that['on'+type]) {\n        that['on'+type].apply(that, args);\n    }\n    if (type in that._listeners) {\n        for(var i = 0; i < that._listeners[type].length; i++) {\n            that._listeners[type][i].apply(that, args);\n        }\n    }\n};\n\nEventEmitter.prototype.on = function(type, callback) {\n    var that = this;\n    that._verifyType(type);\n    if (that._nuked) return;\n\n    if (!(type in that._listeners)) {\n        that._listeners[type] = [];\n    }\n    that._listeners[type].push(callback);\n};\n\nEventEmitter.prototype._verifyType = function(type) {\n    var that = this;\n    if (utils.arrIndexOf(that._events, type) === -1) {\n        utils.log('Event ' + JSON.stringify(type) +\n                  ' not listed ' + JSON.stringify(that._events) +\n                  ' in ' + that);\n    }\n};\n\nEventEmitter.prototype.nuke = function() {\n    var that = this;\n    that._nuked = true;\n    for(var i=0; i<that._events.length; i++) {\n        delete that[that._events[i]];\n    }\n    that._listeners = {};\n};\n//         [*] End of lib/eventemitter.js\n\n\n//         [*] Including lib/utils.js\n/*\n * ***** BEGIN LICENSE BLOCK *****\n * Copyright (c) 2011-2012 VMware, Inc.\n *\n * For the license see COPYING.\n * ***** END LICENSE BLOCK *****\n */\n\nvar random_string_chars = 'abcdefghijklmnopqrstuvwxyz0123456789_';\nutils.random_string = function(length, max) {\n    max = max || random_string_chars.length;\n    var i, ret = [];\n    for(i=0; i < length; i++) {\n        ret.push( random_string_chars.substr(Math.floor(Math.random() * max),1) );\n    }\n    return ret.join('');\n};\nutils.random_number = function(max) {\n    return Math.floor(Math.random() * max);\n};\nutils.random_number_string = function(max) {\n    var t = (''+(max - 1)).length;\n    var p = Array(t+1).join('0');\n    return (p + utils.random_number(max)).slice(-t);\n};\n\n// Assuming that url looks like: http://asdasd:111/asd\nutils.getOrigin = function(url) {\n    url += '/';\n    var parts = url.split('/').slice(0, 3);\n    return parts.join('/');\n};\n\nutils.isSameOriginUrl = function(url_a, url_b) {\n    // location.origin would do, but it's not always available.\n    if (!url_b) url_b = _window.location.href;\n\n    return (url_a.split('/').slice(0,3).join('/')\n                ===\n            url_b.split('/').slice(0,3).join('/'));\n};\n\n// <METEOR>\n// https://github.com/sockjs/sockjs-client/issues/79\nutils.isSameOriginScheme = function(url_a, url_b) {\n    if (!url_b) url_b = _window.location.href;\n\n    return (url_a.split(':')[0]\n                ===\n            url_b.split(':')[0]);\n};\n// </METEOR>\n\n\nutils.getParentDomain = function(url) {\n    // ipv4 ip address\n    if (/^[0-9.]*$/.test(url)) return url;\n    // ipv6 ip address\n    if (/^\\[/.test(url)) return url;\n    // no dots\n    if (!(/[.]/.test(url))) return url;\n\n    var parts = url.split('.').slice(1);\n    return parts.join('.');\n};\n\nutils.objectExtend = function(dst, src) {\n    for(var k in src) {\n        if (src.hasOwnProperty(k)) {\n            dst[k] = src[k];\n        }\n    }\n    return dst;\n};\n\nvar WPrefix = '_jp';\n\nutils.polluteGlobalNamespace = function() {\n    if (!(WPrefix in _window)) {\n        _window[WPrefix] = {};\n    }\n};\n\nutils.closeFrame = function (code, reason) {\n    return 'c'+JSON.stringify([code, reason]);\n};\n\nutils.userSetCode = function (code) {\n    return code === 1000 || (code >= 3000 && code <= 4999);\n};\n\n// See: http://www.erg.abdn.ac.uk/~gerrit/dccp/notes/ccid2/rto_estimator/\n// and RFC 2988.\nutils.countRTO = function (rtt) {\n    var rto;\n    if (rtt > 100) {\n        rto = 3 * rtt; // rto > 300msec\n    } else {\n        rto = rtt + 200; // 200msec < rto <= 300msec\n    }\n    return rto;\n}\n\nutils.log = function() {\n    if (_window.console && console.log && console.log.apply) {\n        console.log.apply(console, arguments);\n    }\n};\n\nutils.bind = function(fun, that) {\n    if (fun.bind) {\n        return fun.bind(that);\n    } else {\n        return function() {\n            return fun.apply(that, arguments);\n        };\n    }\n};\n\nutils.flatUrl = function(url) {\n    return url.indexOf('?') === -1 && url.indexOf('#') === -1;\n};\n\n// `relativeTo` is an optional absolute URL. If provided, `url` will be\n// interpreted relative to `relativeTo`. Defaults to `document.location`.\n// <METEOR>\nutils.amendUrl = function(url, relativeTo) {\n    var baseUrl;\n    if (relativeTo === undefined) {\n      baseUrl = _document.location;\n    } else {\n      var protocolMatch = /^([a-z0-9.+-]+:)/i.exec(relativeTo);\n      if (protocolMatch) {\n        var protocol = protocolMatch[0].toLowerCase();\n        var rest = relativeTo.substring(protocol.length);\n        var hostMatch = /[a-z0-9\\.-]+(:[0-9]+)?/.exec(rest);\n        if (hostMatch)\n          var host = hostMatch[0];\n      }\n      if (! protocol || ! host)\n        throw new Error(\"relativeTo must be an absolute url\");\n      baseUrl = {\n        protocol: protocol,\n        host: host\n      };\n    }\n    if (!url) {\n        throw new Error('Wrong url for SockJS');\n    }\n    if (!utils.flatUrl(url)) {\n        throw new Error('Only basic urls are supported in SockJS');\n    }\n\n    //  '//abc' --> 'http://abc'\n    if (url.indexOf('//') === 0) {\n        url = baseUrl.protocol + url;\n    }\n    // '/abc' --> 'http://localhost:1234/abc'\n    if (url.indexOf('/') === 0) {\n        url = baseUrl.protocol + '//' + baseUrl.host + url;\n    }\n    // </METEOR>\n    // strip trailing slashes\n    url = url.replace(/[/]+$/,'');\n\n    // We have a full url here, with proto and host. For some browsers\n    // http://localhost:80/ is not in the same origin as http://localhost/\n\t// Remove explicit :80 or :443 in such cases. See #74\n    var parts = url.split(\"/\");\n    if ((parts[0] === \"http:\" && /:80$/.test(parts[2])) ||\n\t    (parts[0] === \"https:\" && /:443$/.test(parts[2]))) {\n\t\tparts[2] = parts[2].replace(/:(80|443)$/, \"\");\n\t}\n    url = parts.join(\"/\");\n    return url;\n};\n\n// IE doesn't support [].indexOf.\nutils.arrIndexOf = function(arr, obj){\n    for(var i=0; i < arr.length; i++){\n        if(arr[i] === obj){\n            return i;\n        }\n    }\n    return -1;\n};\n\nutils.arrSkip = function(arr, obj) {\n    var idx = utils.arrIndexOf(arr, obj);\n    if (idx === -1) {\n        return arr.slice();\n    } else {\n        var dst = arr.slice(0, idx);\n        return dst.concat(arr.slice(idx+1));\n    }\n};\n\n// Via: https://gist.github.com/1133122/2121c601c5549155483f50be3da5305e83b8c5df\nutils.isArray = Array.isArray || function(value) {\n    return {}.toString.call(value).indexOf('Array') >= 0\n};\n\nutils.delay = function(t, fun) {\n    if(typeof t === 'function') {\n        fun = t;\n        t = 0;\n    }\n    return setTimeout(fun, t);\n};\n\n\n// Chars worth escaping, as defined by Douglas Crockford:\n//   https://github.com/douglascrockford/JSON-js/blob/47a9882cddeb1e8529e07af9736218075372b8ac/json2.js#L196\nvar json_escapable = /[\\\\\\\"\\x00-\\x1f\\x7f-\\x9f\\u00ad\\u0600-\\u0604\\u070f\\u17b4\\u17b5\\u200c-\\u200f\\u2028-\\u202f\\u2060-\\u206f\\ufeff\\ufff0-\\uffff]/g,\n    json_lookup = {\n\"\\u0000\":\"\\\\u0000\",\"\\u0001\":\"\\\\u0001\",\"\\u0002\":\"\\\\u0002\",\"\\u0003\":\"\\\\u0003\",\n\"\\u0004\":\"\\\\u0004\",\"\\u0005\":\"\\\\u0005\",\"\\u0006\":\"\\\\u0006\",\"\\u0007\":\"\\\\u0007\",\n\"\\b\":\"\\\\b\",\"\\t\":\"\\\\t\",\"\\n\":\"\\\\n\",\"\\u000b\":\"\\\\u000b\",\"\\f\":\"\\\\f\",\"\\r\":\"\\\\r\",\n\"\\u000e\":\"\\\\u000e\",\"\\u000f\":\"\\\\u000f\",\"\\u0010\":\"\\\\u0010\",\"\\u0011\":\"\\\\u0011\",\n\"\\u0012\":\"\\\\u0012\",\"\\u0013\":\"\\\\u0013\",\"\\u0014\":\"\\\\u0014\",\"\\u0015\":\"\\\\u0015\",\n\"\\u0016\":\"\\\\u0016\",\"\\u0017\":\"\\\\u0017\",\"\\u0018\":\"\\\\u0018\",\"\\u0019\":\"\\\\u0019\",\n\"\\u001a\":\"\\\\u001a\",\"\\u001b\":\"\\\\u001b\",\"\\u001c\":\"\\\\u001c\",\"\\u001d\":\"\\\\u001d\",\n\"\\u001e\":\"\\\\u001e\",\"\\u001f\":\"\\\\u001f\",\"\\\"\":\"\\\\\\\"\",\"\\\\\":\"\\\\\\\\\",\n\"\\u007f\":\"\\\\u007f\",\"\\u0080\":\"\\\\u0080\",\"\\u0081\":\"\\\\u0081\",\"\\u0082\":\"\\\\u0082\",\n\"\\u0083\":\"\\\\u0083\",\"\\u0084\":\"\\\\u0084\",\"\\u0085\":\"\\\\u0085\",\"\\u0086\":\"\\\\u0086\",\n\"\\u0087\":\"\\\\u0087\",\"\\u0088\":\"\\\\u0088\",\"\\u0089\":\"\\\\u0089\",\"\\u008a\":\"\\\\u008a\",\n\"\\u008b\":\"\\\\u008b\",\"\\u008c\":\"\\\\u008c\",\"\\u008d\":\"\\\\u008d\",\"\\u008e\":\"\\\\u008e\",\n\"\\u008f\":\"\\\\u008f\",\"\\u0090\":\"\\\\u0090\",\"\\u0091\":\"\\\\u0091\",\"\\u0092\":\"\\\\u0092\",\n\"\\u0093\":\"\\\\u0093\",\"\\u0094\":\"\\\\u0094\",\"\\u0095\":\"\\\\u0095\",\"\\u0096\":\"\\\\u0096\",\n\"\\u0097\":\"\\\\u0097\",\"\\u0098\":\"\\\\u0098\",\"\\u0099\":\"\\\\u0099\",\"\\u009a\":\"\\\\u009a\",\n\"\\u009b\":\"\\\\u009b\",\"\\u009c\":\"\\\\u009c\",\"\\u009d\":\"\\\\u009d\",\"\\u009e\":\"\\\\u009e\",\n\"\\u009f\":\"\\\\u009f\",\"\\u00ad\":\"\\\\u00ad\",\"\\u0600\":\"\\\\u0600\",\"\\u0601\":\"\\\\u0601\",\n\"\\u0602\":\"\\\\u0602\",\"\\u0603\":\"\\\\u0603\",\"\\u0604\":\"\\\\u0604\",\"\\u070f\":\"\\\\u070f\",\n\"\\u17b4\":\"\\\\u17b4\",\"\\u17b5\":\"\\\\u17b5\",\"\\u200c\":\"\\\\u200c\",\"\\u200d\":\"\\\\u200d\",\n\"\\u200e\":\"\\\\u200e\",\"\\u200f\":\"\\\\u200f\",\"\\u2028\":\"\\\\u2028\",\"\\u2029\":\"\\\\u2029\",\n\"\\u202a\":\"\\\\u202a\",\"\\u202b\":\"\\\\u202b\",\"\\u202c\":\"\\\\u202c\",\"\\u202d\":\"\\\\u202d\",\n\"\\u202e\":\"\\\\u202e\",\"\\u202f\":\"\\\\u202f\",\"\\u2060\":\"\\\\u2060\",\"\\u2061\":\"\\\\u2061\",\n\"\\u2062\":\"\\\\u2062\",\"\\u2063\":\"\\\\u2063\",\"\\u2064\":\"\\\\u2064\",\"\\u2065\":\"\\\\u2065\",\n\"\\u2066\":\"\\\\u2066\",\"\\u2067\":\"\\\\u2067\",\"\\u2068\":\"\\\\u2068\",\"\\u2069\":\"\\\\u2069\",\n\"\\u206a\":\"\\\\u206a\",\"\\u206b\":\"\\\\u206b\",\"\\u206c\":\"\\\\u206c\",\"\\u206d\":\"\\\\u206d\",\n\"\\u206e\":\"\\\\u206e\",\"\\u206f\":\"\\\\u206f\",\"\\ufeff\":\"\\\\ufeff\",\"\\ufff0\":\"\\\\ufff0\",\n\"\\ufff1\":\"\\\\ufff1\",\"\\ufff2\":\"\\\\ufff2\",\"\\ufff3\":\"\\\\ufff3\",\"\\ufff4\":\"\\\\ufff4\",\n\"\\ufff5\":\"\\\\ufff5\",\"\\ufff6\":\"\\\\ufff6\",\"\\ufff7\":\"\\\\ufff7\",\"\\ufff8\":\"\\\\ufff8\",\n\"\\ufff9\":\"\\\\ufff9\",\"\\ufffa\":\"\\\\ufffa\",\"\\ufffb\":\"\\\\ufffb\",\"\\ufffc\":\"\\\\ufffc\",\n\"\\ufffd\":\"\\\\ufffd\",\"\\ufffe\":\"\\\\ufffe\",\"\\uffff\":\"\\\\uffff\"};\n\n// Some extra characters that Chrome gets wrong, and substitutes with\n// something else on the wire.\nvar extra_escapable = /[\\x00-\\x1f\\ud800-\\udfff\\ufffe\\uffff\\u0300-\\u0333\\u033d-\\u0346\\u034a-\\u034c\\u0350-\\u0352\\u0357-\\u0358\\u035c-\\u0362\\u0374\\u037e\\u0387\\u0591-\\u05af\\u05c4\\u0610-\\u0617\\u0653-\\u0654\\u0657-\\u065b\\u065d-\\u065e\\u06df-\\u06e2\\u06eb-\\u06ec\\u0730\\u0732-\\u0733\\u0735-\\u0736\\u073a\\u073d\\u073f-\\u0741\\u0743\\u0745\\u0747\\u07eb-\\u07f1\\u0951\\u0958-\\u095f\\u09dc-\\u09dd\\u09df\\u0a33\\u0a36\\u0a59-\\u0a5b\\u0a5e\\u0b5c-\\u0b5d\\u0e38-\\u0e39\\u0f43\\u0f4d\\u0f52\\u0f57\\u0f5c\\u0f69\\u0f72-\\u0f76\\u0f78\\u0f80-\\u0f83\\u0f93\\u0f9d\\u0fa2\\u0fa7\\u0fac\\u0fb9\\u1939-\\u193a\\u1a17\\u1b6b\\u1cda-\\u1cdb\\u1dc0-\\u1dcf\\u1dfc\\u1dfe\\u1f71\\u1f73\\u1f75\\u1f77\\u1f79\\u1f7b\\u1f7d\\u1fbb\\u1fbe\\u1fc9\\u1fcb\\u1fd3\\u1fdb\\u1fe3\\u1feb\\u1fee-\\u1fef\\u1ff9\\u1ffb\\u1ffd\\u2000-\\u2001\\u20d0-\\u20d1\\u20d4-\\u20d7\\u20e7-\\u20e9\\u2126\\u212a-\\u212b\\u2329-\\u232a\\u2adc\\u302b-\\u302c\\uaab2-\\uaab3\\uf900-\\ufa0d\\ufa10\\ufa12\\ufa15-\\ufa1e\\ufa20\\ufa22\\ufa25-\\ufa26\\ufa2a-\\ufa2d\\ufa30-\\ufa6d\\ufa70-\\ufad9\\ufb1d\\ufb1f\\ufb2a-\\ufb36\\ufb38-\\ufb3c\\ufb3e\\ufb40-\\ufb41\\ufb43-\\ufb44\\ufb46-\\ufb4e\\ufff0-\\uffff]/g,\n    extra_lookup;\n\n// JSON Quote string. Use native implementation when possible.\nvar JSONQuote = (JSON && JSON.stringify) || function(string) {\n    json_escapable.lastIndex = 0;\n    if (json_escapable.test(string)) {\n        string = string.replace(json_escapable, function(a) {\n            return json_lookup[a];\n        });\n    }\n    return '\"' + string + '\"';\n};\n\n// This may be quite slow, so let's delay until user actually uses bad\n// characters.\nvar unroll_lookup = function(escapable) {\n    var i;\n    var unrolled = {}\n    var c = []\n    for(i=0; i<65536; i++) {\n        c.push( String.fromCharCode(i) );\n    }\n    escapable.lastIndex = 0;\n    c.join('').replace(escapable, function (a) {\n        unrolled[ a ] = '\\\\u' + ('0000' + a.charCodeAt(0).toString(16)).slice(-4);\n        return '';\n    });\n    escapable.lastIndex = 0;\n    return unrolled;\n};\n\n// Quote string, also taking care of unicode characters that browsers\n// often break. Especially, take care of unicode surrogates:\n//    http://en.wikipedia.org/wiki/Mapping_of_Unicode_characters#Surrogates\nutils.quote = function(string) {\n    var quoted = JSONQuote(string);\n\n    // In most cases this should be very fast and good enough.\n    extra_escapable.lastIndex = 0;\n    if(!extra_escapable.test(quoted)) {\n        return quoted;\n    }\n\n    if(!extra_lookup) extra_lookup = unroll_lookup(extra_escapable);\n\n    return quoted.replace(extra_escapable, function(a) {\n        return extra_lookup[a];\n    });\n}\n\nvar _all_protocols = ['websocket',\n                      'xdr-streaming',\n                      'xhr-streaming',\n                      'iframe-eventsource',\n                      'iframe-htmlfile',\n                      'xdr-polling',\n                      'xhr-polling',\n                      'iframe-xhr-polling',\n                      'jsonp-polling'];\n\nutils.probeProtocols = function() {\n    var probed = {};\n    for(var i=0; i<_all_protocols.length; i++) {\n        var protocol = _all_protocols[i];\n        // User can have a typo in protocol name.\n        probed[protocol] = SockJS[protocol] &&\n                           SockJS[protocol].enabled();\n    }\n    return probed;\n};\n\nutils.detectProtocols = function(probed, protocols_whitelist, info) {\n    var pe = {},\n        protocols = [];\n    if (!protocols_whitelist) protocols_whitelist = _all_protocols;\n    for(var i=0; i<protocols_whitelist.length; i++) {\n        var protocol = protocols_whitelist[i];\n        pe[protocol] = probed[protocol];\n    }\n    var maybe_push = function(protos) {\n        var proto = protos.shift();\n        if (pe[proto]) {\n            protocols.push(proto);\n        } else {\n            if (protos.length > 0) {\n                maybe_push(protos);\n            }\n        }\n    }\n\n    // 1. Websocket\n    if (info.websocket !== false) {\n        maybe_push(['websocket']);\n    }\n\n    // 2. Streaming\n    if (pe['xhr-streaming'] && !info.null_origin) {\n        protocols.push('xhr-streaming');\n    } else {\n        if (pe['xdr-streaming'] && !info.cookie_needed && !info.null_origin) {\n            protocols.push('xdr-streaming');\n        } else {\n            maybe_push(['iframe-eventsource',\n                        'iframe-htmlfile']);\n        }\n    }\n\n    // 3. Polling\n    if (pe['xhr-polling'] && !info.null_origin) {\n        protocols.push('xhr-polling');\n    } else {\n        if (pe['xdr-polling'] && !info.cookie_needed && !info.null_origin) {\n            protocols.push('xdr-polling');\n        } else {\n            maybe_push(['iframe-xhr-polling',\n                        'jsonp-polling']);\n        }\n    }\n    return protocols;\n}\n//         [*] End of lib/utils.js\n\n\n//         [*] Including lib/dom.js\n/*\n * ***** BEGIN LICENSE BLOCK *****\n * Copyright (c) 2011-2012 VMware, Inc.\n *\n * For the license see COPYING.\n * ***** END LICENSE BLOCK *****\n */\n\n// May be used by htmlfile jsonp and transports.\nvar MPrefix = '_sockjs_global';\nutils.createHook = function() {\n    var window_id = 'a' + utils.random_string(8);\n    if (!(MPrefix in _window)) {\n        var map = {};\n        _window[MPrefix] = function(window_id) {\n            if (!(window_id in map)) {\n                map[window_id] = {\n                    id: window_id,\n                    del: function() {delete map[window_id];}\n                };\n            }\n            return map[window_id];\n        }\n    }\n    return _window[MPrefix](window_id);\n};\n\n\n\nutils.attachMessage = function(listener) {\n    utils.attachEvent('message', listener);\n};\nutils.attachEvent = function(event, listener) {\n    if (typeof _window.addEventListener !== 'undefined') {\n        _window.addEventListener(event, listener, false);\n    } else {\n        // IE quirks.\n        // According to: http://stevesouders.com/misc/test-postmessage.php\n        // the message gets delivered only to 'document', not 'window'.\n        _document.attachEvent(\"on\" + event, listener);\n        // I get 'window' for ie8.\n        _window.attachEvent(\"on\" + event, listener);\n    }\n};\n\nutils.detachMessage = function(listener) {\n    utils.detachEvent('message', listener);\n};\nutils.detachEvent = function(event, listener) {\n    if (typeof _window.addEventListener !== 'undefined') {\n        _window.removeEventListener(event, listener, false);\n    } else {\n        _document.detachEvent(\"on\" + event, listener);\n        _window.detachEvent(\"on\" + event, listener);\n    }\n};\n\n\nvar on_unload = {};\n// Things registered after beforeunload are to be called immediately.\nvar after_unload = false;\n\nvar trigger_unload_callbacks = function() {\n    for(var ref in on_unload) {\n        on_unload[ref]();\n        delete on_unload[ref];\n    };\n};\n\nvar unload_triggered = function() {\n    if(after_unload) return;\n    after_unload = true;\n    trigger_unload_callbacks();\n};\n\n// 'unload' alone is not reliable in opera within an iframe, but we\n// can't use `beforeunload` as IE fires it on javascript: links.\nutils.attachEvent('unload', unload_triggered);\n\nutils.unload_add = function(listener) {\n    var ref = utils.random_string(8);\n    on_unload[ref] = listener;\n    if (after_unload) {\n        utils.delay(trigger_unload_callbacks);\n    }\n    return ref;\n};\nutils.unload_del = function(ref) {\n    if (ref in on_unload)\n        delete on_unload[ref];\n};\n\n\nutils.createIframe = function (iframe_url, error_callback) {\n    var iframe = _document.createElement('iframe');\n    var tref, unload_ref;\n    var unattach = function() {\n        clearTimeout(tref);\n        // Explorer had problems with that.\n        try {iframe.onload = null;} catch (x) {}\n        iframe.onerror = null;\n    };\n    var cleanup = function() {\n        if (iframe) {\n            unattach();\n            // This timeout makes chrome fire onbeforeunload event\n            // within iframe. Without the timeout it goes straight to\n            // onunload.\n            setTimeout(function() {\n                if(iframe) {\n                    iframe.parentNode.removeChild(iframe);\n                }\n                iframe = null;\n            }, 0);\n            utils.unload_del(unload_ref);\n        }\n    };\n    var onerror = function(r) {\n        if (iframe) {\n            cleanup();\n            error_callback(r);\n        }\n    };\n    var post = function(msg, origin) {\n        try {\n            // When the iframe is not loaded, IE raises an exception\n            // on 'contentWindow'.\n            if (iframe && iframe.contentWindow) {\n                iframe.contentWindow.postMessage(msg, origin);\n            }\n        } catch (x) {};\n    };\n\n    iframe.src = iframe_url;\n    iframe.style.display = 'none';\n    iframe.style.position = 'absolute';\n    iframe.onerror = function(){onerror('onerror');};\n    iframe.onload = function() {\n        // `onload` is triggered before scripts on the iframe are\n        // executed. Give it few seconds to actually load stuff.\n        clearTimeout(tref);\n        tref = setTimeout(function(){onerror('onload timeout');}, 2000);\n    };\n    _document.body.appendChild(iframe);\n    tref = setTimeout(function(){onerror('timeout');}, 15000);\n    unload_ref = utils.unload_add(cleanup);\n    return {\n        post: post,\n        cleanup: cleanup,\n        loaded: unattach\n    };\n};\n\nutils.createHtmlfile = function (iframe_url, error_callback) {\n    var doc = new ActiveXObject('htmlfile');\n    var tref, unload_ref;\n    var iframe;\n    var unattach = function() {\n        clearTimeout(tref);\n    };\n    var cleanup = function() {\n        if (doc) {\n            unattach();\n            utils.unload_del(unload_ref);\n            iframe.parentNode.removeChild(iframe);\n            iframe = doc = null;\n            CollectGarbage();\n        }\n    };\n    var onerror = function(r)  {\n        if (doc) {\n            cleanup();\n            error_callback(r);\n        }\n    };\n    var post = function(msg, origin) {\n        try {\n            // When the iframe is not loaded, IE raises an exception\n            // on 'contentWindow'.\n            if (iframe && iframe.contentWindow) {\n                iframe.contentWindow.postMessage(msg, origin);\n            }\n        } catch (x) {};\n    };\n\n    doc.open();\n    doc.write('<html><s' + 'cript>' +\n              'document.domain=\"' + document.domain + '\";' +\n              '</s' + 'cript></html>');\n    doc.close();\n    doc.parentWindow[WPrefix] = _window[WPrefix];\n    var c = doc.createElement('div');\n    doc.body.appendChild(c);\n    iframe = doc.createElement('iframe');\n    c.appendChild(iframe);\n    iframe.src = iframe_url;\n    tref = setTimeout(function(){onerror('timeout');}, 15000);\n    unload_ref = utils.unload_add(cleanup);\n    return {\n        post: post,\n        cleanup: cleanup,\n        loaded: unattach\n    };\n};\n//         [*] End of lib/dom.js\n\n\n//         [*] Including lib/dom2.js\n/*\n * ***** BEGIN LICENSE BLOCK *****\n * Copyright (c) 2011-2012 VMware, Inc.\n *\n * For the license see COPYING.\n * ***** END LICENSE BLOCK *****\n */\n\nvar AbstractXHRObject = function(){};\nAbstractXHRObject.prototype = new EventEmitter(['chunk', 'finish']);\n\nAbstractXHRObject.prototype._start = function(method, url, payload, opts) {\n    var that = this;\n\n    try {\n        that.xhr = new XMLHttpRequest();\n    } catch(x) {};\n\n    if (!that.xhr) {\n        try {\n            that.xhr = new _window.ActiveXObject('Microsoft.XMLHTTP');\n        } catch(x) {};\n    }\n    if (_window.ActiveXObject || _window.XDomainRequest) {\n        // IE8 caches even POSTs\n        url += ((url.indexOf('?') === -1) ? '?' : '&') + 't='+(+new Date);\n    }\n\n    // Explorer tends to keep connection open, even after the\n    // tab gets closed: http://bugs.jquery.com/ticket/5280\n    that.unload_ref = utils.unload_add(function(){that._cleanup(true);});\n    try {\n        that.xhr.open(method, url, true);\n    } catch(e) {\n        // IE raises an exception on wrong port.\n        that.emit('finish', 0, '');\n        that._cleanup();\n        return;\n    };\n\n    if (!opts || !opts.no_credentials) {\n        // Mozilla docs says https://developer.mozilla.org/en/XMLHttpRequest :\n        // \"This never affects same-site requests.\"\n        that.xhr.withCredentials = 'true';\n    }\n    if (opts && opts.headers) {\n        for(var key in opts.headers) {\n            that.xhr.setRequestHeader(key, opts.headers[key]);\n        }\n    }\n\n    that.xhr.onreadystatechange = function() {\n        if (that.xhr) {\n            var x = that.xhr;\n            switch (x.readyState) {\n            case 3:\n                // IE doesn't like peeking into responseText or status\n                // on Microsoft.XMLHTTP and readystate=3\n                try {\n                    var status = x.status;\n                    var text = x.responseText;\n                } catch (x) {};\n                // IE returns 1223 for 204: http://bugs.jquery.com/ticket/1450\n                if (status === 1223) status = 204;\n\n                // IE does return readystate == 3 for 404 answers.\n                if (text && text.length > 0) {\n                    that.emit('chunk', status, text);\n                }\n                break;\n            case 4:\n                var status = x.status;\n                // IE returns 1223 for 204: http://bugs.jquery.com/ticket/1450\n                if (status === 1223) status = 204;\n\n                that.emit('finish', status, x.responseText);\n                that._cleanup(false);\n                break;\n            }\n        }\n    };\n    that.xhr.send(payload);\n};\n\nAbstractXHRObject.prototype._cleanup = function(abort) {\n    var that = this;\n    if (!that.xhr) return;\n    utils.unload_del(that.unload_ref);\n\n    // IE needs this field to be a function\n    that.xhr.onreadystatechange = function(){};\n\n    if (abort) {\n        try {\n            that.xhr.abort();\n        } catch(x) {};\n    }\n    that.unload_ref = that.xhr = null;\n};\n\nAbstractXHRObject.prototype.close = function() {\n    var that = this;\n    that.nuke();\n    that._cleanup(true);\n};\n\nvar XHRCorsObject = utils.XHRCorsObject = function() {\n    var that = this, args = arguments;\n    utils.delay(function(){that._start.apply(that, args);});\n};\nXHRCorsObject.prototype = new AbstractXHRObject();\n\nvar XHRLocalObject = utils.XHRLocalObject = function(method, url, payload) {\n    var that = this;\n    utils.delay(function(){\n        that._start(method, url, payload, {\n            no_credentials: true\n        });\n    });\n};\nXHRLocalObject.prototype = new AbstractXHRObject();\n\n\n\n// References:\n//   http://ajaxian.com/archives/100-line-ajax-wrapper\n//   http://msdn.microsoft.com/en-us/library/cc288060(v=VS.85).aspx\nvar XDRObject = utils.XDRObject = function(method, url, payload) {\n    var that = this;\n    utils.delay(function(){that._start(method, url, payload);});\n};\nXDRObject.prototype = new EventEmitter(['chunk', 'finish']);\nXDRObject.prototype._start = function(method, url, payload) {\n    var that = this;\n    var xdr = new XDomainRequest();\n    // IE caches even POSTs\n    url += ((url.indexOf('?') === -1) ? '?' : '&') + 't='+(+new Date);\n\n    var onerror = xdr.ontimeout = xdr.onerror = function() {\n        that.emit('finish', 0, '');\n        that._cleanup(false);\n    };\n    xdr.onprogress = function() {\n        that.emit('chunk', 200, xdr.responseText);\n    };\n    xdr.onload = function() {\n        that.emit('finish', 200, xdr.responseText);\n        that._cleanup(false);\n    };\n    that.xdr = xdr;\n    that.unload_ref = utils.unload_add(function(){that._cleanup(true);});\n    try {\n        // Fails with AccessDenied if port number is bogus\n        that.xdr.open(method, url);\n        that.xdr.send(payload);\n    } catch(x) {\n        onerror();\n    }\n};\n\nXDRObject.prototype._cleanup = function(abort) {\n    var that = this;\n    if (!that.xdr) return;\n    utils.unload_del(that.unload_ref);\n\n    that.xdr.ontimeout = that.xdr.onerror = that.xdr.onprogress =\n        that.xdr.onload = null;\n    if (abort) {\n        try {\n            that.xdr.abort();\n        } catch(x) {};\n    }\n    that.unload_ref = that.xdr = null;\n};\n\nXDRObject.prototype.close = function() {\n    var that = this;\n    that.nuke();\n    that._cleanup(true);\n};\n\n// 1. Is natively via XHR\n// 2. Is natively via XDR\n// 3. Nope, but postMessage is there so it should work via the Iframe.\n// 4. Nope, sorry.\nutils.isXHRCorsCapable = function() {\n    if (_window.XMLHttpRequest && 'withCredentials' in new XMLHttpRequest()) {\n        return 1;\n    }\n    // XDomainRequest doesn't work if page is served from file://\n    if (_window.XDomainRequest && _document.domain) {\n        return 2;\n    }\n    if (IframeTransport.enabled()) {\n        return 3;\n    }\n    return 4;\n};\n//         [*] End of lib/dom2.js\n\n\n//         [*] Including lib/sockjs.js\n/*\n * ***** BEGIN LICENSE BLOCK *****\n * Copyright (c) 2011-2012 VMware, Inc.\n *\n * For the license see COPYING.\n * ***** END LICENSE BLOCK *****\n */\n\nvar SockJS = function(url, dep_protocols_whitelist, options) {\n    if (!(this instanceof SockJS)) {\n        // makes `new` optional\n        return new SockJS(url, dep_protocols_whitelist, options);\n    }\n\n    var that = this, protocols_whitelist;\n    that._options = {devel: false, debug: false, protocols_whitelist: [],\n                     info: undefined, rtt: undefined};\n    if (options) {\n        utils.objectExtend(that._options, options);\n    }\n    that._base_url = utils.amendUrl(url);\n    that._server = that._options.server || utils.random_number_string(1000);\n    if (that._options.protocols_whitelist &&\n        that._options.protocols_whitelist.length) {\n        protocols_whitelist = that._options.protocols_whitelist;\n    } else {\n        // Deprecated API\n        if (typeof dep_protocols_whitelist === 'string' &&\n            dep_protocols_whitelist.length > 0) {\n            protocols_whitelist = [dep_protocols_whitelist];\n        } else if (utils.isArray(dep_protocols_whitelist)) {\n            protocols_whitelist = dep_protocols_whitelist\n        } else {\n            protocols_whitelist = null;\n        }\n        if (protocols_whitelist) {\n            that._debug('Deprecated API: Use \"protocols_whitelist\" option ' +\n                        'instead of supplying protocol list as a second ' +\n                        'parameter to SockJS constructor.');\n        }\n    }\n    that._protocols = [];\n    that.protocol = null;\n    that.readyState = SockJS.CONNECTING;\n    that._ir = createInfoReceiver(that._base_url);\n    that._ir.onfinish = function(info, rtt) {\n        that._ir = null;\n        if (info) {\n            if (that._options.info) {\n                // Override if user supplies the option\n                info = utils.objectExtend(info, that._options.info);\n            }\n            if (that._options.rtt) {\n                rtt = that._options.rtt;\n            }\n            that._applyInfo(info, rtt, protocols_whitelist);\n            that._didClose();\n        } else {\n            that._didClose(1002, 'Can\\'t connect to server', true);\n        }\n    };\n};\n// Inheritance\nSockJS.prototype = new REventTarget();\n\nSockJS.version = \"0.3.4\";\n\nSockJS.CONNECTING = 0;\nSockJS.OPEN = 1;\nSockJS.CLOSING = 2;\nSockJS.CLOSED = 3;\n\nSockJS.prototype._debug = function() {\n    if (this._options.debug)\n        utils.log.apply(utils, arguments);\n};\n\nSockJS.prototype._dispatchOpen = function() {\n    var that = this;\n    if (that.readyState === SockJS.CONNECTING) {\n        if (that._transport_tref) {\n            clearTimeout(that._transport_tref);\n            that._transport_tref = null;\n        }\n        that.readyState = SockJS.OPEN;\n        that.dispatchEvent(new SimpleEvent(\"open\"));\n    } else {\n        // The server might have been restarted, and lost track of our\n        // connection.\n        that._didClose(1006, \"Server lost session\");\n    }\n};\n\nSockJS.prototype._dispatchMessage = function(data) {\n    var that = this;\n    if (that.readyState !== SockJS.OPEN)\n            return;\n    that.dispatchEvent(new SimpleEvent(\"message\", {data: data}));\n};\n\nSockJS.prototype._dispatchHeartbeat = function(data) {\n    var that = this;\n    if (that.readyState !== SockJS.OPEN)\n        return;\n    that.dispatchEvent(new SimpleEvent('heartbeat', {}));\n};\n\nSockJS.prototype._didClose = function(code, reason, force) {\n    var that = this;\n    if (that.readyState !== SockJS.CONNECTING &&\n        that.readyState !== SockJS.OPEN &&\n        that.readyState !== SockJS.CLOSING)\n            throw new Error('INVALID_STATE_ERR');\n    if (that._ir) {\n        that._ir.nuke();\n        that._ir = null;\n    }\n\n    if (that._transport) {\n        that._transport.doCleanup();\n        that._transport = null;\n    }\n\n    var close_event = new SimpleEvent(\"close\", {\n        code: code,\n        reason: reason,\n        wasClean: utils.userSetCode(code)});\n\n    if (!utils.userSetCode(code) &&\n        that.readyState === SockJS.CONNECTING && !force) {\n        if (that._try_next_protocol(close_event)) {\n            return;\n        }\n        close_event = new SimpleEvent(\"close\", {code: 2000,\n                                                reason: \"All transports failed\",\n                                                wasClean: false,\n                                                last_event: close_event});\n    }\n    that.readyState = SockJS.CLOSED;\n\n    utils.delay(function() {\n                   that.dispatchEvent(close_event);\n                });\n};\n\nSockJS.prototype._didMessage = function(data) {\n    var that = this;\n    var type = data.slice(0, 1);\n    switch(type) {\n    case 'o':\n        that._dispatchOpen();\n        break;\n    case 'a':\n        var payload = JSON.parse(data.slice(1) || '[]');\n        for(var i=0; i < payload.length; i++){\n            that._dispatchMessage(payload[i]);\n        }\n        break;\n    case 'm':\n        var payload = JSON.parse(data.slice(1) || 'null');\n        that._dispatchMessage(payload);\n        break;\n    case 'c':\n        var payload = JSON.parse(data.slice(1) || '[]');\n        that._didClose(payload[0], payload[1]);\n        break;\n    case 'h':\n        that._dispatchHeartbeat();\n        break;\n    }\n};\n\nSockJS.prototype._try_next_protocol = function(close_event) {\n    var that = this;\n    if (that.protocol) {\n        that._debug('Closed transport:', that.protocol, ''+close_event);\n        that.protocol = null;\n    }\n    if (that._transport_tref) {\n        clearTimeout(that._transport_tref);\n        that._transport_tref = null;\n    }\n\n    while(1) {\n        var protocol = that.protocol = that._protocols.shift();\n        if (!protocol) {\n            return false;\n        }\n        // Some protocols require access to `body`, what if were in\n        // the `head`?\n        if (SockJS[protocol] &&\n            SockJS[protocol].need_body === true &&\n            (!_document.body ||\n             (typeof _document.readyState !== 'undefined'\n              && _document.readyState !== 'complete'))) {\n            that._protocols.unshift(protocol);\n            that.protocol = 'waiting-for-load';\n            utils.attachEvent('load', function(){\n                that._try_next_protocol();\n            });\n            return true;\n        }\n\n        if (!SockJS[protocol] ||\n              !SockJS[protocol].enabled(that._options)) {\n            that._debug('Skipping transport:', protocol);\n        } else {\n            var roundTrips = SockJS[protocol].roundTrips || 1;\n            var to = ((that._options.rto || 0) * roundTrips) || 5000;\n            that._transport_tref = utils.delay(to, function() {\n                if (that.readyState === SockJS.CONNECTING) {\n                    // I can't understand how it is possible to run\n                    // this timer, when the state is CLOSED, but\n                    // apparently in IE everythin is possible.\n                    that._didClose(2007, \"Transport timeouted\");\n                }\n            });\n\n            var connid = utils.random_string(8);\n            var trans_url = that._base_url + '/' + that._server + '/' + connid;\n            that._debug('Opening transport:', protocol, ' url:'+trans_url,\n                        ' RTO:'+that._options.rto);\n            that._transport = new SockJS[protocol](that, trans_url,\n                                                   that._base_url);\n            return true;\n        }\n    }\n};\n\nSockJS.prototype.close = function(code, reason) {\n    var that = this;\n    if (code && !utils.userSetCode(code))\n        throw new Error(\"INVALID_ACCESS_ERR\");\n    if(that.readyState !== SockJS.CONNECTING &&\n       that.readyState !== SockJS.OPEN) {\n        return false;\n    }\n    that.readyState = SockJS.CLOSING;\n    that._didClose(code || 1000, reason || \"Normal closure\");\n    return true;\n};\n\nSockJS.prototype.send = function(data) {\n    var that = this;\n    if (that.readyState === SockJS.CONNECTING)\n        throw new Error('INVALID_STATE_ERR');\n    if (that.readyState === SockJS.OPEN) {\n        that._transport.doSend(utils.quote('' + data));\n    }\n    return true;\n};\n\nSockJS.prototype._applyInfo = function(info, rtt, protocols_whitelist) {\n    var that = this;\n    that._options.info = info;\n    that._options.rtt = rtt;\n    that._options.rto = utils.countRTO(rtt);\n    that._options.info.null_origin = !_document.domain;\n    // Servers can override base_url, eg to provide a randomized domain name and\n    // avoid browser per-domain connection limits.\n    if (info.base_url)\n      // <METEOR>\n      that._base_url = utils.amendUrl(info.base_url, that._base_url);\n      // </METEOR>\n    var probed = utils.probeProtocols();\n    that._protocols = utils.detectProtocols(probed, protocols_whitelist, info);\n// <METEOR>\n// https://github.com/sockjs/sockjs-client/issues/79\n    // Hack to avoid XDR when using different protocols\n    // We're on IE trying to do cross-protocol. jsonp only.\n    if (!utils.isSameOriginScheme(that._base_url) &&\n        2 === utils.isXHRCorsCapable()) {\n        that._protocols = ['jsonp-polling'];\n    }\n// </METEOR>\n};\n//         [*] End of lib/sockjs.js\n\n\n//         [*] Including lib/trans-websocket.js\n/*\n * ***** BEGIN LICENSE BLOCK *****\n * Copyright (c) 2011-2012 VMware, Inc.\n *\n * For the license see COPYING.\n * ***** END LICENSE BLOCK *****\n */\n\nvar WebSocketTransport = SockJS.websocket = function(ri, trans_url) {\n    var that = this;\n    var url = trans_url + '/websocket';\n    if (url.slice(0, 5) === 'https') {\n        url = 'wss' + url.slice(5);\n    } else {\n        url = 'ws' + url.slice(4);\n    }\n    that.ri = ri;\n    that.url = url;\n    var Constructor = _window.WebSocket || _window.MozWebSocket;\n\n    that.ws = new Constructor(that.url);\n    that.ws.onmessage = function(e) {\n        that.ri._didMessage(e.data);\n    };\n    // Firefox has an interesting bug. If a websocket connection is\n    // created after onunload, it stays alive even when user\n    // navigates away from the page. In such situation let's lie -\n    // let's not open the ws connection at all. See:\n    // https://github.com/sockjs/sockjs-client/issues/28\n    // https://bugzilla.mozilla.org/show_bug.cgi?id=696085\n    that.unload_ref = utils.unload_add(function(){that.ws.close()});\n    that.ws.onclose = function() {\n        that.ri._didMessage(utils.closeFrame(1006, \"WebSocket connection broken\"));\n    };\n};\n\nWebSocketTransport.prototype.doSend = function(data) {\n    this.ws.send('[' + data + ']');\n};\n\nWebSocketTransport.prototype.doCleanup = function() {\n    var that = this;\n    var ws = that.ws;\n    if (ws) {\n        ws.onmessage = ws.onclose = null;\n        ws.close();\n        utils.unload_del(that.unload_ref);\n        that.unload_ref = that.ri = that.ws = null;\n    }\n};\n\nWebSocketTransport.enabled = function() {\n    return !!(_window.WebSocket || _window.MozWebSocket);\n};\n\n// In theory, ws should require 1 round trip. But in chrome, this is\n// not very stable over SSL. Most likely a ws connection requires a\n// separate SSL connection, in which case 2 round trips are an\n// absolute minumum.\nWebSocketTransport.roundTrips = 2;\n//         [*] End of lib/trans-websocket.js\n\n\n//         [*] Including lib/trans-sender.js\n/*\n * ***** BEGIN LICENSE BLOCK *****\n * Copyright (c) 2011-2012 VMware, Inc.\n *\n * For the license see COPYING.\n * ***** END LICENSE BLOCK *****\n */\n\nvar BufferedSender = function() {};\nBufferedSender.prototype.send_constructor = function(sender) {\n    var that = this;\n    that.send_buffer = [];\n    that.sender = sender;\n};\nBufferedSender.prototype.doSend = function(message) {\n    var that = this;\n    that.send_buffer.push(message);\n    if (!that.send_stop) {\n        that.send_schedule();\n    }\n};\n\n// For polling transports in a situation when in the message callback,\n// new message is being send. If the sending connection was started\n// before receiving one, it is possible to saturate the network and\n// timeout due to the lack of receiving socket. To avoid that we delay\n// sending messages by some small time, in order to let receiving\n// connection be started beforehand. This is only a halfmeasure and\n// does not fix the big problem, but it does make the tests go more\n// stable on slow networks.\nBufferedSender.prototype.send_schedule_wait = function() {\n    var that = this;\n    var tref;\n    that.send_stop = function() {\n        that.send_stop = null;\n        clearTimeout(tref);\n    };\n    tref = utils.delay(25, function() {\n        that.send_stop = null;\n        that.send_schedule();\n    });\n};\n\nBufferedSender.prototype.send_schedule = function() {\n    var that = this;\n    if (that.send_buffer.length > 0) {\n        var payload = '[' + that.send_buffer.join(',') + ']';\n        that.send_stop = that.sender(that.trans_url, payload, function(success, abort_reason) {\n            that.send_stop = null;\n            if (success === false) {\n                that.ri._didClose(1006, 'Sending error ' + abort_reason);\n            } else {\n                that.send_schedule_wait();\n            }\n        });\n        that.send_buffer = [];\n    }\n};\n\nBufferedSender.prototype.send_destructor = function() {\n    var that = this;\n    if (that._send_stop) {\n        that._send_stop();\n    }\n    that._send_stop = null;\n};\n\nvar jsonPGenericSender = function(url, payload, callback) {\n    var that = this;\n\n    if (!('_send_form' in that)) {\n        var form = that._send_form = _document.createElement('form');\n        var area = that._send_area = _document.createElement('textarea');\n        area.name = 'd';\n        form.style.display = 'none';\n        form.style.position = 'absolute';\n        form.method = 'POST';\n        form.enctype = 'application/x-www-form-urlencoded';\n        form.acceptCharset = \"UTF-8\";\n        form.appendChild(area);\n        _document.body.appendChild(form);\n    }\n    var form = that._send_form;\n    var area = that._send_area;\n    var id = 'a' + utils.random_string(8);\n    form.target = id;\n    form.action = url + '/jsonp_send?i=' + id;\n\n    var iframe;\n    try {\n        // ie6 dynamic iframes with target=\"\" support (thanks Chris Lambacher)\n        iframe = _document.createElement('<iframe name=\"'+ id +'\">');\n    } catch(x) {\n        iframe = _document.createElement('iframe');\n        iframe.name = id;\n    }\n    iframe.id = id;\n    form.appendChild(iframe);\n    iframe.style.display = 'none';\n\n    try {\n        area.value = payload;\n    } catch(e) {\n        utils.log('Your browser is seriously broken. Go home! ' + e.message);\n    }\n    form.submit();\n\n    var completed = function(e) {\n        if (!iframe.onerror) return;\n        iframe.onreadystatechange = iframe.onerror = iframe.onload = null;\n        // Opera mini doesn't like if we GC iframe\n        // immediately, thus this timeout.\n        utils.delay(500, function() {\n                       iframe.parentNode.removeChild(iframe);\n                       iframe = null;\n                   });\n        area.value = '';\n        // It is not possible to detect if the iframe succeeded or\n        // failed to submit our form.\n        callback(true);\n    };\n    iframe.onerror = iframe.onload = completed;\n    iframe.onreadystatechange = function(e) {\n        if (iframe.readyState == 'complete') completed();\n    };\n    return completed;\n};\n\nvar createAjaxSender = function(AjaxObject) {\n    return function(url, payload, callback) {\n        var xo = new AjaxObject('POST', url + '/xhr_send', payload);\n        xo.onfinish = function(status, text) {\n            callback(status === 200 || status === 204,\n                     'http status ' + status);\n        };\n        return function(abort_reason) {\n            callback(false, abort_reason);\n        };\n    };\n};\n//         [*] End of lib/trans-sender.js\n\n\n//         [*] Including lib/trans-jsonp-receiver.js\n/*\n * ***** BEGIN LICENSE BLOCK *****\n * Copyright (c) 2011-2012 VMware, Inc.\n *\n * For the license see COPYING.\n * ***** END LICENSE BLOCK *****\n */\n\n// Parts derived from Socket.io:\n//    https://github.com/LearnBoost/socket.io/blob/0.6.17/lib/socket.io/transports/jsonp-polling.js\n// and jQuery-JSONP:\n//    https://code.google.com/p/jquery-jsonp/source/browse/trunk/core/jquery.jsonp.js\nvar jsonPGenericReceiver = function(url, callback) {\n    var tref;\n    var script = _document.createElement('script');\n    var script2;  // Opera synchronous load trick.\n    var close_script = function(frame) {\n        if (script2) {\n            script2.parentNode.removeChild(script2);\n            script2 = null;\n        }\n        if (script) {\n            clearTimeout(tref);\n            // Unfortunately, you can't really abort script loading of\n            // the script.\n            script.parentNode.removeChild(script);\n            script.onreadystatechange = script.onerror =\n                script.onload = script.onclick = null;\n            script = null;\n            callback(frame);\n            callback = null;\n        }\n    };\n\n    // IE9 fires 'error' event after orsc or before, in random order.\n    var loaded_okay = false;\n    var error_timer = null;\n\n    script.id = 'a' + utils.random_string(8);\n    script.src = url;\n    script.type = 'text/javascript';\n    script.charset = 'UTF-8';\n    script.onerror = function(e) {\n        if (!error_timer) {\n            // Delay firing close_script.\n            error_timer = setTimeout(function() {\n                if (!loaded_okay) {\n                    close_script(utils.closeFrame(\n                        1006,\n                        \"JSONP script loaded abnormally (onerror)\"));\n                }\n            }, 1000);\n        }\n    };\n    script.onload = function(e) {\n        close_script(utils.closeFrame(1006, \"JSONP script loaded abnormally (onload)\"));\n    };\n\n    script.onreadystatechange = function(e) {\n        if (/loaded|closed/.test(script.readyState)) {\n            if (script && script.htmlFor && script.onclick) {\n                loaded_okay = true;\n                try {\n                    // In IE, actually execute the script.\n                    script.onclick();\n                } catch (x) {}\n            }\n            if (script) {\n                close_script(utils.closeFrame(1006, \"JSONP script loaded abnormally (onreadystatechange)\"));\n            }\n        }\n    };\n    // IE: event/htmlFor/onclick trick.\n    // One can't rely on proper order for onreadystatechange. In order to\n    // make sure, set a 'htmlFor' and 'event' properties, so that\n    // script code will be installed as 'onclick' handler for the\n    // script object. Later, onreadystatechange, manually execute this\n    // code. FF and Chrome doesn't work with 'event' and 'htmlFor'\n    // set. For reference see:\n    //   http://jaubourg.net/2010/07/loading-script-as-onclick-handler-of.html\n    // Also, read on that about script ordering:\n    //   http://wiki.whatwg.org/wiki/Dynamic_Script_Execution_Order\n    if (typeof script.async === 'undefined' && _document.attachEvent) {\n        // According to mozilla docs, in recent browsers script.async defaults\n        // to 'true', so we may use it to detect a good browser:\n        // https://developer.mozilla.org/en/HTML/Element/script\n        if (!/opera/i.test(navigator.userAgent)) {\n            // Naively assume we're in IE\n            try {\n                script.htmlFor = script.id;\n                script.event = \"onclick\";\n            } catch (x) {}\n            script.async = true;\n        } else {\n            // Opera, second sync script hack\n            script2 = _document.createElement('script');\n            script2.text = \"try{var a = document.getElementById('\"+script.id+\"'); if(a)a.onerror();}catch(x){};\";\n            script.async = script2.async = false;\n        }\n    }\n    if (typeof script.async !== 'undefined') {\n        script.async = true;\n    }\n\n    // Fallback mostly for Konqueror - stupid timer, 35 seconds shall be plenty.\n    tref = setTimeout(function() {\n                          close_script(utils.closeFrame(1006, \"JSONP script loaded abnormally (timeout)\"));\n                      }, 35000);\n\n    var head = _document.getElementsByTagName('head')[0];\n    head.insertBefore(script, head.firstChild);\n    if (script2) {\n        head.insertBefore(script2, head.firstChild);\n    }\n    return close_script;\n};\n//         [*] End of lib/trans-jsonp-receiver.js\n\n\n//         [*] Including lib/trans-jsonp-polling.js\n/*\n * ***** BEGIN LICENSE BLOCK *****\n * Copyright (c) 2011-2012 VMware, Inc.\n *\n * For the license see COPYING.\n * ***** END LICENSE BLOCK *****\n */\n\n// The simplest and most robust transport, using the well-know cross\n// domain hack - JSONP. This transport is quite inefficient - one\n// mssage could use up to one http request. But at least it works almost\n// everywhere.\n// Known limitations:\n//   o you will get a spinning cursor\n//   o for Konqueror a dumb timer is needed to detect errors\n\n\nvar JsonPTransport = SockJS['jsonp-polling'] = function(ri, trans_url) {\n    utils.polluteGlobalNamespace();\n    var that = this;\n    that.ri = ri;\n    that.trans_url = trans_url;\n    that.send_constructor(jsonPGenericSender);\n    that._schedule_recv();\n};\n\n// Inheritnace\nJsonPTransport.prototype = new BufferedSender();\n\nJsonPTransport.prototype._schedule_recv = function() {\n    var that = this;\n    var callback = function(data) {\n        that._recv_stop = null;\n        if (data) {\n            // no data - heartbeat;\n            if (!that._is_closing) {\n                that.ri._didMessage(data);\n            }\n        }\n        // The message can be a close message, and change is_closing state.\n        if (!that._is_closing) {\n            that._schedule_recv();\n        }\n    };\n    that._recv_stop = jsonPReceiverWrapper(that.trans_url + '/jsonp',\n                                           jsonPGenericReceiver, callback);\n};\n\nJsonPTransport.enabled = function() {\n    return true;\n};\n\nJsonPTransport.need_body = true;\n\n\nJsonPTransport.prototype.doCleanup = function() {\n    var that = this;\n    that._is_closing = true;\n    if (that._recv_stop) {\n        that._recv_stop();\n    }\n    that.ri = that._recv_stop = null;\n    that.send_destructor();\n};\n\n\n// Abstract away code that handles global namespace pollution.\nvar jsonPReceiverWrapper = function(url, constructReceiver, user_callback) {\n    var id = 'a' + utils.random_string(6);\n    var url_id = url + '?c=' + escape(WPrefix + '.' + id);\n\n    // Unfortunately it is not possible to abort loading of the\n    // script. We need to keep track of frake close frames.\n    var aborting = 0;\n\n    // Callback will be called exactly once.\n    var callback = function(frame) {\n        switch(aborting) {\n        case 0:\n            // Normal behaviour - delete hook _and_ emit message.\n            delete _window[WPrefix][id];\n            user_callback(frame);\n            break;\n        case 1:\n            // Fake close frame - emit but don't delete hook.\n            user_callback(frame);\n            aborting = 2;\n            break;\n        case 2:\n            // Got frame after connection was closed, delete hook, don't emit.\n            delete _window[WPrefix][id];\n            break;\n        }\n    };\n\n    var close_script = constructReceiver(url_id, callback);\n    _window[WPrefix][id] = close_script;\n    var stop = function() {\n        if (_window[WPrefix][id]) {\n            aborting = 1;\n            _window[WPrefix][id](utils.closeFrame(1000, \"JSONP user aborted read\"));\n        }\n    };\n    return stop;\n};\n//         [*] End of lib/trans-jsonp-polling.js\n\n\n//         [*] Including lib/trans-xhr.js\n/*\n * ***** BEGIN LICENSE BLOCK *****\n * Copyright (c) 2011-2012 VMware, Inc.\n *\n * For the license see COPYING.\n * ***** END LICENSE BLOCK *****\n */\n\nvar AjaxBasedTransport = function() {};\nAjaxBasedTransport.prototype = new BufferedSender();\n\nAjaxBasedTransport.prototype.run = function(ri, trans_url,\n                                            url_suffix, Receiver, AjaxObject) {\n    var that = this;\n    that.ri = ri;\n    that.trans_url = trans_url;\n    that.send_constructor(createAjaxSender(AjaxObject));\n    that.poll = new Polling(ri, Receiver,\n                            trans_url + url_suffix, AjaxObject);\n};\n\nAjaxBasedTransport.prototype.doCleanup = function() {\n    var that = this;\n    if (that.poll) {\n        that.poll.abort();\n        that.poll = null;\n    }\n};\n\n// xhr-streaming\nvar XhrStreamingTransport = SockJS['xhr-streaming'] = function(ri, trans_url) {\n    this.run(ri, trans_url, '/xhr_streaming', XhrReceiver, utils.XHRCorsObject);\n};\n\nXhrStreamingTransport.prototype = new AjaxBasedTransport();\n\nXhrStreamingTransport.enabled = function() {\n    // Support for CORS Ajax aka Ajax2? Opera 12 claims CORS but\n    // doesn't do streaming.\n    return (_window.XMLHttpRequest &&\n            'withCredentials' in new XMLHttpRequest() &&\n            (!/opera/i.test(navigator.userAgent)));\n};\nXhrStreamingTransport.roundTrips = 2; // preflight, ajax\n\n// Safari gets confused when a streaming ajax request is started\n// before onload. This causes the load indicator to spin indefinetely.\nXhrStreamingTransport.need_body = true;\n\n\n// According to:\n//   http://stackoverflow.com/questions/1641507/detect-browser-support-for-cross-domain-xmlhttprequests\n//   http://hacks.mozilla.org/2009/07/cross-site-xmlhttprequest-with-cors/\n\n\n// xdr-streaming\nvar XdrStreamingTransport = SockJS['xdr-streaming'] = function(ri, trans_url) {\n    this.run(ri, trans_url, '/xhr_streaming', XhrReceiver, utils.XDRObject);\n};\n\nXdrStreamingTransport.prototype = new AjaxBasedTransport();\n\nXdrStreamingTransport.enabled = function() {\n    return !!_window.XDomainRequest;\n};\nXdrStreamingTransport.roundTrips = 2; // preflight, ajax\n\n\n\n// xhr-polling\nvar XhrPollingTransport = SockJS['xhr-polling'] = function(ri, trans_url) {\n    this.run(ri, trans_url, '/xhr', XhrReceiver, utils.XHRCorsObject);\n};\n\nXhrPollingTransport.prototype = new AjaxBasedTransport();\n\nXhrPollingTransport.enabled = XhrStreamingTransport.enabled;\nXhrPollingTransport.roundTrips = 2; // preflight, ajax\n\n\n// xdr-polling\nvar XdrPollingTransport = SockJS['xdr-polling'] = function(ri, trans_url) {\n    this.run(ri, trans_url, '/xhr', XhrReceiver, utils.XDRObject);\n};\n\nXdrPollingTransport.prototype = new AjaxBasedTransport();\n\nXdrPollingTransport.enabled = XdrStreamingTransport.enabled;\nXdrPollingTransport.roundTrips = 2; // preflight, ajax\n//         [*] End of lib/trans-xhr.js\n\n\n//         [*] Including lib/trans-iframe.js\n/*\n * ***** BEGIN LICENSE BLOCK *****\n * Copyright (c) 2011-2012 VMware, Inc.\n *\n * For the license see COPYING.\n * ***** END LICENSE BLOCK *****\n */\n\n// Few cool transports do work only for same-origin. In order to make\n// them working cross-domain we shall use iframe, served form the\n// remote domain. New browsers, have capabilities to communicate with\n// cross domain iframe, using postMessage(). In IE it was implemented\n// from IE 8+, but of course, IE got some details wrong:\n//    http://msdn.microsoft.com/en-us/library/cc197015(v=VS.85).aspx\n//    http://stevesouders.com/misc/test-postmessage.php\n\nvar IframeTransport = function() {};\n\nIframeTransport.prototype.i_constructor = function(ri, trans_url, base_url) {\n    var that = this;\n    that.ri = ri;\n    that.origin = utils.getOrigin(base_url);\n    that.base_url = base_url;\n    that.trans_url = trans_url;\n\n    var iframe_url = base_url + '/iframe.html';\n    if (that.ri._options.devel) {\n        iframe_url += '?t=' + (+new Date);\n    }\n    that.window_id = utils.random_string(8);\n    iframe_url += '#' + that.window_id;\n\n    that.iframeObj = utils.createIframe(iframe_url, function(r) {\n                                            that.ri._didClose(1006, \"Unable to load an iframe (\" + r + \")\");\n                                        });\n\n    that.onmessage_cb = utils.bind(that.onmessage, that);\n    utils.attachMessage(that.onmessage_cb);\n};\n\nIframeTransport.prototype.doCleanup = function() {\n    var that = this;\n    if (that.iframeObj) {\n        utils.detachMessage(that.onmessage_cb);\n        try {\n            // When the iframe is not loaded, IE raises an exception\n            // on 'contentWindow'.\n            if (that.iframeObj.iframe.contentWindow) {\n                that.postMessage('c');\n            }\n        } catch (x) {}\n        that.iframeObj.cleanup();\n        that.iframeObj = null;\n        that.onmessage_cb = that.iframeObj = null;\n    }\n};\n\nIframeTransport.prototype.onmessage = function(e) {\n    var that = this;\n    if (e.origin !== that.origin) return;\n    var window_id = e.data.slice(0, 8);\n    var type = e.data.slice(8, 9);\n    var data = e.data.slice(9);\n\n    if (window_id !== that.window_id) return;\n\n    switch(type) {\n    case 's':\n        that.iframeObj.loaded();\n        that.postMessage('s', JSON.stringify([SockJS.version, that.protocol, that.trans_url, that.base_url]));\n        break;\n    case 't':\n        that.ri._didMessage(data);\n        break;\n    }\n};\n\nIframeTransport.prototype.postMessage = function(type, data) {\n    var that = this;\n    that.iframeObj.post(that.window_id + type + (data || ''), that.origin);\n};\n\nIframeTransport.prototype.doSend = function (message) {\n    this.postMessage('m', message);\n};\n\nIframeTransport.enabled = function() {\n    // postMessage misbehaves in konqueror 4.6.5 - the messages are delivered with\n    // huge delay, or not at all.\n    var konqueror = navigator && navigator.userAgent && navigator.userAgent.indexOf('Konqueror') !== -1;\n    return ((typeof _window.postMessage === 'function' ||\n            typeof _window.postMessage === 'object') && (!konqueror));\n};\n//         [*] End of lib/trans-iframe.js\n\n\n//         [*] Including lib/trans-iframe-within.js\n/*\n * ***** BEGIN LICENSE BLOCK *****\n * Copyright (c) 2011-2012 VMware, Inc.\n *\n * For the license see COPYING.\n * ***** END LICENSE BLOCK *****\n */\n\nvar curr_window_id;\n\nvar postMessage = function (type, data) {\n    if(parent !== _window) {\n        parent.postMessage(curr_window_id + type + (data || ''), '*');\n    } else {\n        utils.log(\"Can't postMessage, no parent window.\", type, data);\n    }\n};\n\nvar FacadeJS = function() {};\nFacadeJS.prototype._didClose = function (code, reason) {\n    postMessage('t', utils.closeFrame(code, reason));\n};\nFacadeJS.prototype._didMessage = function (frame) {\n    postMessage('t', frame);\n};\nFacadeJS.prototype._doSend = function (data) {\n    this._transport.doSend(data);\n};\nFacadeJS.prototype._doCleanup = function () {\n    this._transport.doCleanup();\n};\n\nutils.parent_origin = undefined;\n\nSockJS.bootstrap_iframe = function() {\n    var facade;\n    curr_window_id = _document.location.hash.slice(1);\n    var onMessage = function(e) {\n        if(e.source !== parent) return;\n        if(typeof utils.parent_origin === 'undefined')\n            utils.parent_origin = e.origin;\n        if (e.origin !== utils.parent_origin) return;\n\n        var window_id = e.data.slice(0, 8);\n        var type = e.data.slice(8, 9);\n        var data = e.data.slice(9);\n        if (window_id !== curr_window_id) return;\n        switch(type) {\n        case 's':\n            var p = JSON.parse(data);\n            var version = p[0];\n            var protocol = p[1];\n            var trans_url = p[2];\n            var base_url = p[3];\n            if (version !== SockJS.version) {\n                utils.log(\"Incompatibile SockJS! Main site uses:\" +\n                          \" \\\"\" + version + \"\\\", the iframe:\" +\n                          \" \\\"\" + SockJS.version + \"\\\".\");\n            }\n            if (!utils.flatUrl(trans_url) || !utils.flatUrl(base_url)) {\n                utils.log(\"Only basic urls are supported in SockJS\");\n                return;\n            }\n\n            if (!utils.isSameOriginUrl(trans_url) ||\n                !utils.isSameOriginUrl(base_url)) {\n                utils.log(\"Can't connect to different domain from within an \" +\n                          \"iframe. (\" + JSON.stringify([_window.location.href, trans_url, base_url]) +\n                          \")\");\n                return;\n            }\n            facade = new FacadeJS();\n            facade._transport = new FacadeJS[protocol](facade, trans_url, base_url);\n            break;\n        case 'm':\n            facade._doSend(data);\n            break;\n        case 'c':\n            if (facade)\n                facade._doCleanup();\n            facade = null;\n            break;\n        }\n    };\n\n    // alert('test ticker');\n    // facade = new FacadeJS();\n    // facade._transport = new FacadeJS['w-iframe-xhr-polling'](facade, 'http://host.com:9999/ticker/12/basd');\n\n    utils.attachMessage(onMessage);\n\n    // Start\n    postMessage('s');\n};\n//         [*] End of lib/trans-iframe-within.js\n\n\n//         [*] Including lib/info.js\n/*\n * ***** BEGIN LICENSE BLOCK *****\n * Copyright (c) 2011-2012 VMware, Inc.\n *\n * For the license see COPYING.\n * ***** END LICENSE BLOCK *****\n */\n\nvar InfoReceiver = function(base_url, AjaxObject) {\n    var that = this;\n    utils.delay(function(){that.doXhr(base_url, AjaxObject);});\n};\n\nInfoReceiver.prototype = new EventEmitter(['finish']);\n\nInfoReceiver.prototype.doXhr = function(base_url, AjaxObject) {\n    var that = this;\n    var t0 = (new Date()).getTime();\n\n// <METEOR>\n  // https://github.com/sockjs/sockjs-client/pull/129\n  // var xo = new AjaxObject('GET', base_url + '/info');\n\n    var xo = new AjaxObject(\n      // add cachebusting parameter to url to work around a chrome bug:\n      // https://code.google.com/p/chromium/issues/detail?id=263981\n      // or misbehaving proxies.\n      'GET', base_url + '/info?cb=' + utils.random_string(10))\n// </METEOR>\n\n    var tref = utils.delay(8000,\n                           function(){xo.ontimeout();});\n\n    xo.onfinish = function(status, text) {\n        clearTimeout(tref);\n        tref = null;\n        if (status === 200) {\n            var rtt = (new Date()).getTime() - t0;\n            var info = JSON.parse(text);\n            if (typeof info !== 'object') info = {};\n            that.emit('finish', info, rtt);\n        } else {\n            that.emit('finish');\n        }\n    };\n    xo.ontimeout = function() {\n        xo.close();\n        that.emit('finish');\n    };\n};\n\nvar InfoReceiverIframe = function(base_url) {\n    var that = this;\n    var go = function() {\n        var ifr = new IframeTransport();\n        ifr.protocol = 'w-iframe-info-receiver';\n        var fun = function(r) {\n            if (typeof r === 'string' && r.substr(0,1) === 'm') {\n                var d = JSON.parse(r.substr(1));\n                var info = d[0], rtt = d[1];\n                that.emit('finish', info, rtt);\n            } else {\n                that.emit('finish');\n            }\n            ifr.doCleanup();\n            ifr = null;\n        };\n        var mock_ri = {\n            _options: {},\n            _didClose: fun,\n            _didMessage: fun\n        };\n        ifr.i_constructor(mock_ri, base_url, base_url);\n    }\n    if(!_document.body) {\n        utils.attachEvent('load', go);\n    } else {\n        go();\n    }\n};\nInfoReceiverIframe.prototype = new EventEmitter(['finish']);\n\n\nvar InfoReceiverFake = function() {\n    // It may not be possible to do cross domain AJAX to get the info\n    // data, for example for IE7. But we want to run JSONP, so let's\n    // fake the response, with rtt=2s (rto=6s).\n    var that = this;\n    utils.delay(function() {\n        that.emit('finish', {}, 2000);\n    });\n};\nInfoReceiverFake.prototype = new EventEmitter(['finish']);\n\nvar createInfoReceiver = function(base_url) {\n    if (utils.isSameOriginUrl(base_url)) {\n        // If, for some reason, we have SockJS locally - there's no\n        // need to start up the complex machinery. Just use ajax.\n        return new InfoReceiver(base_url, utils.XHRLocalObject);\n    }\n    switch (utils.isXHRCorsCapable()) {\n    case 1:\n        // XHRLocalObject -> no_credentials=true\n        return new InfoReceiver(base_url, utils.XHRLocalObject);\n    case 2:\n// <METEOR>\n// https://github.com/sockjs/sockjs-client/issues/79\n        // XDR doesn't work across different schemes\n        // http://blogs.msdn.com/b/ieinternals/archive/2010/05/13/xdomainrequest-restrictions-limitations-and-workarounds.aspx\n        if (utils.isSameOriginScheme(base_url))\n            return new InfoReceiver(base_url, utils.XDRObject);\n        else\n            return new InfoReceiverFake();\n// </METEOR>\n    case 3:\n        // Opera\n        return new InfoReceiverIframe(base_url);\n    default:\n        // IE 7\n        return new InfoReceiverFake();\n    };\n};\n\n\nvar WInfoReceiverIframe = FacadeJS['w-iframe-info-receiver'] = function(ri, _trans_url, base_url) {\n    var ir = new InfoReceiver(base_url, utils.XHRLocalObject);\n    ir.onfinish = function(info, rtt) {\n        ri._didMessage('m'+JSON.stringify([info, rtt]));\n        ri._didClose();\n    }\n};\nWInfoReceiverIframe.prototype.doCleanup = function() {};\n//         [*] End of lib/info.js\n\n\n//         [*] Including lib/trans-iframe-eventsource.js\n/*\n * ***** BEGIN LICENSE BLOCK *****\n * Copyright (c) 2011-2012 VMware, Inc.\n *\n * For the license see COPYING.\n * ***** END LICENSE BLOCK *****\n */\n\nvar EventSourceIframeTransport = SockJS['iframe-eventsource'] = function () {\n    var that = this;\n    that.protocol = 'w-iframe-eventsource';\n    that.i_constructor.apply(that, arguments);\n};\n\nEventSourceIframeTransport.prototype = new IframeTransport();\n\nEventSourceIframeTransport.enabled = function () {\n    return ('EventSource' in _window) && IframeTransport.enabled();\n};\n\nEventSourceIframeTransport.need_body = true;\nEventSourceIframeTransport.roundTrips = 3; // html, javascript, eventsource\n\n\n// w-iframe-eventsource\nvar EventSourceTransport = FacadeJS['w-iframe-eventsource'] = function(ri, trans_url) {\n    this.run(ri, trans_url, '/eventsource', EventSourceReceiver, utils.XHRLocalObject);\n}\nEventSourceTransport.prototype = new AjaxBasedTransport();\n//         [*] End of lib/trans-iframe-eventsource.js\n\n\n//         [*] Including lib/trans-iframe-xhr-polling.js\n/*\n * ***** BEGIN LICENSE BLOCK *****\n * Copyright (c) 2011-2012 VMware, Inc.\n *\n * For the license see COPYING.\n * ***** END LICENSE BLOCK *****\n */\n\nvar XhrPollingIframeTransport = SockJS['iframe-xhr-polling'] = function () {\n    var that = this;\n    that.protocol = 'w-iframe-xhr-polling';\n    that.i_constructor.apply(that, arguments);\n};\n\nXhrPollingIframeTransport.prototype = new IframeTransport();\n\nXhrPollingIframeTransport.enabled = function () {\n    return _window.XMLHttpRequest && IframeTransport.enabled();\n};\n\nXhrPollingIframeTransport.need_body = true;\nXhrPollingIframeTransport.roundTrips = 3; // html, javascript, xhr\n\n\n// w-iframe-xhr-polling\nvar XhrPollingITransport = FacadeJS['w-iframe-xhr-polling'] = function(ri, trans_url) {\n    this.run(ri, trans_url, '/xhr', XhrReceiver, utils.XHRLocalObject);\n};\n\nXhrPollingITransport.prototype = new AjaxBasedTransport();\n//         [*] End of lib/trans-iframe-xhr-polling.js\n\n\n//         [*] Including lib/trans-iframe-htmlfile.js\n/*\n * ***** BEGIN LICENSE BLOCK *****\n * Copyright (c) 2011-2012 VMware, Inc.\n *\n * For the license see COPYING.\n * ***** END LICENSE BLOCK *****\n */\n\n// This transport generally works in any browser, but will cause a\n// spinning cursor to appear in any browser other than IE.\n// We may test this transport in all browsers - why not, but in\n// production it should be only run in IE.\n\nvar HtmlFileIframeTransport = SockJS['iframe-htmlfile'] = function () {\n    var that = this;\n    that.protocol = 'w-iframe-htmlfile';\n    that.i_constructor.apply(that, arguments);\n};\n\n// Inheritance.\nHtmlFileIframeTransport.prototype = new IframeTransport();\n\nHtmlFileIframeTransport.enabled = function() {\n    return IframeTransport.enabled();\n};\n\nHtmlFileIframeTransport.need_body = true;\nHtmlFileIframeTransport.roundTrips = 3; // html, javascript, htmlfile\n\n\n// w-iframe-htmlfile\nvar HtmlFileTransport = FacadeJS['w-iframe-htmlfile'] = function(ri, trans_url) {\n    this.run(ri, trans_url, '/htmlfile', HtmlfileReceiver, utils.XHRLocalObject);\n};\nHtmlFileTransport.prototype = new AjaxBasedTransport();\n//         [*] End of lib/trans-iframe-htmlfile.js\n\n\n//         [*] Including lib/trans-polling.js\n/*\n * ***** BEGIN LICENSE BLOCK *****\n * Copyright (c) 2011-2012 VMware, Inc.\n *\n * For the license see COPYING.\n * ***** END LICENSE BLOCK *****\n */\n\nvar Polling = function(ri, Receiver, recv_url, AjaxObject) {\n    var that = this;\n    that.ri = ri;\n    that.Receiver = Receiver;\n    that.recv_url = recv_url;\n    that.AjaxObject = AjaxObject;\n    that._scheduleRecv();\n};\n\nPolling.prototype._scheduleRecv = function() {\n    var that = this;\n    var poll = that.poll = new that.Receiver(that.recv_url, that.AjaxObject);\n    var msg_counter = 0;\n    poll.onmessage = function(e) {\n        msg_counter += 1;\n        that.ri._didMessage(e.data);\n    };\n    poll.onclose = function(e) {\n        that.poll = poll = poll.onmessage = poll.onclose = null;\n        if (!that.poll_is_closing) {\n            if (e.reason === 'permanent') {\n                that.ri._didClose(1006, 'Polling error (' + e.reason + ')');\n            } else {\n                that._scheduleRecv();\n            }\n        }\n    };\n};\n\nPolling.prototype.abort = function() {\n    var that = this;\n    that.poll_is_closing = true;\n    if (that.poll) {\n        that.poll.abort();\n    }\n};\n//         [*] End of lib/trans-polling.js\n\n\n//         [*] Including lib/trans-receiver-eventsource.js\n/*\n * ***** BEGIN LICENSE BLOCK *****\n * Copyright (c) 2011-2012 VMware, Inc.\n *\n * For the license see COPYING.\n * ***** END LICENSE BLOCK *****\n */\n\nvar EventSourceReceiver = function(url) {\n    var that = this;\n    var es = new EventSource(url);\n    es.onmessage = function(e) {\n        that.dispatchEvent(new SimpleEvent('message',\n                                           {'data': unescape(e.data)}));\n    };\n    that.es_close = es.onerror = function(e, abort_reason) {\n        // ES on reconnection has readyState = 0 or 1.\n        // on network error it's CLOSED = 2\n        var reason = abort_reason ? 'user' :\n            (es.readyState !== 2 ? 'network' : 'permanent');\n        that.es_close = es.onmessage = es.onerror = null;\n        // EventSource reconnects automatically.\n        es.close();\n        es = null;\n        // Safari and chrome < 15 crash if we close window before\n        // waiting for ES cleanup. See:\n        //   https://code.google.com/p/chromium/issues/detail?id=89155\n        utils.delay(200, function() {\n                        that.dispatchEvent(new SimpleEvent('close', {reason: reason}));\n                    });\n    };\n};\n\nEventSourceReceiver.prototype = new REventTarget();\n\nEventSourceReceiver.prototype.abort = function() {\n    var that = this;\n    if (that.es_close) {\n        that.es_close({}, true);\n    }\n};\n//         [*] End of lib/trans-receiver-eventsource.js\n\n\n//         [*] Including lib/trans-receiver-htmlfile.js\n/*\n * ***** BEGIN LICENSE BLOCK *****\n * Copyright (c) 2011-2012 VMware, Inc.\n *\n * For the license see COPYING.\n * ***** END LICENSE BLOCK *****\n */\n\nvar _is_ie_htmlfile_capable;\nvar isIeHtmlfileCapable = function() {\n    if (_is_ie_htmlfile_capable === undefined) {\n        if ('ActiveXObject' in _window) {\n            try {\n                _is_ie_htmlfile_capable = !!new ActiveXObject('htmlfile');\n            } catch (x) {}\n        } else {\n            _is_ie_htmlfile_capable = false;\n        }\n    }\n    return _is_ie_htmlfile_capable;\n};\n\n\nvar HtmlfileReceiver = function(url) {\n    var that = this;\n    utils.polluteGlobalNamespace();\n\n    that.id = 'a' + utils.random_string(6, 26);\n    url += ((url.indexOf('?') === -1) ? '?' : '&') +\n        'c=' + escape(WPrefix + '.' + that.id);\n\n    var constructor = isIeHtmlfileCapable() ?\n        utils.createHtmlfile : utils.createIframe;\n\n    var iframeObj;\n    _window[WPrefix][that.id] = {\n        start: function () {\n            iframeObj.loaded();\n        },\n        message: function (data) {\n            that.dispatchEvent(new SimpleEvent('message', {'data': data}));\n        },\n        stop: function () {\n            that.iframe_close({}, 'network');\n        }\n    };\n    that.iframe_close = function(e, abort_reason) {\n        iframeObj.cleanup();\n        that.iframe_close = iframeObj = null;\n        delete _window[WPrefix][that.id];\n        that.dispatchEvent(new SimpleEvent('close', {reason: abort_reason}));\n    };\n    iframeObj = constructor(url, function(e) {\n                                that.iframe_close({}, 'permanent');\n                            });\n};\n\nHtmlfileReceiver.prototype = new REventTarget();\n\nHtmlfileReceiver.prototype.abort = function() {\n    var that = this;\n    if (that.iframe_close) {\n        that.iframe_close({}, 'user');\n    }\n};\n//         [*] End of lib/trans-receiver-htmlfile.js\n\n\n//         [*] Including lib/trans-receiver-xhr.js\n/*\n * ***** BEGIN LICENSE BLOCK *****\n * Copyright (c) 2011-2012 VMware, Inc.\n *\n * For the license see COPYING.\n * ***** END LICENSE BLOCK *****\n */\n\nvar XhrReceiver = function(url, AjaxObject) {\n    var that = this;\n    var buf_pos = 0;\n\n    that.xo = new AjaxObject('POST', url, null);\n    that.xo.onchunk = function(status, text) {\n        if (status !== 200) return;\n        while (1) {\n            var buf = text.slice(buf_pos);\n            var p = buf.indexOf('\\n');\n            if (p === -1) break;\n            buf_pos += p+1;\n            var msg = buf.slice(0, p);\n            that.dispatchEvent(new SimpleEvent('message', {data: msg}));\n        }\n    };\n    that.xo.onfinish = function(status, text) {\n        that.xo.onchunk(status, text);\n        that.xo = null;\n        var reason = status === 200 ? 'network' : 'permanent';\n        that.dispatchEvent(new SimpleEvent('close', {reason: reason}));\n    }\n};\n\nXhrReceiver.prototype = new REventTarget();\n\nXhrReceiver.prototype.abort = function() {\n    var that = this;\n    if (that.xo) {\n        that.xo.close();\n        that.dispatchEvent(new SimpleEvent('close', {reason: 'user'}));\n        that.xo = null;\n    }\n};\n//         [*] End of lib/trans-receiver-xhr.js\n\n\n//         [*] Including lib/test-hooks.js\n/*\n * ***** BEGIN LICENSE BLOCK *****\n * Copyright (c) 2011-2012 VMware, Inc.\n *\n * For the license see COPYING.\n * ***** END LICENSE BLOCK *****\n */\n\n// For testing\nSockJS.getUtils = function(){\n    return utils;\n};\n\nSockJS.getIframeTransport = function(){\n    return IframeTransport;\n};\n//         [*] End of lib/test-hooks.js\n\n                  return SockJS;\n          })();\nif ('_sockjs_onload' in window) setTimeout(_sockjs_onload, 1);\n\n// AMD compliance\nif (typeof define === 'function' && define.amd) {\n    define('sockjs', [], function(){return SockJS;});\n}\n//     [*] End of lib/index.js\n\n// [*] End of lib/all.js\n","// @param url {String} URL to Meteor app\n//   \"http://subdomain.meteor.com/\" or \"/\" or\n//   \"ddp+sockjs://foo-**.meteor.com/sockjs\"\nLivedataTest.ClientStream = function (url, options) {\n  var self = this;\n  self.options = _.extend({\n    retry: true\n  }, options);\n  self._initCommon(self.options);\n\n  //// Constants\n\n\n  // how long between hearing heartbeat from the server until we declare\n  // the connection dead. heartbeats come every 45s (stream_server.js)\n  //\n  // NOTE: this is a older timeout mechanism. We now send heartbeats at\n  // the DDP level (https://github.com/meteor/meteor/pull/1865), and\n  // expect those timeouts to kill a non-responsive connection before\n  // this timeout fires. This is kept around for compatibility (when\n  // talking to a server that doesn't support DDP heartbeats) and can be\n  // removed later.\n  self.HEARTBEAT_TIMEOUT = 100*1000;\n\n  self.rawUrl = url;\n  self.socket = null;\n\n  self.heartbeatTimer = null;\n\n  // Listen to global 'online' event if we are running in a browser.\n  // (IE8 does not support addEventListener)\n  if (typeof window !== 'undefined' && window.addEventListener)\n    window.addEventListener(\"online\", _.bind(self._online, self),\n                            false /* useCapture. make FF3.6 happy. */);\n\n  //// Kickoff!\n  self._launchConnection();\n};\n\n_.extend(LivedataTest.ClientStream.prototype, {\n\n  // data is a utf8 string. Data sent while not connected is dropped on\n  // the floor, and it is up the user of this API to retransmit lost\n  // messages on 'reset'\n  send: function (data) {\n    var self = this;\n    if (self.currentStatus.connected) {\n      self.socket.send(data);\n    }\n  },\n\n  // Changes where this connection points\n  _changeUrl: function (url) {\n    var self = this;\n    self.rawUrl = url;\n  },\n\n  _connected: function () {\n    var self = this;\n\n    if (self.connectionTimer) {\n      clearTimeout(self.connectionTimer);\n      self.connectionTimer = null;\n    }\n\n    if (self.currentStatus.connected) {\n      // already connected. do nothing. this probably shouldn't happen.\n      return;\n    }\n\n    // update status\n    self.currentStatus.status = \"connected\";\n    self.currentStatus.connected = true;\n    self.currentStatus.retryCount = 0;\n    self.statusChanged();\n\n    // fire resets. This must come after status change so that clients\n    // can call send from within a reset callback.\n    _.each(self.eventCallbacks.reset, function (callback) { callback(); });\n\n  },\n\n  _cleanup: function (maybeError) {\n    var self = this;\n\n    self._clearConnectionAndHeartbeatTimers();\n    if (self.socket) {\n      self.socket.onmessage = self.socket.onclose\n        = self.socket.onerror = self.socket.onheartbeat = function () {};\n      self.socket.close();\n      self.socket = null;\n    }\n\n    _.each(self.eventCallbacks.disconnect, function (callback) {\n      callback(maybeError);\n    });\n  },\n\n  _clearConnectionAndHeartbeatTimers: function () {\n    var self = this;\n    if (self.connectionTimer) {\n      clearTimeout(self.connectionTimer);\n      self.connectionTimer = null;\n    }\n    if (self.heartbeatTimer) {\n      clearTimeout(self.heartbeatTimer);\n      self.heartbeatTimer = null;\n    }\n  },\n\n  _heartbeat_timeout: function () {\n    var self = this;\n    Meteor._debug(\"Connection timeout. No sockjs heartbeat received.\");\n    self._lostConnection(new DDP.ConnectionError(\"Heartbeat timed out\"));\n  },\n\n  _heartbeat_received: function () {\n    var self = this;\n    // If we've already permanently shut down this stream, the timeout is\n    // already cleared, and we don't need to set it again.\n    if (self._forcedToDisconnect)\n      return;\n    if (self.heartbeatTimer)\n      clearTimeout(self.heartbeatTimer);\n    self.heartbeatTimer = setTimeout(\n      _.bind(self._heartbeat_timeout, self),\n      self.HEARTBEAT_TIMEOUT);\n  },\n\n  _sockjsProtocolsWhitelist: function () {\n    // only allow polling protocols. no streaming.  streaming\n    // makes safari spin.\n    var protocolsWhitelist = [\n      'xdr-polling', 'xhr-polling', 'iframe-xhr-polling', 'jsonp-polling'];\n\n    // iOS 4 and 5 and below crash when using websockets over certain\n    // proxies. this seems to be resolved with iOS 6. eg\n    // https://github.com/LearnBoost/socket.io/issues/193#issuecomment-7308865.\n    //\n    // iOS <4 doesn't support websockets at all so sockjs will just\n    // immediately fall back to http\n    var noWebsockets = navigator &&\n          /iPhone|iPad|iPod/.test(navigator.userAgent) &&\n          /OS 4_|OS 5_/.test(navigator.userAgent);\n\n    if (!noWebsockets)\n      protocolsWhitelist = ['websocket'].concat(protocolsWhitelist);\n\n    return protocolsWhitelist;\n  },\n\n  _launchConnection: function () {\n    var self = this;\n    self._cleanup(); // cleanup the old socket, if there was one.\n\n    var options = _.extend({\n      protocols_whitelist:self._sockjsProtocolsWhitelist()\n    }, self.options._sockjsOptions);\n\n    // Convert raw URL to SockJS URL each time we open a connection, so that we\n    // can connect to random hostnames and get around browser per-host\n    // connection limits.\n    self.socket = new SockJS(toSockjsUrl(self.rawUrl), undefined, options);\n    self.socket.onopen = function (data) {\n      self._connected();\n    };\n    self.socket.onmessage = function (data) {\n      self._heartbeat_received();\n\n      if (self.currentStatus.connected)\n        _.each(self.eventCallbacks.message, function (callback) {\n          callback(data.data);\n        });\n    };\n    self.socket.onclose = function () {\n      self._lostConnection();\n    };\n    self.socket.onerror = function () {\n      // XXX is this ever called?\n      Meteor._debug(\"stream error\", _.toArray(arguments), (new Date()).toDateString());\n    };\n\n    self.socket.onheartbeat =  function () {\n      self._heartbeat_received();\n    };\n\n    if (self.connectionTimer)\n      clearTimeout(self.connectionTimer);\n    self.connectionTimer = setTimeout(function () {\n      self._lostConnection(\n        new DDP.ConnectionError(\"DDP connection timed out\"));\n    }, self.CONNECT_TIMEOUT);\n  }\n});\n","// XXX from Underscore.String (http://epeli.github.com/underscore.string/)\nvar startsWith = function(str, starts) {\n  return str.length >= starts.length &&\n    str.substring(0, starts.length) === starts;\n};\nvar endsWith = function(str, ends) {\n  return str.length >= ends.length &&\n    str.substring(str.length - ends.length) === ends;\n};\n\n// @param url {String} URL to Meteor app, eg:\n//   \"/\" or \"madewith.meteor.com\" or \"https://foo.meteor.com\"\n//   or \"ddp+sockjs://ddp--****-foo.meteor.com/sockjs\"\n// @returns {String} URL to the endpoint with the specific scheme and subPath, e.g.\n// for scheme \"http\" and subPath \"sockjs\"\n//   \"http://subdomain.meteor.com/sockjs\" or \"/sockjs\"\n//   or \"https://ddp--1234-foo.meteor.com/sockjs\"\nvar translateUrl =  function(url, newSchemeBase, subPath) {\n  if (! newSchemeBase) {\n    newSchemeBase = \"http\";\n  }\n\n  var ddpUrlMatch = url.match(/^ddp(i?)\\+sockjs:\\/\\//);\n  var httpUrlMatch = url.match(/^http(s?):\\/\\//);\n  var newScheme;\n  if (ddpUrlMatch) {\n    // Remove scheme and split off the host.\n    var urlAfterDDP = url.substr(ddpUrlMatch[0].length);\n    newScheme = ddpUrlMatch[1] === \"i\" ? newSchemeBase : newSchemeBase + \"s\";\n    var slashPos = urlAfterDDP.indexOf('/');\n    var host =\n          slashPos === -1 ? urlAfterDDP : urlAfterDDP.substr(0, slashPos);\n    var rest = slashPos === -1 ? '' : urlAfterDDP.substr(slashPos);\n\n    // In the host (ONLY!), change '*' characters into random digits. This\n    // allows different stream connections to connect to different hostnames\n    // and avoid browser per-hostname connection limits.\n    host = host.replace(/\\*/g, function () {\n      return Math.floor(Random.fraction()*10);\n    });\n\n    return newScheme + '://' + host + rest;\n  } else if (httpUrlMatch) {\n    newScheme = !httpUrlMatch[1] ? newSchemeBase : newSchemeBase + \"s\";\n    var urlAfterHttp = url.substr(httpUrlMatch[0].length);\n    url = newScheme + \"://\" + urlAfterHttp;\n  }\n\n  // Prefix FQDNs but not relative URLs\n  if (url.indexOf(\"://\") === -1 && !startsWith(url, \"/\")) {\n    url = newSchemeBase + \"://\" + url;\n  }\n\n  // XXX This is not what we should be doing: if I have a site\n  // deployed at \"/foo\", then DDP.connect(\"/\") should actually connect\n  // to \"/\", not to \"/foo\". \"/\" is an absolute path. (Contrast: if\n  // deployed at \"/foo\", it would be reasonable for DDP.connect(\"bar\")\n  // to connect to \"/foo/bar\").\n  //\n  // We should make this properly honor absolute paths rather than\n  // forcing the path to be relative to the site root. Simultaneously,\n  // we should set DDP_DEFAULT_CONNECTION_URL to include the site\n  // root. See also client_convenience.js #RationalizingRelativeDDPURLs\n  url = Meteor._relativeToSiteRootUrl(url);\n\n  if (endsWith(url, \"/\"))\n    return url + subPath;\n  else\n    return url + \"/\" + subPath;\n};\n\ntoSockjsUrl = function (url) {\n  return translateUrl(url, \"http\", \"sockjs\");\n};\n\ntoWebsocketUrl = function (url) {\n  var ret = translateUrl(url, \"ws\", \"websocket\");\n  return ret;\n};\n\nLivedataTest.toSockjsUrl = toSockjsUrl;\n\n \n_.extend(LivedataTest.ClientStream.prototype, {\n\n  // Register for callbacks.\n  on: function (name, callback) {\n    var self = this;\n\n    if (name !== 'message' && name !== 'reset' && name !== 'disconnect')\n      throw new Error(\"unknown event type: \" + name);\n\n    if (!self.eventCallbacks[name])\n      self.eventCallbacks[name] = [];\n    self.eventCallbacks[name].push(callback);\n  },\n\n\n  _initCommon: function (options) {\n    var self = this;\n    options = options || {};\n\n    //// Constants\n\n    // how long to wait until we declare the connection attempt\n    // failed.\n    self.CONNECT_TIMEOUT = options.connectTimeoutMs || 10000;\n\n    self.eventCallbacks = {}; // name -> [callback]\n\n    self._forcedToDisconnect = false;\n\n    //// Reactive status\n    self.currentStatus = {\n      status: \"connecting\",\n      connected: false,\n      retryCount: 0\n    };\n\n\n    self.statusListeners = typeof Tracker !== 'undefined' && new Tracker.Dependency;\n    self.statusChanged = function () {\n      if (self.statusListeners)\n        self.statusListeners.changed();\n    };\n\n    //// Retry logic\n    self._retry = new Retry;\n    self.connectionTimer = null;\n\n  },\n\n  // Trigger a reconnect.\n  reconnect: function (options) {\n    var self = this;\n    options = options || {};\n\n    if (options.url) {\n      self._changeUrl(options.url);\n    }\n\n    if (options._sockjsOptions) {\n      self.options._sockjsOptions = options._sockjsOptions;\n    }\n\n    if (self.currentStatus.connected) {\n      if (options._force || options.url) {\n        // force reconnect.\n        self._lostConnection(new DDP.ForcedReconnectError);\n      } // else, noop.\n      return;\n    }\n\n    // if we're mid-connection, stop it.\n    if (self.currentStatus.status === \"connecting\") {\n      // Pretend it's a clean close.\n      self._lostConnection();\n    }\n\n    self._retry.clear();\n    self.currentStatus.retryCount -= 1; // don't count manual retries\n    self._retryNow();\n  },\n\n  disconnect: function (options) {\n    var self = this;\n    options = options || {};\n\n    // Failed is permanent. If we're failed, don't let people go back\n    // online by calling 'disconnect' then 'reconnect'.\n    if (self._forcedToDisconnect)\n      return;\n\n    // If _permanent is set, permanently disconnect a stream. Once a stream\n    // is forced to disconnect, it can never reconnect. This is for\n    // error cases such as ddp version mismatch, where trying again\n    // won't fix the problem.\n    if (options._permanent) {\n      self._forcedToDisconnect = true;\n    }\n\n    self._cleanup();\n    self._retry.clear();\n\n    self.currentStatus = {\n      status: (options._permanent ? \"failed\" : \"offline\"),\n      connected: false,\n      retryCount: 0\n    };\n\n    if (options._permanent && options._error)\n      self.currentStatus.reason = options._error;\n\n    self.statusChanged();\n  },\n\n  // maybeError is set unless it's a clean protocol-level close.\n  _lostConnection: function (maybeError) {\n    var self = this;\n\n    self._cleanup(maybeError);\n    self._retryLater(maybeError); // sets status. no need to do it here.\n  },\n\n  // fired when we detect that we've gone online. try to reconnect\n  // immediately.\n  _online: function () {\n    // if we've requested to be offline by disconnecting, don't reconnect.\n    if (this.currentStatus.status != \"offline\")\n      this.reconnect();\n  },\n\n  _retryLater: function (maybeError) {\n    var self = this;\n\n    var timeout = 0;\n    if (self.options.retry ||\n        (maybeError && maybeError.errorType === \"DDP.ForcedReconnectError\")) {\n      timeout = self._retry.retryLater(\n        self.currentStatus.retryCount,\n        _.bind(self._retryNow, self)\n      );\n      self.currentStatus.status = \"waiting\";\n      self.currentStatus.retryTime = (new Date()).getTime() + timeout;\n    } else {\n      self.currentStatus.status = \"failed\";\n      delete self.currentStatus.retryTime;\n    }\n\n    self.currentStatus.connected = false;\n    self.statusChanged();\n  },\n\n  _retryNow: function () {\n    var self = this;\n\n    if (self._forcedToDisconnect)\n      return;\n\n    self.currentStatus.retryCount += 1;\n    self.currentStatus.status = \"connecting\";\n    self.currentStatus.connected = false;\n    delete self.currentStatus.retryTime;\n    self.statusChanged();\n\n    self._launchConnection();\n  },\n\n\n  // Get current status. Reactive.\n  status: function () {\n    var self = this;\n    if (self.statusListeners)\n      self.statusListeners.depend();\n    return self.currentStatus;\n  }\n});\n\nDDP.ConnectionError = Meteor.makeErrorType(\n  \"DDP.ConnectionError\", function (message) {\n    var self = this;\n    self.message = message;\n});\n\nDDP.ForcedReconnectError = Meteor.makeErrorType(\n  \"DDP.ForcedReconnectError\", function () {});\n","LivedataTest.SUPPORTED_DDP_VERSIONS = DDPCommon.SUPPORTED_DDP_VERSIONS;\n\n// This is private but it's used in a few places. accounts-base uses\n// it to get the current user. Meteor.setTimeout and friends clear\n// it. We can probably find a better way to factor this.\nDDP._CurrentInvocation = new Meteor.EnvironmentVariable;\n","// Returns the named sequence of pseudo-random values.\n// The scope will be DDP._CurrentInvocation.get(), so the stream will produce\n// consistent values for method calls on the client and server.\nDDP.randomStream = function (name) {\n  var scope = DDP._CurrentInvocation.get();\n  return DDPCommon.RandomStream.get(scope, name);\n};\n\n\n","if (Meteor.isServer) {\n  var path = Npm.require('path');\n  var Fiber = Npm.require('fibers');\n  var Future = Npm.require(path.join('fibers', 'future'));\n}\n\n// @param url {String|Object} URL to Meteor app,\n//   or an object as a test hook (see code)\n// Options:\n//   reloadWithOutstanding: is it OK to reload if there are outstanding methods?\n//   headers: extra headers to send on the websockets connection, for\n//     server-to-server DDP only\n//   _sockjsOptions: Specifies options to pass through to the sockjs client\n//   onDDPNegotiationVersionFailure: callback when version negotiation fails.\n//\n// XXX There should be a way to destroy a DDP connection, causing all\n// outstanding method calls to fail.\n//\n// XXX Our current way of handling failure and reconnection is great\n// for an app (where we want to tolerate being disconnected as an\n// expect state, and keep trying forever to reconnect) but cumbersome\n// for something like a command line tool that wants to make a\n// connection, call a method, and print an error if connection\n// fails. We should have better usability in the latter case (while\n// still transparently reconnecting if it's just a transient failure\n// or the server migrating us).\nvar Connection = function (url, options) {\n  var self = this;\n  options = _.extend({\n    onConnected: function () {},\n    onDDPVersionNegotiationFailure: function (description) {\n      Meteor._debug(description);\n    },\n    heartbeatInterval: 17500,\n    heartbeatTimeout: 15000,\n    npmFayeOptions: {},\n    // These options are only for testing.\n    reloadWithOutstanding: false,\n    supportedDDPVersions: DDPCommon.SUPPORTED_DDP_VERSIONS,\n    retry: true,\n    respondToPings: true\n  }, options);\n\n  // If set, called when we reconnect, queuing method calls _before_ the\n  // existing outstanding ones. This is the only data member that is part of the\n  // public API!\n  self.onReconnect = null;\n\n  // as a test hook, allow passing a stream instead of a url.\n  if (typeof url === \"object\") {\n    self._stream = url;\n  } else {\n    self._stream = new LivedataTest.ClientStream(url, {\n      retry: options.retry,\n      headers: options.headers,\n      _sockjsOptions: options._sockjsOptions,\n      // Used to keep some tests quiet, or for other cases in which\n      // the right thing to do with connection errors is to silently\n      // fail (e.g. sending package usage stats). At some point we\n      // should have a real API for handling client-stream-level\n      // errors.\n      _dontPrintErrors: options._dontPrintErrors,\n      connectTimeoutMs: options.connectTimeoutMs,\n      npmFayeOptions: options.npmFayeOptions\n    });\n  }\n\n  self._lastSessionId = null;\n  self._versionSuggestion = null;  // The last proposed DDP version.\n  self._version = null;   // The DDP version agreed on by client and server.\n  self._stores = {}; // name -> object with methods\n  self._methodHandlers = {}; // name -> func\n  self._nextMethodId = 1;\n  self._supportedDDPVersions = options.supportedDDPVersions;\n\n  self._heartbeatInterval = options.heartbeatInterval;\n  self._heartbeatTimeout = options.heartbeatTimeout;\n\n  // Tracks methods which the user has tried to call but which have not yet\n  // called their user callback (ie, they are waiting on their result or for all\n  // of their writes to be written to the local cache). Map from method ID to\n  // MethodInvoker object.\n  self._methodInvokers = {};\n\n  // Tracks methods which the user has called but whose result messages have not\n  // arrived yet.\n  //\n  // _outstandingMethodBlocks is an array of blocks of methods. Each block\n  // represents a set of methods that can run at the same time. The first block\n  // represents the methods which are currently in flight; subsequent blocks\n  // must wait for previous blocks to be fully finished before they can be sent\n  // to the server.\n  //\n  // Each block is an object with the following fields:\n  // - methods: a list of MethodInvoker objects\n  // - wait: a boolean; if true, this block had a single method invoked with\n  //         the \"wait\" option\n  //\n  // There will never be adjacent blocks with wait=false, because the only thing\n  // that makes methods need to be serialized is a wait method.\n  //\n  // Methods are removed from the first block when their \"result\" is\n  // received. The entire first block is only removed when all of the in-flight\n  // methods have received their results (so the \"methods\" list is empty) *AND*\n  // all of the data written by those methods are visible in the local cache. So\n  // it is possible for the first block's methods list to be empty, if we are\n  // still waiting for some objects to quiesce.\n  //\n  // Example:\n  //  _outstandingMethodBlocks = [\n  //    {wait: false, methods: []},\n  //    {wait: true, methods: [<MethodInvoker for 'login'>]},\n  //    {wait: false, methods: [<MethodInvoker for 'foo'>,\n  //                            <MethodInvoker for 'bar'>]}]\n  // This means that there were some methods which were sent to the server and\n  // which have returned their results, but some of the data written by\n  // the methods may not be visible in the local cache. Once all that data is\n  // visible, we will send a 'login' method. Once the login method has returned\n  // and all the data is visible (including re-running subs if userId changes),\n  // we will send the 'foo' and 'bar' methods in parallel.\n  self._outstandingMethodBlocks = [];\n\n  // method ID -> array of objects with keys 'collection' and 'id', listing\n  // documents written by a given method's stub. keys are associated with\n  // methods whose stub wrote at least one document, and whose data-done message\n  // has not yet been received.\n  self._documentsWrittenByStub = {};\n  // collection -> IdMap of \"server document\" object. A \"server document\" has:\n  // - \"document\": the version of the document according the\n  //   server (ie, the snapshot before a stub wrote it, amended by any changes\n  //   received from the server)\n  //   It is undefined if we think the document does not exist\n  // - \"writtenByStubs\": a set of method IDs whose stubs wrote to the document\n  //   whose \"data done\" messages have not yet been processed\n  self._serverDocuments = {};\n\n  // Array of callbacks to be called after the next update of the local\n  // cache. Used for:\n  //  - Calling methodInvoker.dataVisible and sub ready callbacks after\n  //    the relevant data is flushed.\n  //  - Invoking the callbacks of \"half-finished\" methods after reconnect\n  //    quiescence. Specifically, methods whose result was received over the old\n  //    connection (so we don't re-send it) but whose data had not been made\n  //    visible.\n  self._afterUpdateCallbacks = [];\n\n  // In two contexts, we buffer all incoming data messages and then process them\n  // all at once in a single update:\n  //   - During reconnect, we buffer all data messages until all subs that had\n  //     been ready before reconnect are ready again, and all methods that are\n  //     active have returned their \"data done message\"; then\n  //   - During the execution of a \"wait\" method, we buffer all data messages\n  //     until the wait method gets its \"data done\" message. (If the wait method\n  //     occurs during reconnect, it doesn't get any special handling.)\n  // all data messages are processed in one update.\n  //\n  // The following fields are used for this \"quiescence\" process.\n\n  // This buffers the messages that aren't being processed yet.\n  self._messagesBufferedUntilQuiescence = [];\n  // Map from method ID -> true. Methods are removed from this when their\n  // \"data done\" message is received, and we will not quiesce until it is\n  // empty.\n  self._methodsBlockingQuiescence = {};\n  // map from sub ID -> true for subs that were ready (ie, called the sub\n  // ready callback) before reconnect but haven't become ready again yet\n  self._subsBeingRevived = {}; // map from sub._id -> true\n  // if true, the next data update should reset all stores. (set during\n  // reconnect.)\n  self._resetStores = false;\n\n  // name -> array of updates for (yet to be created) collections\n  self._updatesForUnknownStores = {};\n  // if we're blocking a migration, the retry func\n  self._retryMigrate = null;\n\n  // metadata for subscriptions.  Map from sub ID to object with keys:\n  //   - id\n  //   - name\n  //   - params\n  //   - inactive (if true, will be cleaned up if not reused in re-run)\n  //   - ready (has the 'ready' message been received?)\n  //   - readyCallback (an optional callback to call when ready)\n  //   - errorCallback (an optional callback to call if the sub terminates with\n  //                    an error, XXX COMPAT WITH 1.0.3.1)\n  //   - stopCallback (an optional callback to call when the sub terminates\n  //     for any reason, with an error argument if an error triggered the stop)\n  self._subscriptions = {};\n\n  // Reactive userId.\n  self._userId = null;\n  self._userIdDeps = new Tracker.Dependency;\n\n  // Block auto-reload while we're waiting for method responses.\n  if (Meteor.isClient && Package.reload && !options.reloadWithOutstanding) {\n    Package.reload.Reload._onMigrate(function (retry) {\n      if (!self._readyToMigrate()) {\n        if (self._retryMigrate)\n          throw new Error(\"Two migrations in progress?\");\n        self._retryMigrate = retry;\n        return false;\n      } else {\n        return [true];\n      }\n    });\n  }\n\n  var onMessage = function (raw_msg) {\n    try {\n      var msg = DDPCommon.parseDDP(raw_msg);\n    } catch (e) {\n      Meteor._debug(\"Exception while parsing DDP\", e);\n      return;\n    }\n\n    // Any message counts as receiving a pong, as it demonstrates that\n    // the server is still alive.\n    if (self._heartbeat) {\n      self._heartbeat.messageReceived();\n    }\n\n    if (msg === null || !msg.msg) {\n      // XXX COMPAT WITH 0.6.6. ignore the old welcome message for back\n      // compat.  Remove this 'if' once the server stops sending welcome\n      // messages (stream_server.js).\n      if (! (msg && msg.server_id))\n        Meteor._debug(\"discarding invalid livedata message\", msg);\n      return;\n    }\n\n    if (msg.msg === 'connected') {\n      self._version = self._versionSuggestion;\n      self._livedata_connected(msg);\n      options.onConnected();\n    }\n    else if (msg.msg === 'failed') {\n      if (_.contains(self._supportedDDPVersions, msg.version)) {\n        self._versionSuggestion = msg.version;\n        self._stream.reconnect({_force: true});\n      } else {\n        var description =\n              \"DDP version negotiation failed; server requested version \" + msg.version;\n        self._stream.disconnect({_permanent: true, _error: description});\n        options.onDDPVersionNegotiationFailure(description);\n      }\n    }\n    else if (msg.msg === 'ping' && options.respondToPings) {\n      self._send({msg: \"pong\", id: msg.id});\n    }\n    else if (msg.msg === 'pong') {\n      // noop, as we assume everything's a pong\n    }\n    else if (_.include(['added', 'changed', 'removed', 'ready', 'updated'], msg.msg))\n      self._livedata_data(msg);\n    else if (msg.msg === 'nosub')\n      self._livedata_nosub(msg);\n    else if (msg.msg === 'result')\n      self._livedata_result(msg);\n    else if (msg.msg === 'error')\n      self._livedata_error(msg);\n    else\n      Meteor._debug(\"discarding unknown livedata message type\", msg);\n  };\n\n  var onReset = function () {\n    // Send a connect message at the beginning of the stream.\n    // NOTE: reset is called even on the first connection, so this is\n    // the only place we send this message.\n    var msg = {msg: 'connect'};\n    if (self._lastSessionId)\n      msg.session = self._lastSessionId;\n    msg.version = self._versionSuggestion || self._supportedDDPVersions[0];\n    self._versionSuggestion = msg.version;\n    msg.support = self._supportedDDPVersions;\n    self._send(msg);\n\n    // Mark non-retry calls as failed. This has to be done early as getting these methods out of the\n    // current block is pretty important to making sure that quiescence is properly calculated, as\n    // well as possibly moving on to another useful block.\n\n    // Only bother testing if there is an outstandingMethodBlock (there might not be, especially if\n    // we are connecting for the first time.\n    if (self._outstandingMethodBlocks.length > 0) {\n      // If there is an outstanding method block, we only care about the first one as that is the\n      // one that could have already sent messages with no response, that are not allowed to retry.\n      _.each(self._outstandingMethodBlocks[0].methods, function(methodInvoker) {\n        // If the message wasn't sent or it's allowed to retry, do nothing.\n        if (methodInvoker.sentMessage && methodInvoker.noRetry) {\n          // The next loop serves to get the index in the current method block of this method.\n          var currentMethodBlock = self._outstandingMethodBlocks[0].methods;\n          var loopMethod;\n          for (var i = 0; i < currentMethodBlock.length; i++) {\n            loopMethod = currentMethodBlock[i];\n            if (loopMethod.methodId === methodInvoker.methodId) {\n              break;\n            }\n          }\n\n          // Remove from current method block. This may leave the block empty, but we\n          // don't move on to the next block until the callback has been delivered, in\n          // _outstandingMethodFinished.\n          currentMethodBlock.splice(i, 1);\n\n          // Make sure that the method is told that it failed.\n          methodInvoker.receiveResult(Meteor.Error('invocation-failed',\n            'Method invocation might have failed due to dropped connection. ' +\n            'Failing because `noRetry` option was passed to Meteor.apply.'));\n        }\n      });\n    }\n\n    // Now, to minimize setup latency, go ahead and blast out all of\n    // our pending methods ands subscriptions before we've even taken\n    // the necessary RTT to know if we successfully reconnected. (1)\n    // They're supposed to be idempotent, and where they are not,\n    // they can block retry in apply; (2) even if we did reconnect,\n    // we're not sure what messages might have gotten lost\n    // (in either direction) since we were disconnected (TCP being\n    // sloppy about that.)\n\n    // If the current block of methods all got their results (but didn't all get\n    // their data visible), discard the empty block now.\n    if (! _.isEmpty(self._outstandingMethodBlocks) &&\n        _.isEmpty(self._outstandingMethodBlocks[0].methods)) {\n      self._outstandingMethodBlocks.shift();\n    }\n\n    // Mark all messages as unsent, they have not yet been sent on this\n    // connection.\n    _.each(self._methodInvokers, function (m) {\n      m.sentMessage = false;\n    });\n\n    // If an `onReconnect` handler is set, call it first. Go through\n    // some hoops to ensure that methods that are called from within\n    // `onReconnect` get executed _before_ ones that were originally\n    // outstanding (since `onReconnect` is used to re-establish auth\n    // certificates)\n    if (self.onReconnect)\n      self._callOnReconnectAndSendAppropriateOutstandingMethods();\n    else\n      self._sendOutstandingMethods();\n\n    // add new subscriptions at the end. this way they take effect after\n    // the handlers and we don't see flicker.\n    _.each(self._subscriptions, function (sub, id) {\n      self._send({\n        msg: 'sub',\n        id: id,\n        name: sub.name,\n        params: sub.params\n      });\n    });\n  };\n\n  var onDisconnect = function () {\n    if (self._heartbeat) {\n      self._heartbeat.stop();\n      self._heartbeat = null;\n    }\n  };\n\n  if (Meteor.isServer) {\n    self._stream.on('message', Meteor.bindEnvironment(onMessage, \"handling DDP message\"));\n    self._stream.on('reset', Meteor.bindEnvironment(onReset, \"handling DDP reset\"));\n    self._stream.on('disconnect', Meteor.bindEnvironment(onDisconnect, \"handling DDP disconnect\"));\n  } else {\n    self._stream.on('message', onMessage);\n    self._stream.on('reset', onReset);\n    self._stream.on('disconnect', onDisconnect);\n  }\n};\n\n// A MethodInvoker manages sending a method to the server and calling the user's\n// callbacks. On construction, it registers itself in the connection's\n// _methodInvokers map; it removes itself once the method is fully finished and\n// the callback is invoked. This occurs when it has both received a result,\n// and the data written by it is fully visible.\nvar MethodInvoker = function (options) {\n  var self = this;\n\n  // Public (within this file) fields.\n  self.methodId = options.methodId;\n  self.sentMessage = false;\n\n  self._callback = options.callback;\n  self._connection = options.connection;\n  self._message = options.message;\n  self._onResultReceived = options.onResultReceived || function () {};\n  self._wait = options.wait;\n  self.noRetry = options.noRetry;\n  self._methodResult = null;\n  self._dataVisible = false;\n\n  // Register with the connection.\n  self._connection._methodInvokers[self.methodId] = self;\n};\n_.extend(MethodInvoker.prototype, {\n  // Sends the method message to the server. May be called additional times if\n  // we lose the connection and reconnect before receiving a result.\n  sendMessage: function () {\n    var self = this;\n    // This function is called before sending a method (including resending on\n    // reconnect). We should only (re)send methods where we don't already have a\n    // result!\n    if (self.gotResult())\n      throw new Error(\"sendingMethod is called on method with result\");\n\n\n    // If we're re-sending it, it doesn't matter if data was written the first\n    // time.\n    self._dataVisible = false;\n    self.sentMessage = true;\n\n    // If this is a wait method, make all data messages be buffered until it is\n    // done.\n    if (self._wait)\n      self._connection._methodsBlockingQuiescence[self.methodId] = true;\n\n    // Actually send the message.\n    self._connection._send(self._message);\n  },\n  // Invoke the callback, if we have both a result and know that all data has\n  // been written to the local cache.\n  _maybeInvokeCallback: function () {\n    var self = this;\n    if (self._methodResult && self._dataVisible) {\n      // Call the callback. (This won't throw: the callback was wrapped with\n      // bindEnvironment.)\n      self._callback(self._methodResult[0], self._methodResult[1]);\n\n      // Forget about this method.\n      delete self._connection._methodInvokers[self.methodId];\n\n      // Let the connection know that this method is finished, so it can try to\n      // move on to the next block of methods.\n      self._connection._outstandingMethodFinished();\n    }\n  },\n  // Call with the result of the method from the server. Only may be called\n  // once; once it is called, you should not call sendMessage again.\n  // If the user provided an onResultReceived callback, call it immediately.\n  // Then invoke the main callback if data is also visible.\n  receiveResult: function (err, result) {\n    var self = this;\n    if (self.gotResult())\n      throw new Error(\"Methods should only receive results once\");\n    self._methodResult = [err, result];\n    self._onResultReceived(err, result);\n    self._maybeInvokeCallback();\n  },\n  // Call this when all data written by the method is visible. This means that\n  // the method has returns its \"data is done\" message *AND* all server\n  // documents that are buffered at that time have been written to the local\n  // cache. Invokes the main callback if the result has been received.\n  dataVisible: function () {\n    var self = this;\n    self._dataVisible = true;\n    self._maybeInvokeCallback();\n  },\n  // True if receiveResult has been called.\n  gotResult: function () {\n    var self = this;\n    return !!self._methodResult;\n  }\n});\n\n_.extend(Connection.prototype, {\n  // 'name' is the name of the data on the wire that should go in the\n  // store. 'wrappedStore' should be an object with methods beginUpdate, update,\n  // endUpdate, saveOriginals, retrieveOriginals. see Collection for an example.\n  registerStore: function (name, wrappedStore) {\n    var self = this;\n\n    if (name in self._stores)\n      return false;\n\n    // Wrap the input object in an object which makes any store method not\n    // implemented by 'store' into a no-op.\n    var store = {};\n    _.each(['update', 'beginUpdate', 'endUpdate', 'saveOriginals',\n            'retrieveOriginals', 'getDoc',\n\t\t\t'_getCollection'], function (method) {\n              store[method] = function () {\n                return (wrappedStore[method]\n                        ? wrappedStore[method].apply(wrappedStore, arguments)\n                        : undefined);\n              };\n            });\n\n    self._stores[name] = store;\n\n    var queued = self._updatesForUnknownStores[name];\n    if (queued) {\n      store.beginUpdate(queued.length, false);\n      _.each(queued, function (msg) {\n        store.update(msg);\n      });\n      store.endUpdate();\n      delete self._updatesForUnknownStores[name];\n    }\n\n    return true;\n  },\n\n  /**\n   * @memberOf Meteor\n   * @importFromPackage meteor\n   * @summary Subscribe to a record set.  Returns a handle that provides\n   * `stop()` and `ready()` methods.\n   * @locus Client\n   * @param {String} name Name of the subscription.  Matches the name of the\n   * server's `publish()` call.\n   * @param {EJSONable} [arg1,arg2...] Optional arguments passed to publisher\n   * function on server.\n   * @param {Function|Object} [callbacks] Optional. May include `onStop`\n   * and `onReady` callbacks. If there is an error, it is passed as an\n   * argument to `onStop`. If a function is passed instead of an object, it\n   * is interpreted as an `onReady` callback.\n   */\n  subscribe: function (name /* .. [arguments] .. (callback|callbacks) */) {\n    var self = this;\n\n    var params = Array.prototype.slice.call(arguments, 1);\n    var callbacks = {};\n    if (params.length) {\n      var lastParam = params[params.length - 1];\n      if (_.isFunction(lastParam)) {\n        callbacks.onReady = params.pop();\n      } else if (lastParam &&\n        // XXX COMPAT WITH 1.0.3.1 onError used to exist, but now we use\n        // onStop with an error callback instead.\n        _.any([lastParam.onReady, lastParam.onError, lastParam.onStop],\n          _.isFunction)) {\n        callbacks = params.pop();\n      }\n    }\n\n    // Is there an existing sub with the same name and param, run in an\n    // invalidated Computation? This will happen if we are rerunning an\n    // existing computation.\n    //\n    // For example, consider a rerun of:\n    //\n    //     Tracker.autorun(function () {\n    //       Meteor.subscribe(\"foo\", Session.get(\"foo\"));\n    //       Meteor.subscribe(\"bar\", Session.get(\"bar\"));\n    //     });\n    //\n    // If \"foo\" has changed but \"bar\" has not, we will match the \"bar\"\n    // subcribe to an existing inactive subscription in order to not\n    // unsub and resub the subscription unnecessarily.\n    //\n    // We only look for one such sub; if there are N apparently-identical subs\n    // being invalidated, we will require N matching subscribe calls to keep\n    // them all active.\n    var existing = _.find(self._subscriptions, function (sub) {\n      return sub.inactive && sub.name === name &&\n        EJSON.equals(sub.params, params);\n    });\n\n    var id;\n    if (existing) {\n      id = existing.id;\n      existing.inactive = false; // reactivate\n\n      if (callbacks.onReady) {\n        // If the sub is not already ready, replace any ready callback with the\n        // one provided now. (It's not really clear what users would expect for\n        // an onReady callback inside an autorun; the semantics we provide is\n        // that at the time the sub first becomes ready, we call the last\n        // onReady callback provided, if any.)\n        if (!existing.ready)\n          existing.readyCallback = callbacks.onReady;\n      }\n\n      // XXX COMPAT WITH 1.0.3.1 we used to have onError but now we call\n      // onStop with an optional error argument\n      if (callbacks.onError) {\n        // Replace existing callback if any, so that errors aren't\n        // double-reported.\n        existing.errorCallback = callbacks.onError;\n      }\n\n      if (callbacks.onStop) {\n        existing.stopCallback = callbacks.onStop;\n      }\n    } else {\n      // New sub! Generate an id, save it locally, and send message.\n      id = Random.id();\n      self._subscriptions[id] = {\n        id: id,\n        name: name,\n        params: EJSON.clone(params),\n        inactive: false,\n        ready: false,\n        readyDeps: new Tracker.Dependency,\n        readyCallback: callbacks.onReady,\n        // XXX COMPAT WITH 1.0.3.1 #errorCallback\n        errorCallback: callbacks.onError,\n        stopCallback: callbacks.onStop,\n        connection: self,\n        remove: function() {\n          delete this.connection._subscriptions[this.id];\n          this.ready && this.readyDeps.changed();\n        },\n        stop: function() {\n          this.connection._send({msg: 'unsub', id: id});\n          this.remove();\n\n          if (callbacks.onStop) {\n            callbacks.onStop();\n          }\n        }\n      };\n      self._send({msg: 'sub', id: id, name: name, params: params});\n    }\n\n    // return a handle to the application.\n    var handle = {\n      stop: function () {\n        if (!_.has(self._subscriptions, id))\n          return;\n\n        self._subscriptions[id].stop();\n      },\n      ready: function () {\n        // return false if we've unsubscribed.\n        if (!_.has(self._subscriptions, id))\n          return false;\n        var record = self._subscriptions[id];\n        record.readyDeps.depend();\n        return record.ready;\n      },\n      subscriptionId: id\n    };\n\n    if (Tracker.active) {\n      // We're in a reactive computation, so we'd like to unsubscribe when the\n      // computation is invalidated... but not if the rerun just re-subscribes\n      // to the same subscription!  When a rerun happens, we use onInvalidate\n      // as a change to mark the subscription \"inactive\" so that it can\n      // be reused from the rerun.  If it isn't reused, it's killed from\n      // an afterFlush.\n      Tracker.onInvalidate(function (c) {\n        if (_.has(self._subscriptions, id))\n          self._subscriptions[id].inactive = true;\n\n        Tracker.afterFlush(function () {\n          if (_.has(self._subscriptions, id) &&\n              self._subscriptions[id].inactive)\n            handle.stop();\n        });\n      });\n    }\n\n    return handle;\n  },\n\n  // options:\n  // - onLateError {Function(error)} called if an error was received after the ready event.\n  //     (errors received before ready cause an error to be thrown)\n  _subscribeAndWait: function (name, args, options) {\n    var self = this;\n    var f = new Future();\n    var ready = false;\n    var handle;\n    args = args || [];\n    args.push({\n      onReady: function () {\n        ready = true;\n        f['return']();\n      },\n      onError: function (e) {\n        if (!ready)\n          f['throw'](e);\n        else\n          options && options.onLateError && options.onLateError(e);\n      }\n    });\n\n    handle = self.subscribe.apply(self, [name].concat(args));\n    f.wait();\n    return handle;\n  },\n\n  methods: function (methods) {\n    var self = this;\n    _.each(methods, function (func, name) {\n      if (typeof func !== 'function')\n        throw new Error(\"Method '\" + name + \"' must be a function\");\n      if (self._methodHandlers[name])\n        throw new Error(\"A method named '\" + name + \"' is already defined\");\n      self._methodHandlers[name] = func;\n    });\n  },\n\n  /**\n   * @memberOf Meteor\n   * @importFromPackage meteor\n   * @summary Invokes a method passing any number of arguments.\n   * @locus Anywhere\n   * @param {String} name Name of method to invoke\n   * @param {EJSONable} [arg1,arg2...] Optional method arguments\n   * @param {Function} [asyncCallback] Optional callback, which is called asynchronously with the error or result after the method is complete. If not provided, the method runs synchronously if possible (see below).\n   */\n  call: function (name /* .. [arguments] .. callback */) {\n    // if it's a function, the last argument is the result callback,\n    // not a parameter to the remote method.\n    var args = Array.prototype.slice.call(arguments, 1);\n    if (args.length && typeof args[args.length - 1] === \"function\")\n      var callback = args.pop();\n    return this.apply(name, args, callback);\n  },\n\n  // @param options {Optional Object}\n  //   wait: Boolean - Should we wait to call this until all current methods\n  //                   are fully finished, and block subsequent method calls\n  //                   until this method is fully finished?\n  //                   (does not affect methods called from within this method)\n  //   onResultReceived: Function - a callback to call as soon as the method\n  //                                result is received. the data written by\n  //                                the method may not yet be in the cache!\n  //   returnStubValue: Boolean - If true then in cases where we would have\n  //                              otherwise discarded the stub's return value\n  //                              and returned undefined, instead we go ahead\n  //                              and return it.  Specifically, this is any\n  //                              time other than when (a) we are already\n  //                              inside a stub or (b) we are in Node and no\n  //                              callback was provided.  Currently we require\n  //                              this flag to be explicitly passed to reduce\n  //                              the likelihood that stub return values will\n  //                              be confused with server return values; we\n  //                              may improve this in future.\n  // @param callback {Optional Function}\n\n  /**\n   * @memberOf Meteor\n   * @importFromPackage meteor\n   * @summary Invoke a method passing an array of arguments.\n   * @locus Anywhere\n   * @param {String} name Name of method to invoke\n   * @param {EJSONable[]} args Method arguments\n   * @param {Object} [options]\n   * @param {Boolean} options.wait (Client only) If true, don't send this method until all previous method calls have completed, and don't send any subsequent method calls until this one is completed.\n   * @param {Function} options.onResultReceived (Client only) This callback is invoked with the error or result of the method (just like `asyncCallback`) as soon as the error or result is available. The local cache may not yet reflect the writes performed by the method.\n   * @param (Boolean) options.noRetry (Client only) if true, don't send this method again on reload, simply call the callback an error with the error code 'invocation-failed'.\n   * @param {Function} [asyncCallback] Optional callback; same semantics as in [`Meteor.call`](#meteor_call).\n   */\n  apply: function (name, args, options, callback) {\n    var self = this;\n\n    // We were passed 3 arguments. They may be either (name, args, options)\n    // or (name, args, callback)\n    if (!callback && typeof options === 'function') {\n      callback = options;\n      options = {};\n    }\n    options = options || {};\n\n    if (callback) {\n      // XXX would it be better form to do the binding in stream.on,\n      // or caller, instead of here?\n      // XXX improve error message (and how we report it)\n      callback = Meteor.bindEnvironment(\n        callback,\n        \"delivering result of invoking '\" + name + \"'\"\n      );\n    }\n\n    // Keep our args safe from mutation (eg if we don't send the message for a\n    // while because of a wait method).\n    args = EJSON.clone(args);\n\n    // Lazily allocate method ID once we know that it'll be needed.\n    var methodId = (function () {\n      var id;\n      return function () {\n        if (id === undefined)\n          id = '' + (self._nextMethodId++);\n        return id;\n      };\n    })();\n\n    var enclosing = DDP._CurrentInvocation.get();\n    var alreadyInSimulation = enclosing && enclosing.isSimulation;\n\n    // Lazily generate a randomSeed, only if it is requested by the stub.\n    // The random streams only have utility if they're used on both the client\n    // and the server; if the client doesn't generate any 'random' values\n    // then we don't expect the server to generate any either.\n    // Less commonly, the server may perform different actions from the client,\n    // and may in fact generate values where the client did not, but we don't\n    // have any client-side values to match, so even here we may as well just\n    // use a random seed on the server.  In that case, we don't pass the\n    // randomSeed to save bandwidth, and we don't even generate it to save a\n    // bit of CPU and to avoid consuming entropy.\n    var randomSeed = null;\n    var randomSeedGenerator = function () {\n      if (randomSeed === null) {\n        randomSeed = DDPCommon.makeRpcSeed(enclosing, name);\n      }\n      return randomSeed;\n    };\n\n    // Run the stub, if we have one. The stub is supposed to make some\n    // temporary writes to the database to give the user a smooth experience\n    // until the actual result of executing the method comes back from the\n    // server (whereupon the temporary writes to the database will be reversed\n    // during the beginUpdate/endUpdate process.)\n    //\n    // Normally, we ignore the return value of the stub (even if it is an\n    // exception), in favor of the real return value from the server. The\n    // exception is if the *caller* is a stub. In that case, we're not going\n    // to do a RPC, so we use the return value of the stub as our return\n    // value.\n\n    var stub = self._methodHandlers[name];\n    if (stub) {\n      var setUserId = function(userId) {\n        self.setUserId(userId);\n      };\n\n      var invocation = new DDPCommon.MethodInvocation({\n        isSimulation: true,\n        userId: self.userId(),\n        setUserId: setUserId,\n        randomSeed: function () { return randomSeedGenerator(); }\n      });\n\n      if (!alreadyInSimulation)\n        self._saveOriginals();\n\n      try {\n        // Note that unlike in the corresponding server code, we never audit\n        // that stubs check() their arguments.\n        var stubReturnValue = DDP._CurrentInvocation.withValue(invocation, function () {\n          if (Meteor.isServer) {\n            // Because saveOriginals and retrieveOriginals aren't reentrant,\n            // don't allow stubs to yield.\n            return Meteor._noYieldsAllowed(function () {\n              // re-clone, so that the stub can't affect our caller's values\n              return stub.apply(invocation, EJSON.clone(args));\n            });\n          } else {\n            return stub.apply(invocation, EJSON.clone(args));\n          }\n        });\n      }\n      catch (e) {\n        var exception = e;\n      }\n\n      if (!alreadyInSimulation)\n        self._retrieveAndStoreOriginals(methodId());\n    }\n\n    // If we're in a simulation, stop and return the result we have,\n    // rather than going on to do an RPC. If there was no stub,\n    // we'll end up returning undefined.\n    if (alreadyInSimulation) {\n      if (callback) {\n        callback(exception, stubReturnValue);\n        return undefined;\n      }\n      if (exception)\n        throw exception;\n      return stubReturnValue;\n    }\n\n    // If an exception occurred in a stub, and we're ignoring it\n    // because we're doing an RPC and want to use what the server\n    // returns instead, log it so the developer knows\n    // (unless they explicitly ask to see the error).\n    //\n    // Tests can set the 'expected' flag on an exception so it won't\n    // go to log.\n    if (exception) {\n      if (options.throwStubExceptions) {\n        throw exception;\n      } else if (!exception.expected) {\n        Meteor._debug(\"Exception while simulating the effect of invoking '\" +\n          name + \"'\", exception, exception.stack);\n      }\n    }\n\n\n    // At this point we're definitely doing an RPC, and we're going to\n    // return the value of the RPC to the caller.\n\n    // If the caller didn't give a callback, decide what to do.\n    if (!callback) {\n      if (Meteor.isClient) {\n        // On the client, we don't have fibers, so we can't block. The\n        // only thing we can do is to return undefined and discard the\n        // result of the RPC. If an error occurred then print the error\n        // to the console.\n        callback = function (err) {\n          err && Meteor._debug(\"Error invoking Method '\" + name + \"':\",\n                               err.message);\n        };\n      } else {\n        // On the server, make the function synchronous. Throw on\n        // errors, return on success.\n        var future = new Future;\n        callback = future.resolver();\n      }\n    }\n    // Send the RPC. Note that on the client, it is important that the\n    // stub have finished before we send the RPC, so that we know we have\n    // a complete list of which local documents the stub wrote.\n    var message = {\n      msg: 'method',\n      method: name,\n      params: args,\n      id: methodId()\n    };\n\n    // Send the randomSeed only if we used it\n    if (randomSeed !== null) {\n      message.randomSeed = randomSeed;\n    }\n\n    var methodInvoker = new MethodInvoker({\n      methodId: methodId(),\n      callback: callback,\n      connection: self,\n      onResultReceived: options.onResultReceived,\n      wait: !!options.wait,\n      message: message,\n      noRetry: !!options.noRetry\n    });\n\n    if (options.wait) {\n      // It's a wait method! Wait methods go in their own block.\n      self._outstandingMethodBlocks.push(\n        {wait: true, methods: [methodInvoker]});\n    } else {\n      // Not a wait method. Start a new block if the previous block was a wait\n      // block, and add it to the last block of methods.\n      if (_.isEmpty(self._outstandingMethodBlocks) ||\n          _.last(self._outstandingMethodBlocks).wait)\n        self._outstandingMethodBlocks.push({wait: false, methods: []});\n      _.last(self._outstandingMethodBlocks).methods.push(methodInvoker);\n    }\n\n    // If we added it to the first block, send it out now.\n    if (self._outstandingMethodBlocks.length === 1)\n      methodInvoker.sendMessage();\n\n    // If we're using the default callback on the server,\n    // block waiting for the result.\n    if (future) {\n      return future.wait();\n    }\n    return options.returnStubValue ? stubReturnValue : undefined;\n  },\n\n  // Before calling a method stub, prepare all stores to track changes and allow\n  // _retrieveAndStoreOriginals to get the original versions of changed\n  // documents.\n  _saveOriginals: function () {\n    var self = this;\n    _.each(self._stores, function (s) {\n      s.saveOriginals();\n    });\n  },\n  // Retrieves the original versions of all documents modified by the stub for\n  // method 'methodId' from all stores and saves them to _serverDocuments (keyed\n  // by document) and _documentsWrittenByStub (keyed by method ID).\n  _retrieveAndStoreOriginals: function (methodId) {\n    var self = this;\n    if (self._documentsWrittenByStub[methodId])\n      throw new Error(\"Duplicate methodId in _retrieveAndStoreOriginals\");\n\n    var docsWritten = [];\n    _.each(self._stores, function (s, collection) {\n      var originals = s.retrieveOriginals();\n      // not all stores define retrieveOriginals\n      if (!originals)\n        return;\n      originals.forEach(function (doc, id) {\n        docsWritten.push({collection: collection, id: id});\n        if (!_.has(self._serverDocuments, collection))\n          self._serverDocuments[collection] = new MongoIDMap;\n        var serverDoc = self._serverDocuments[collection].setDefault(id, {});\n        if (serverDoc.writtenByStubs) {\n          // We're not the first stub to write this doc. Just add our method ID\n          // to the record.\n          serverDoc.writtenByStubs[methodId] = true;\n        } else {\n          // First stub! Save the original value and our method ID.\n          serverDoc.document = doc;\n          serverDoc.flushCallbacks = [];\n          serverDoc.writtenByStubs = {};\n          serverDoc.writtenByStubs[methodId] = true;\n        }\n      });\n    });\n    if (!_.isEmpty(docsWritten)) {\n      self._documentsWrittenByStub[methodId] = docsWritten;\n    }\n  },\n\n  // This is very much a private function we use to make the tests\n  // take up fewer server resources after they complete.\n  _unsubscribeAll: function () {\n    var self = this;\n    _.each(_.clone(self._subscriptions), function (sub, id) {\n      // Avoid killing the autoupdate subscription so that developers\n      // still get hot code pushes when writing tests.\n      //\n      // XXX it's a hack to encode knowledge about autoupdate here,\n      // but it doesn't seem worth it yet to have a special API for\n      // subscriptions to preserve after unit tests.\n      if (sub.name !== 'meteor_autoupdate_clientVersions') {\n        self._subscriptions[id].stop();\n      }\n    });\n  },\n\n  // Sends the DDP stringification of the given message object\n  _send: function (obj) {\n    var self = this;\n    self._stream.send(DDPCommon.stringifyDDP(obj));\n  },\n\n  // We detected via DDP-level heartbeats that we've lost the\n  // connection.  Unlike `disconnect` or `close`, a lost connection\n  // will be automatically retried.\n  _lostConnection: function (error) {\n    var self = this;\n    self._stream._lostConnection(error);\n  },\n\n  /**\n   * @summary Get the current connection status. A reactive data source.\n   * @locus Client\n   * @memberOf Meteor\n   * @importFromPackage meteor\n   */\n  status: function (/*passthrough args*/) {\n    var self = this;\n    return self._stream.status.apply(self._stream, arguments);\n  },\n\n  /**\n   * @summary Force an immediate reconnection attempt if the client is not connected to the server.\n\n  This method does nothing if the client is already connected.\n   * @locus Client\n   * @memberOf Meteor\n   * @importFromPackage meteor\n   */\n  reconnect: function (/*passthrough args*/) {\n    var self = this;\n    return self._stream.reconnect.apply(self._stream, arguments);\n  },\n\n  /**\n   * @summary Disconnect the client from the server.\n   * @locus Client\n   * @memberOf Meteor\n   * @importFromPackage meteor\n   */\n  disconnect: function (/*passthrough args*/) {\n    var self = this;\n    return self._stream.disconnect.apply(self._stream, arguments);\n  },\n\n  close: function () {\n    var self = this;\n    return self._stream.disconnect({_permanent: true});\n  },\n\n  ///\n  /// Reactive user system\n  ///\n  userId: function () {\n    var self = this;\n    if (self._userIdDeps)\n      self._userIdDeps.depend();\n    return self._userId;\n  },\n\n  setUserId: function (userId) {\n    var self = this;\n    // Avoid invalidating dependents if setUserId is called with current value.\n    if (self._userId === userId)\n      return;\n    self._userId = userId;\n    if (self._userIdDeps)\n      self._userIdDeps.changed();\n  },\n\n  // Returns true if we are in a state after reconnect of waiting for subs to be\n  // revived or early methods to finish their data, or we are waiting for a\n  // \"wait\" method to finish.\n  _waitingForQuiescence: function () {\n    var self = this;\n    return (! _.isEmpty(self._subsBeingRevived) ||\n            ! _.isEmpty(self._methodsBlockingQuiescence));\n  },\n\n  // Returns true if any method whose message has been sent to the server has\n  // not yet invoked its user callback.\n  _anyMethodsAreOutstanding: function () {\n    var self = this;\n    return _.any(_.pluck(self._methodInvokers, 'sentMessage'));\n  },\n\n  _livedata_connected: function (msg) {\n    var self = this;\n\n    if (self._version !== 'pre1' && self._heartbeatInterval !== 0) {\n      self._heartbeat = new DDPCommon.Heartbeat({\n        heartbeatInterval: self._heartbeatInterval,\n        heartbeatTimeout: self._heartbeatTimeout,\n        onTimeout: function () {\n          self._lostConnection(\n            new DDP.ConnectionError(\"DDP heartbeat timed out\"));\n        },\n        sendPing: function () {\n          self._send({msg: 'ping'});\n        }\n      });\n      self._heartbeat.start();\n    }\n\n    // If this is a reconnect, we'll have to reset all stores.\n    if (self._lastSessionId)\n      self._resetStores = true;\n\n    if (typeof (msg.session) === \"string\") {\n      var reconnectedToPreviousSession = (self._lastSessionId === msg.session);\n      self._lastSessionId = msg.session;\n    }\n\n    if (reconnectedToPreviousSession) {\n      // Successful reconnection -- pick up where we left off.  Note that right\n      // now, this never happens: the server never connects us to a previous\n      // session, because DDP doesn't provide enough data for the server to know\n      // what messages the client has processed. We need to improve DDP to make\n      // this possible, at which point we'll probably need more code here.\n      return;\n    }\n\n    // Server doesn't have our data any more. Re-sync a new session.\n\n    // Forget about messages we were buffering for unknown collections. They'll\n    // be resent if still relevant.\n    self._updatesForUnknownStores = {};\n\n    if (self._resetStores) {\n      // Forget about the effects of stubs. We'll be resetting all collections\n      // anyway.\n      self._documentsWrittenByStub = {};\n      self._serverDocuments = {};\n    }\n\n    // Clear _afterUpdateCallbacks.\n    self._afterUpdateCallbacks = [];\n\n    // Mark all named subscriptions which are ready (ie, we already called the\n    // ready callback) as needing to be revived.\n    // XXX We should also block reconnect quiescence until unnamed subscriptions\n    //     (eg, autopublish) are done re-publishing to avoid flicker!\n    self._subsBeingRevived = {};\n    _.each(self._subscriptions, function (sub, id) {\n      if (sub.ready)\n        self._subsBeingRevived[id] = true;\n    });\n\n    // Arrange for \"half-finished\" methods to have their callbacks run, and\n    // track methods that were sent on this connection so that we don't\n    // quiesce until they are all done.\n    //\n    // Start by clearing _methodsBlockingQuiescence: methods sent before\n    // reconnect don't matter, and any \"wait\" methods sent on the new connection\n    // that we drop here will be restored by the loop below.\n    self._methodsBlockingQuiescence = {};\n    if (self._resetStores) {\n      _.each(self._methodInvokers, function (invoker) {\n        if (invoker.gotResult()) {\n          // This method already got its result, but it didn't call its callback\n          // because its data didn't become visible. We did not resend the\n          // method RPC. We'll call its callback when we get a full quiesce,\n          // since that's as close as we'll get to \"data must be visible\".\n          self._afterUpdateCallbacks.push(_.bind(invoker.dataVisible, invoker));\n        } else if (invoker.sentMessage) {\n          // This method has been sent on this connection (maybe as a resend\n          // from the last connection, maybe from onReconnect, maybe just very\n          // quickly before processing the connected message).\n          //\n          // We don't need to do anything special to ensure its callbacks get\n          // called, but we'll count it as a method which is preventing\n          // reconnect quiescence. (eg, it might be a login method that was run\n          // from onReconnect, and we don't want to see flicker by seeing a\n          // logged-out state.)\n          self._methodsBlockingQuiescence[invoker.methodId] = true;\n        }\n      });\n    }\n\n    self._messagesBufferedUntilQuiescence = [];\n\n    // If we're not waiting on any methods or subs, we can reset the stores and\n    // call the callbacks immediately.\n    if (!self._waitingForQuiescence()) {\n      if (self._resetStores) {\n        _.each(self._stores, function (s) {\n          s.beginUpdate(0, true);\n          s.endUpdate();\n        });\n        self._resetStores = false;\n      }\n      self._runAfterUpdateCallbacks();\n    }\n  },\n\n\n  _processOneDataMessage: function (msg, updates) {\n    var self = this;\n    // Using underscore here so as not to need to capitalize.\n    self['_process_' + msg.msg](msg, updates);\n  },\n\n\n  _livedata_data: function (msg) {\n    var self = this;\n\n    // collection name -> array of messages\n    var updates = {};\n\n    if (self._waitingForQuiescence()) {\n      self._messagesBufferedUntilQuiescence.push(msg);\n\n      if (msg.msg === \"nosub\")\n        delete self._subsBeingRevived[msg.id];\n\n      _.each(msg.subs || [], function (subId) {\n        delete self._subsBeingRevived[subId];\n      });\n      _.each(msg.methods || [], function (methodId) {\n        delete self._methodsBlockingQuiescence[methodId];\n      });\n\n      if (self._waitingForQuiescence())\n        return;\n\n      // No methods or subs are blocking quiescence!\n      // We'll now process and all of our buffered messages, reset all stores,\n      // and apply them all at once.\n      _.each(self._messagesBufferedUntilQuiescence, function (bufferedMsg) {\n        self._processOneDataMessage(bufferedMsg, updates);\n      });\n      self._messagesBufferedUntilQuiescence = [];\n    } else {\n      self._processOneDataMessage(msg, updates);\n    }\n\n    if (self._resetStores || !_.isEmpty(updates)) {\n      // Begin a transactional update of each store.\n      _.each(self._stores, function (s, storeName) {\n        s.beginUpdate(_.has(updates, storeName) ? updates[storeName].length : 0,\n                      self._resetStores);\n      });\n      self._resetStores = false;\n\n      _.each(updates, function (updateMessages, storeName) {\n        var store = self._stores[storeName];\n        if (store) {\n          _.each(updateMessages, function (updateMessage) {\n            store.update(updateMessage);\n          });\n        } else {\n          // Nobody's listening for this data. Queue it up until\n          // someone wants it.\n          // XXX memory use will grow without bound if you forget to\n          // create a collection or just don't care about it... going\n          // to have to do something about that.\n          if (!_.has(self._updatesForUnknownStores, storeName))\n            self._updatesForUnknownStores[storeName] = [];\n          Array.prototype.push.apply(self._updatesForUnknownStores[storeName],\n                                     updateMessages);\n        }\n      });\n\n      // End update transaction.\n      _.each(self._stores, function (s) { s.endUpdate(); });\n    }\n\n    self._runAfterUpdateCallbacks();\n  },\n\n  // Call any callbacks deferred with _runWhenAllServerDocsAreFlushed whose\n  // relevant docs have been flushed, as well as dataVisible callbacks at\n  // reconnect-quiescence time.\n  _runAfterUpdateCallbacks: function () {\n    var self = this;\n    var callbacks = self._afterUpdateCallbacks;\n    self._afterUpdateCallbacks = [];\n    _.each(callbacks, function (c) {\n      c();\n    });\n  },\n\n  _pushUpdate: function (updates, collection, msg) {\n    var self = this;\n    if (!_.has(updates, collection)) {\n      updates[collection] = [];\n    }\n    updates[collection].push(msg);\n  },\n\n  _getServerDoc: function (collection, id) {\n    var self = this;\n    if (!_.has(self._serverDocuments, collection))\n      return null;\n    var serverDocsForCollection = self._serverDocuments[collection];\n    return serverDocsForCollection.get(id) || null;\n  },\n\n  _process_added: function (msg, updates) {\n    var self = this;\n    var id = MongoID.idParse(msg.id);\n    var serverDoc = self._getServerDoc(msg.collection, id);\n    if (serverDoc) {\n      // Some outstanding stub wrote here.\n      var isExisting = (serverDoc.document !== undefined);\n\n      serverDoc.document = msg.fields || {};\n      serverDoc.document._id = id;\n\n      if (self._resetStores) {\n        // During reconnect the server is sending adds for existing ids.\n        // Always push an update so that document stays in the store after\n        // reset. Use current version of the document for this update, so\n        // that stub-written values are preserved.\n        var currentDoc = self._stores[msg.collection].getDoc(msg.id);\n        if (currentDoc !== undefined)\n          msg.fields = currentDoc;\n\n        self._pushUpdate(updates, msg.collection, msg);\n      } else if (isExisting) {\n        throw new Error(\"Server sent add for existing id: \" + msg.id);\n      }\n    } else {\n      self._pushUpdate(updates, msg.collection, msg);\n    }\n  },\n\n  _process_changed: function (msg, updates) {\n    var self = this;\n    var serverDoc = self._getServerDoc(\n      msg.collection, MongoID.idParse(msg.id));\n    if (serverDoc) {\n      if (serverDoc.document === undefined)\n        throw new Error(\"Server sent changed for nonexisting id: \" + msg.id);\n      DiffSequence.applyChanges(serverDoc.document, msg.fields);\n    } else {\n      self._pushUpdate(updates, msg.collection, msg);\n    }\n  },\n\n  _process_removed: function (msg, updates) {\n    var self = this;\n    var serverDoc = self._getServerDoc(\n      msg.collection, MongoID.idParse(msg.id));\n    if (serverDoc) {\n      // Some outstanding stub wrote here.\n      if (serverDoc.document === undefined)\n        throw new Error(\"Server sent removed for nonexisting id:\" + msg.id);\n      serverDoc.document = undefined;\n    } else {\n      self._pushUpdate(updates, msg.collection, {\n        msg: 'removed',\n        collection: msg.collection,\n        id: msg.id\n      });\n    }\n  },\n\n  _process_updated: function (msg, updates) {\n    var self = this;\n    // Process \"method done\" messages.\n    _.each(msg.methods, function (methodId) {\n      _.each(self._documentsWrittenByStub[methodId], function (written) {\n        var serverDoc = self._getServerDoc(written.collection, written.id);\n        if (!serverDoc)\n          throw new Error(\"Lost serverDoc for \" + JSON.stringify(written));\n        if (!serverDoc.writtenByStubs[methodId])\n          throw new Error(\"Doc \" + JSON.stringify(written) +\n                          \" not written by  method \" + methodId);\n        delete serverDoc.writtenByStubs[methodId];\n        if (_.isEmpty(serverDoc.writtenByStubs)) {\n          // All methods whose stubs wrote this method have completed! We can\n          // now copy the saved document to the database (reverting the stub's\n          // change if the server did not write to this object, or applying the\n          // server's writes if it did).\n\n          // This is a fake ddp 'replace' message.  It's just for talking\n          // between livedata connections and minimongo.  (We have to stringify\n          // the ID because it's supposed to look like a wire message.)\n          self._pushUpdate(updates, written.collection, {\n            msg: 'replace',\n            id: MongoID.idStringify(written.id),\n            replace: serverDoc.document\n          });\n          // Call all flush callbacks.\n          _.each(serverDoc.flushCallbacks, function (c) {\n            c();\n          });\n\n          // Delete this completed serverDocument. Don't bother to GC empty\n          // IdMaps inside self._serverDocuments, since there probably aren't\n          // many collections and they'll be written repeatedly.\n          self._serverDocuments[written.collection].remove(written.id);\n        }\n      });\n      delete self._documentsWrittenByStub[methodId];\n\n      // We want to call the data-written callback, but we can't do so until all\n      // currently buffered messages are flushed.\n      var callbackInvoker = self._methodInvokers[methodId];\n      if (!callbackInvoker)\n        throw new Error(\"No callback invoker for method \" + methodId);\n      self._runWhenAllServerDocsAreFlushed(\n        _.bind(callbackInvoker.dataVisible, callbackInvoker));\n    });\n  },\n\n  _process_ready: function (msg, updates) {\n    var self = this;\n    // Process \"sub ready\" messages. \"sub ready\" messages don't take effect\n    // until all current server documents have been flushed to the local\n    // database. We can use a write fence to implement this.\n    _.each(msg.subs, function (subId) {\n      self._runWhenAllServerDocsAreFlushed(function () {\n        var subRecord = self._subscriptions[subId];\n        // Did we already unsubscribe?\n        if (!subRecord)\n          return;\n        // Did we already receive a ready message? (Oops!)\n        if (subRecord.ready)\n          return;\n        subRecord.ready = true;\n        subRecord.readyCallback && subRecord.readyCallback();\n        subRecord.readyDeps.changed();\n      });\n    });\n  },\n\n  // Ensures that \"f\" will be called after all documents currently in\n  // _serverDocuments have been written to the local cache. f will not be called\n  // if the connection is lost before then!\n  _runWhenAllServerDocsAreFlushed: function (f) {\n    var self = this;\n    var runFAfterUpdates = function () {\n      self._afterUpdateCallbacks.push(f);\n    };\n    var unflushedServerDocCount = 0;\n    var onServerDocFlush = function () {\n      --unflushedServerDocCount;\n      if (unflushedServerDocCount === 0) {\n        // This was the last doc to flush! Arrange to run f after the updates\n        // have been applied.\n        runFAfterUpdates();\n      }\n    };\n    _.each(self._serverDocuments, function (collectionDocs) {\n      collectionDocs.forEach(function (serverDoc) {\n        var writtenByStubForAMethodWithSentMessage = _.any(\n          serverDoc.writtenByStubs, function (dummy, methodId) {\n            var invoker = self._methodInvokers[methodId];\n            return invoker && invoker.sentMessage;\n          });\n        if (writtenByStubForAMethodWithSentMessage) {\n          ++unflushedServerDocCount;\n          serverDoc.flushCallbacks.push(onServerDocFlush);\n        }\n      });\n    });\n    if (unflushedServerDocCount === 0) {\n      // There aren't any buffered docs --- we can call f as soon as the current\n      // round of updates is applied!\n      runFAfterUpdates();\n    }\n  },\n\n  _livedata_nosub: function (msg) {\n    var self = this;\n\n    // First pass it through _livedata_data, which only uses it to help get\n    // towards quiescence.\n    self._livedata_data(msg);\n\n    // Do the rest of our processing immediately, with no\n    // buffering-until-quiescence.\n\n    // we weren't subbed anyway, or we initiated the unsub.\n    if (!_.has(self._subscriptions, msg.id))\n      return;\n\n    // XXX COMPAT WITH 1.0.3.1 #errorCallback\n    var errorCallback = self._subscriptions[msg.id].errorCallback;\n    var stopCallback = self._subscriptions[msg.id].stopCallback;\n\n    self._subscriptions[msg.id].remove();\n\n    var meteorErrorFromMsg = function (msgArg) {\n      return msgArg && msgArg.error && new Meteor.Error(\n        msgArg.error.error, msgArg.error.reason, msgArg.error.details);\n    }\n\n    // XXX COMPAT WITH 1.0.3.1 #errorCallback\n    if (errorCallback && msg.error) {\n      errorCallback(meteorErrorFromMsg(msg));\n    }\n\n    if (stopCallback) {\n      stopCallback(meteorErrorFromMsg(msg));\n    }\n  },\n\n  _process_nosub: function () {\n    // This is called as part of the \"buffer until quiescence\" process, but\n    // nosub's effect is always immediate. It only goes in the buffer at all\n    // because it's possible for a nosub to be the thing that triggers\n    // quiescence, if we were waiting for a sub to be revived and it dies\n    // instead.\n  },\n\n  _livedata_result: function (msg) {\n    // id, result or error. error has error (code), reason, details\n\n    var self = this;\n\n    // find the outstanding request\n    // should be O(1) in nearly all realistic use cases\n    if (_.isEmpty(self._outstandingMethodBlocks)) {\n      Meteor._debug(\"Received method result but no methods outstanding\");\n      return;\n    }\n    var currentMethodBlock = self._outstandingMethodBlocks[0].methods;\n    var m;\n    for (var i = 0; i < currentMethodBlock.length; i++) {\n      m = currentMethodBlock[i];\n      if (m.methodId === msg.id)\n        break;\n    }\n\n    if (!m) {\n      Meteor._debug(\"Can't match method response to original method call\", msg);\n      return;\n    }\n\n    // Remove from current method block. This may leave the block empty, but we\n    // don't move on to the next block until the callback has been delivered, in\n    // _outstandingMethodFinished.\n    currentMethodBlock.splice(i, 1);\n\n    if (_.has(msg, 'error')) {\n      m.receiveResult(new Meteor.Error(\n        msg.error.error, msg.error.reason,\n        msg.error.details));\n    } else {\n      // msg.result may be undefined if the method didn't return a\n      // value\n      m.receiveResult(undefined, msg.result);\n    }\n  },\n\n  // Called by MethodInvoker after a method's callback is invoked.  If this was\n  // the last outstanding method in the current block, runs the next block. If\n  // there are no more methods, consider accepting a hot code push.\n  _outstandingMethodFinished: function () {\n    var self = this;\n    if (self._anyMethodsAreOutstanding())\n      return;\n\n    // No methods are outstanding. This should mean that the first block of\n    // methods is empty. (Or it might not exist, if this was a method that\n    // half-finished before disconnect/reconnect.)\n    if (! _.isEmpty(self._outstandingMethodBlocks)) {\n      var firstBlock = self._outstandingMethodBlocks.shift();\n      if (! _.isEmpty(firstBlock.methods))\n        throw new Error(\"No methods outstanding but nonempty block: \" +\n                        JSON.stringify(firstBlock));\n\n      // Send the outstanding methods now in the first block.\n      if (!_.isEmpty(self._outstandingMethodBlocks))\n        self._sendOutstandingMethods();\n    }\n\n    // Maybe accept a hot code push.\n    self._maybeMigrate();\n  },\n\n  // Sends messages for all the methods in the first block in\n  // _outstandingMethodBlocks.\n  _sendOutstandingMethods: function() {\n    var self = this;\n    if (_.isEmpty(self._outstandingMethodBlocks))\n      return;\n    _.each(self._outstandingMethodBlocks[0].methods, function (m) {\n      m.sendMessage();\n    });\n  },\n\n  _livedata_error: function (msg) {\n    Meteor._debug(\"Received error from server: \", msg.reason);\n    if (msg.offendingMessage)\n      Meteor._debug(\"For: \", msg.offendingMessage);\n  },\n\n  _callOnReconnectAndSendAppropriateOutstandingMethods: function() {\n    var self = this;\n    var oldOutstandingMethodBlocks = self._outstandingMethodBlocks;\n    self._outstandingMethodBlocks = [];\n\n    self.onReconnect();\n\n    if (_.isEmpty(oldOutstandingMethodBlocks))\n      return;\n\n    // We have at least one block worth of old outstanding methods to try\n    // again. First: did onReconnect actually send anything? If not, we just\n    // restore all outstanding methods and run the first block.\n    if (_.isEmpty(self._outstandingMethodBlocks)) {\n      self._outstandingMethodBlocks = oldOutstandingMethodBlocks;\n      self._sendOutstandingMethods();\n      return;\n    }\n\n    // OK, there are blocks on both sides. Special case: merge the last block of\n    // the reconnect methods with the first block of the original methods, if\n    // neither of them are \"wait\" blocks.\n    if (!_.last(self._outstandingMethodBlocks).wait &&\n        !oldOutstandingMethodBlocks[0].wait) {\n      _.each(oldOutstandingMethodBlocks[0].methods, function (m) {\n        _.last(self._outstandingMethodBlocks).methods.push(m);\n\n        // If this \"last block\" is also the first block, send the message.\n        if (self._outstandingMethodBlocks.length === 1)\n          m.sendMessage();\n      });\n\n      oldOutstandingMethodBlocks.shift();\n    }\n\n    // Now add the rest of the original blocks on.\n    _.each(oldOutstandingMethodBlocks, function (block) {\n      self._outstandingMethodBlocks.push(block);\n    });\n  },\n\n  // We can accept a hot code push if there are no methods in flight.\n  _readyToMigrate: function() {\n    var self = this;\n    return _.isEmpty(self._methodInvokers);\n  },\n\n  // If we were blocking a migration, see if it's now possible to continue.\n  // Call whenever the set of outstanding/blocked methods shrinks.\n  _maybeMigrate: function () {\n    var self = this;\n    if (self._retryMigrate && self._readyToMigrate()) {\n      self._retryMigrate();\n      self._retryMigrate = null;\n    }\n  }\n});\n\nLivedataTest.Connection = Connection;\n\n// @param url {String} URL to Meteor app,\n//     e.g.:\n//     \"subdomain.meteor.com\",\n//     \"http://subdomain.meteor.com\",\n//     \"/\",\n//     \"ddp+sockjs://ddp--****-foo.meteor.com/sockjs\"\n\n/**\n * @summary Connect to the server of a different Meteor application to subscribe to its document sets and invoke its remote methods.\n * @locus Anywhere\n * @param {String} url The URL of another Meteor application.\n */\nDDP.connect = function (url, options) {\n  var ret = new Connection(url, options);\n  allConnections.push(ret); // hack. see below.\n  return ret;\n};\n\n// Hack for `spiderable` package: a way to see if the page is done\n// loading all the data it needs.\n//\nallConnections = [];\nDDP._allSubscriptionsReady = function () {\n  return _.all(allConnections, function (conn) {\n    return _.all(conn._subscriptions, function (sub) {\n      return sub.ready;\n    });\n  });\n};\n","// Meteor.refresh can be called on the client (if you're in common code) but it\n// only has an effect on the server.\nMeteor.refresh = function (notification) {\n};\n\nif (Meteor.isClient) {\n  // By default, try to connect back to the same endpoint as the page\n  // was served from.\n  //\n  // XXX We should be doing this a different way. Right now we don't\n  // include ROOT_URL_PATH_PREFIX when computing ddpUrl. (We don't\n  // include it on the server when computing\n  // DDP_DEFAULT_CONNECTION_URL, and we don't include it in our\n  // default, '/'.) We get by with this because DDP.connect then\n  // forces the URL passed to it to be interpreted relative to the\n  // app's deploy path, even if it is absolute. Instead, we should\n  // make DDP_DEFAULT_CONNECTION_URL, if set, include the path prefix;\n  // make the default ddpUrl be '' rather that '/'; and make\n  // _translateUrl in stream_client_common.js not force absolute paths\n  // to be treated like relative paths. See also\n  // stream_client_common.js #RationalizingRelativeDDPURLs\n  var ddpUrl = '/';\n  if (typeof __meteor_runtime_config__ !== \"undefined\") {\n    if (__meteor_runtime_config__.DDP_DEFAULT_CONNECTION_URL)\n      ddpUrl = __meteor_runtime_config__.DDP_DEFAULT_CONNECTION_URL;\n  }\n\n  var retry = new Retry();\n\n  var onDDPVersionNegotiationFailure = function (description) {\n    Meteor._debug(description);\n    if (Package.reload) {\n      var migrationData = Package.reload.Reload._migrationData('livedata') || {};\n      var failures = migrationData.DDPVersionNegotiationFailures || 0;\n      ++failures;\n      Package.reload.Reload._onMigrate('livedata', function () {\n        return [true, {DDPVersionNegotiationFailures: failures}];\n      });\n      retry.retryLater(failures, function () {\n        Package.reload.Reload._reload();\n      });\n    }\n  };\n\n  Meteor.connection =\n    DDP.connect(ddpUrl, {\n      onDDPVersionNegotiationFailure: onDDPVersionNegotiationFailure\n    });\n\n  // Proxy the public methods of Meteor.connection so they can\n  // be called directly on Meteor.\n  _.each(['subscribe', 'methods', 'call', 'apply', 'status', 'reconnect',\n          'disconnect'],\n         function (name) {\n           Meteor[name] = _.bind(Meteor.connection[name], Meteor.connection);\n         });\n} else {\n  // Never set up a default connection on the server. Don't even map\n  // subscribe/call/etc onto Meteor.\n  Meteor.connection = null;\n}\n\n// Meteor.connection used to be called\n// Meteor.default_connection. Provide backcompat as a courtesy even\n// though it was never documented.\n// XXX COMPAT WITH 0.6.4\nMeteor.default_connection = Meteor.connection;\n\n// We should transition from Meteor.connect to DDP.connect.\n// XXX COMPAT WITH 0.6.4\nMeteor.connect = DDP.connect;\n"]}}]